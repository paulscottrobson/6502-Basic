
; 64tass Turbo Assembler Macro V1.55.2200 listing file
; 64tass -Walias -Wmacro-prefix -Wall -q -c -L ../source/bin/basic.lst -l ../source/bin/basic.lbl -Wall -o ../source/bin/basic.prg basic.asm
; Sat Mar  6 20:08:54 2021

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: main/00header/01common.inc


;******  Processing file: main/00header/../../generated/installed.inc

=1					installed_main = 1
=1					installed_variable = 1
=1					installed_assembler = 1
=1					installed_error = 1
=1					installed_extension = 1
=1					installed_string = 1
=1					installed_device = 1
=0					installed_floatingpoint = 0
=1					installed_interaction = 1
=1					installed_tokeniser = 1

;******  Return to file: main/00header/01common.inc

=$1000					CodeStart = $1000
=$800					MemoryStorage = $800
=$02					ZeroPageStorage = $02
=8					StackSize = 8
=512					retStackSize = 512
=8					hashTableSize = 8			; if this changes, the calculation is AccessSetup has to match it.
="G"					markerGOSUB = 'G'
="R"					markerREPEAT = 'R'
="F"					markerFOR = 'F'
="W"					markerWHILE = 'W'
="P"					markerPROC = 'P'
="$"					markerSTRING = '$'
="#"					markerFLOAT = '#'
="%"					markerINT = '%'
=5					VarHSize = 5 								; header (2 link, 2 name, 1 hash)
=5					VarASize = 5 								; array [address,size,byteSize]
=4					VarISize = 4 								; integer (32 bit)
=6					VarFSize = 6 								; float (4 mantissa, 1 exponent 1 sign/zero)
=2					VarSSize = 2 								; address (2 bytes)

;******  Return to file: basic.asm


;******  Processing file: main/00header/02macros.inc


;******  Return to file: basic.asm


;******  Processing file: main/00header/03data.inc

>0002					codePtr:.fill 	2							; (codePtr),y points to code.
>0004					temp0: 	.fill 	2							; working variables.
>0006					temp1: 	.fill 	2
>0008					temp2: 	.fill 	2
>000a					temp3: 	.fill 	2
.000c					tempshort:
>000c							.fill 	1
.000d					highMemory:
>000d							.fill 	2
.000f					lowMemory:
>000f							.fill 	2
>0040					esType:	.fill 	StackSize  					; type byte (see above)
>0048					esInt0:	.fill 	StackSize 					; integer or mantissa
>0050					esInt1:	.fill 	StackSize
>0058					esInt2:	.fill 	StackSize
>0060					esInt3:	.fill 	StackSize
>0068					esExp:	.fill 	StackSize 					; exponent ($80 = 0)
>0070					esZSign:.fill 	StackSize 					; for floating point - sign (bit 7) isZero (bit 6)
=$48					esMant0 = esInt0 							; synonyms.
=$50					esMant1 = esInt1
=$58					esMant2 = esInt2
=$60					esMant3 = esInt3
>0800							.align	256
.0800					returnStack:
>0800							.fill 	retStackSize
>0a00							.align	256
.0a00					SingleLetterVar:
>0a00					 		.fill 	26*4
.0a68					hashTables:
>0a68							.fill 	6*2*hashTableSize
.0ac8					basePage:
>0ac8							.fill 	2
.0aca					endMemory:
>0aca							.fill 	2
.0acc					NullString:
>0acc							.fill 	1							; don't waste memory concreting null strings.
.0acd					convertBuffer:
>0acd							.fill 	35

;******  Processing file: main/00header/../../generated/tokenconst.inc

=$80					TOK_EOL=$80
=$81					TOK_SHIFT1=$81
=$82					TOK_SHIFT2=$82
=$83					TOK_SHIFT3=$83
=$84					TOK_FPC=$84
=$85					TOK_STR=$85
=$86					TOK_BINARYST=$86
=$99					TOK_STRUCTST=$99
=$a4					TOK_UNARYST=$a4
=$c6					TOK_TOKENS=$c6
=$86					TKW_AND                      = $86 ; and
=$87					TKW_OR                       = $87 ; or
=$88					TKW_XOR                      = $88 ; xor
=$89					TKW_GREATEREQUAL             = $89 ; >=
=$8a					TKW_LESSEQUAL                = $8a ; <=
=$8b					TKW_GREATER                  = $8b ; >
=$8c					TKW_LESS                     = $8c ; <
=$8d					TKW_EQUAL                    = $8d ; =
=$8e					TKW_LESSGREATER              = $8e ; <>
=$8f					TKW_PLUS                     = $8f ; +
=$90					TKW_MINUS                    = $90 ; -
=$91					TKW_GREATERGREATER           = $91 ; >>
=$92					TKW_LESSLESS                 = $92 ; <<
=$93					TKW_STAR                     = $93 ; *
=$94					TKW_SLASH                    = $94 ; /
=$95					TKW_MOD                      = $95 ; mod
=$96					TKW_HAT                      = $96 ; ^
=$97					TKW_PLING                    = $97 ; !
=$98					TKW_QMARK                    = $98 ; ?
=$99					TKW_REPEAT                   = $99 ; repeat
=$9a					TKW_WHILE                    = $9a ; while
=$9b					TKW_FOR                      = $9b ; for
=$9c					TKW_IF                       = $9c ; if
=$9d					TKW_DEFPROC                  = $9d ; defproc
=$9e					TKW_UNTIL                    = $9e ; until
=$9f					TKW_WEND                     = $9f ; wend
=$a0					TKW_NEXT                     = $a0 ; next
=$a1					TKW_THEN                     = $a1 ; then
=$a2					TKW_ENDIF                    = $a2 ; endif
=$a3					TKW_ENDPROC                  = $a3 ; endproc
=$a4					TKW_LPAREN                   = $a4 ; (
=$a5					TKW_LENLPAREN                = $a5 ; len(
=$a6					TKW_SGNLPAREN                = $a6 ; sgn(
=$a7					TKW_ABSLPAREN                = $a7 ; abs(
=$a8					TKW_RANDOMLPAREN             = $a8 ; random(
=$a9					TKW_PAGE                     = $a9 ; page
=$aa					TKW_TRUE                     = $aa ; true
=$ab					TKW_FALSE                    = $ab ; false
=$ac					TKW_MINLPAREN                = $ac ; min(
=$ad					TKW_MAXLPAREN                = $ad ; max(
=$ae					TKW_SYSLPAREN                = $ae ; sys(
=$af					TKW_TIMERLPAREN              = $af ; timer(
=$b0					TKW_EVENTLPAREN              = $b0 ; event(
=$b1					TKW_GETLPAREN                = $b1 ; get(
=$b2					TKW_INKEYLPAREN              = $b2 ; inkey(
=$b3					TKW_ALLOCLPAREN              = $b3 ; alloc(
=$b4					TKW_CHRDOLLARLPAREN          = $b4 ; chr$(
=$b5					TKW_LEFTDOLLARLPAREN         = $b5 ; left$(
=$b6					TKW_MIDDOLLARLPAREN          = $b6 ; mid$(
=$b7					TKW_RIGHTDOLLARLPAREN        = $b7 ; right$(
=$b8					TKW_STRDOLLARLPAREN          = $b8 ; str$(
=$b9					TKW_VALLPAREN                = $b9 ; val(
=$ba					TKW_PEEKLPAREN               = $ba ; peek(
=$bb					TKW_DEEKLPAREN               = $bb ; deek(
=$bc					TKW_LEEKLPAREN               = $bc ; leek(
=$bd					TKW_ASCLPAREN                = $bd ; asc(
=$be					TKW_INTLPAREN                = $be ; int(
=$bf					TKW_FLOATLPAREN              = $bf ; float(
=$c0					TKW_ISVALLPAREN              = $c0 ; isval(
=$c1					TKW_UPPERDOLLARLPAREN        = $c1 ; upper$(
=$c2					TKW_LOWERDOLLARLPAREN        = $c2 ; lower$(
=$c3					TKW_AT                       = $c3 ; @
=$c4					TKW_WAVY                     = $c4 ; ~
=$c5					TKW_AMP                      = $c5 ; &
=$c6					TKW_RPAREN                   = $c6 ; )
=$c7					TKW_COLON                    = $c7 ; :
=$c8					TKW_COMMA                    = $c8 ; ,
=$c9					TKW_SEMICOLON                = $c9 ; ;
=$ca					TKW_QUOTE                    = $ca ; '
=$cb					TKW_TO                       = $cb ; to
=$cc					TKW_STEP                     = $cc ; step
=$cd					TKW_PROC                     = $cd ; proc
=$ce					TKW_LOCAL                    = $ce ; local
=$cf					TKW_DIM                      = $cf ; dim
=$d0					TKW_REM                      = $d0 ; rem
=$d1					TKW_LET                      = $d1 ; let
=$d2					TKW_INPUT                    = $d2 ; input
=$d3					TKW_ELSE                     = $d3 ; else
=$d4					TKW_VDU                      = $d4 ; vdu
=$d5					TKW_PRINT                    = $d5 ; print
=$d6					TKW_GOTO                     = $d6 ; goto
=$d7					TKW_GOSUB                    = $d7 ; gosub
=$d8					TKW_RETURN                   = $d8 ; return
=$d9					TKW_DATA                     = $d9 ; data
=$da					TKW_ASSERT                   = $da ; assert
=$db					TKW_POKE                     = $db ; poke
=$dc					TKW_DOKE                     = $dc ; doke
=$dd					TKW_LOKE                     = $dd ; loke
=$86					TKW_CLEAR                    = $86 ; clear
=$87					TKW_LOAD                     = $87 ; load
=$88					TKW_SAVE                     = $88 ; save
=$89					TKW_LIST                     = $89 ; list
=$8a					TKW_NEW                      = $8a ; new
=$8b					TKW_RUN                      = $8b ; run
=$8c					TKW_READ                     = $8c ; read
=$8d					TKW_RESTORE                  = $8d ; restore
=$8e					TKW_END                      = $8e ; end
=$8f					TKW_STOP                     = $8f ; stop
=$86					TKW_VPOKE                    = $86 ; vpoke
=$87					TKW_VDOKE                    = $87 ; vdoke
=$86					TKW_VPEEKLPAREN              = $86 ; vpeek(
=$87					TKW_VDEEKLPAREN              = $87 ; vdeek(

;******  Return to file: main/00header/03data.inc

=$3a					TYPE_INT =		($3A) 						; type bytes that end identifier.
=$3b					TYPE_INTARRAY =	($3B)
=$3c					TYPE_STR =		($3C)
=$3d					TYPE_STRARRAY =	($3D)
=$3e					TYPE_FLOAT =	($3E)
=$3f					TYPE_FLOATARRAY=($3F)

;******  Return to file: basic.asm


;******  Processing file: main/imath/intmacros.inc


;******  Return to file: basic.asm


;******  Processing file: main/main.inc


;******  Return to file: basic.asm


;******  Processing file: assembler/assembler.inc


;******  Return to file: basic.asm


;******  Processing file: device/device.inc


;******  Return to file: basic.asm


;******  Processing file: error/error.inc


;******  Return to file: basic.asm


;******  Processing file: error/errorhandler.inc


;******  Processing file: error/../generated/errorid.inc

=1					ErrorID_Missing = 1 ; Feature not Present
=2					ErrorID_Syntax = 2 ; Syntax Error
=3					ErrorID_NoModule = 3 ; Module disabled
=4					ErrorID_Assert = 4 ; Assertion failed
=5					ErrorID_DivZero = 5 ; Divide By Zero
=6					ErrorID_Stop = 6 ; Stop
=7					ErrorID_BadType = 7 ; Type Mismatch
=8					ErrorID_BadValue = 8 ; Illegal Value
=9					ErrorID_MissingRP = 9 ; Missing right bracket
=10					ErrorID_MissingComma = 10 ; Missing comma
=11					ErrorID_NoReference = 11 ; Missing reference
=12					ErrorID_LineNumber = 12 ; Line Number not found
=13					ErrorID_StrLen = 13 ; String too long.
=14					ErrorID_ReturnErr = 14 ; RETURN without GOSUB
=15					ErrorID_UntilErr = 15 ; UNTIL without REPEAT
=16					ErrorID_NextErr = 16 ; NEXT without FOR
=17					ErrorID_WendErr = 17 ; WEND without WHILE
=18					ErrorID_endprocErr = 18 ; ENDPROC without PROC
=19					ErrorID_BadIndex = 19 ; Bad NEXT index
=20					ErrorID_Struct = 20 ; Structures nested wrong
=21					ErrorID_NoAuto = 21 ; Cannot create variable
=22					ErrorID_RetStack = 22 ; Return stack out of space.
=23					ErrorID_NoProc = 23 ; Unknown Procedure
=24					ErrorID_Params = 24 ; Parameters do not match.
=25					ErrorID_DupArray = 25 ; Array already defined
=26					ErrorID_NotArray = 26 ; DIM requires array
=27					ErrorID_ArrayIndex = 27 ; Bad array index.

;******  Return to file: error/errorhandler.inc


;******  Return to file: basic.asm


;******  Processing file: extension/extension.inc


;******  Return to file: basic.asm


;******  Processing file: floatingpoint/floatingpoint.inc


;******  Return to file: basic.asm


;******  Processing file: interaction/interaction.inc


;******  Return to file: basic.asm


;******  Processing file: string/memory.inc

=252					MaxStringSize = 252

;******  Return to file: basic.asm


;******  Processing file: string/string.inc


;******  Return to file: basic.asm


;******  Processing file: tokeniser/tokeniser.inc


;******  Return to file: basic.asm


;******  Processing file: variable/variable.inc


;******  Return to file: basic.asm

.1000					section_start_main:

;******  Processing file: main/main.asm


;******  Processing file: main/00header/00start.asm

.1000	a2 ff		ldx #$ff	Start:	ldx 	#$FF
.1002	9a		txs				txs
.1003	a2 02		ldx #$02		ldx	#2
.1005	20 27 22	jsr $2227		jsr	deviceHandler
.1008	a9 00		lda #$00			lda 	#(testBaseAddress) & $FF
.100a	8d c8 0a	sta $0ac8			sta 	basePage
.100d	a9 50		lda #$50			lda 	#(testBaseAddress) >> 8
.100f	8d c9 0a	sta $0ac9			sta 	1+(basePage)
.1012	a9 00		lda #$00			lda 	#($9800) & $FF
.1014	8d ca 0a	sta $0aca			sta 	endMemory
.1017	a9 98		lda #$98			lda 	#($9800) >> 8
.1019	8d cb 0a	sta $0acb			sta 	1+(endMemory)
.101c	4c 27 14	jmp $1427			jmp 	Command_Run
.2a8e					ReturnPos:
.5000					testBaseAddress:

;******  Processing file: main/00header/../../generated/testcode.inc

>5000	08 0a 00 d9 85 01 50 80			.byte 8,10,0,217,133,1,80,128,12,11,0,213,133,5,83,84,65,82,84,128,17,12,0,207,3,59,69,198,200,14,1,13,5,61,66,198,128,17,13,0,129,140,1,58,200,2,50,58,200,3,59,67,198,128,16,14,0,213,1,58,200,2,50,58,200,3,59,67,198,128,26,15,0,155,9,58,141,65,203,66,199,129,140,14,1,13,5,61,9,58,198,199,160,9,58,128,25,16,0,155,9,58,141,65,203,66,199,213,14,1,13,5,61,9,58,198,199,160,9,58,128,18,17,0,217,76,200,77,200,78,199,213,133,4,78,69,88,84,128,14,18,0,213,133,7,84,69,88,84,73,69,83,128,18,19,0,217,133,4,80,97,117,108,200,133,4,74,97,110,101,128,11,20,0,213,133,4,68,79,78,69,128,8,21,0,153,199,158,171,128,4,22,0,128,4,23,0,128,0
>5008	0c 0b 00 d5 85 05 53 54 41 52 54 80 11 0c 00 cf
>5018	03 3b 45 c6 c8 0e 01 0d 05 3d 42 c6 80 11 0d 00
>5028	81 8c 01 3a c8 02 32 3a c8 03 3b 43 c6 80 10 0e
>5038	00 d5 01 3a c8 02 32 3a c8 03 3b 43 c6 80 1a 0f
>5048	00 9b 09 3a 8d 41 cb 42 c7 81 8c 0e 01 0d 05 3d
>5058	09 3a c6 c7 a0 09 3a 80 19 10 00 9b 09 3a 8d 41
>5068	cb 42 c7 d5 0e 01 0d 05 3d 09 3a c6 c7 a0 09 3a
>5078	80 12 11 00 d9 4c c8 4d c8 4e c7 d5 85 04 4e 45
>5088	58 54 80 0e 12 00 d5 85 07 54 45 58 54 49 45 53
>5098	80 12 13 00 d9 85 04 50 61 75 6c c8 85 04 4a 61
>50a8	6e 65 80 0b 14 00 d5 85 04 44 4f 4e 45 80 08 15
>50b8	00 99 c7 9e ab 80 04 16 00 80 04 17 00 80 00

;******  Return to file: main/00header/00start.asm


;******  Return to file: main/main.asm


;******  Processing file: main/commands/assert.asm

.101f					Command_Assert:
.101f	20 dd 1a	jsr $1add			jsr 	EvaluateRootInteger 		; what is being asserted.
.1022	20 21 21	jsr $2121			jsr 	MInt32Zero 					; is it true ?
.1025	f0 01		beq $1028			beq 	_CAError
.1027	60		rts				rts
.1028					_CAError:
.1028	a2 04		ldx #$04			ldx 	#ErrorID_Assert
.102a	20 36 22	jsr $2236		jsr	errorHandler

;******  Return to file: main/main.asm


;******  Processing file: main/commands/clear.asm

.102d					CommandClear:
.102d	98		tya				tya
.102e	48		pha				pha
.102f	ad ca 0a	lda $0aca			lda 	endMemory					; set high memory = end of memory
.1032	85 0d		sta $0d				sta 	highMemory
.1034	ad cb 0a	lda $0acb			lda 	endMemory+1
.1037	85 0e		sta $0e				sta 	highMemory+1
.1039	ad c8 0a	lda $0ac8			lda 	basePage 					; work out where the program ends.
.103c	85 04		sta $04				sta 	temp0
.103e	ad c9 0a	lda $0ac9			lda 	basePage+1
.1041	85 05		sta $05				sta 	temp0+1
.1043					_CCFindEnd:
.1043	a0 00		ldy #$00			ldy 	#0
.1045	b1 04		lda ($04),y			lda 	(temp0),y
.1047	f0 0c		beq $1055			beq 	_CCFoundEnd 				; offset zero is end.
.1049	18		clc				clc
.104a	65 04		adc $04				adc 	temp0 						; move to next line
.104c	85 04		sta $04				sta 	temp0
.104e	90 f3		bcc $1043			bcc 	_CCFindEnd
.1050	e6 05		inc $05				inc 	temp0+1
.1052	4c 43 10	jmp $1043			jmp 	_CCFindEnd
.1055					_CCFoundEnd:
.1055	a5 04		lda $04				lda 	temp0 						; put temp0 in lowMemory
.1057	85 0f		sta $0f				sta 	lowMemory
.1059	a5 05		lda $05				lda 	temp0+1
.105b	85 10		sta $10				sta 	lowMemory+1
.105d	a9 04		lda #$04			lda 	#4 							; skip low free memory clear, leave a gap.
.105f	20 73 10	jsr $1073			jsr 	AdvanceLowMemoryByte		; need at least one here, to skip the end of program zero offset.
.1062	20 87 21	jsr $2187			jsr 	RSReset 					; reset the return stack.
.1065	a2 04		ldx #$04		ldx	#4
.1067	20 85 2a	jsr $2a85		jsr	variableHandler
.106a	20 d4 15	jsr $15d4			jsr 	ScanProc 					; scan for procedures
.106d	20 e8 13	jsr $13e8			jsr 	CommandRestore 				; do a restore
.1070	68		pla				pla
.1071	a8		tay				tay
.1072	60		rts				rts
.1073					AdvanceLowMemoryByte:
.1073	18		clc				clc
.1074	65 0f		adc $0f				adc 	lowMemory
.1076	85 0f		sta $0f				sta 	lowMemory
.1078	90 02		bcc $107c			bcc 	_ALMBExit
.107a	e6 10		inc $10				inc 	lowMemory+1
.107c					_ALMBExit:
.107c	60		rts				rts

;******  Return to file: main/main.asm


;******  Processing file: main/commands/dim.asm

.107d					Command_Dim:
.107d	a2 02		ldx #$02		ldx	#2
.107f	20 85 2a	jsr $2a85		jsr	variableHandler
.1082	b1 02		lda ($02),y			lda 	(codePtr),y 				; see what follows.
.1084	c8		iny				iny
.1085	c9 c8		cmp #$c8			cmp 	#TKW_COMMA 					; comma follows, go back and do next
.1087	f0 f4		beq $107d			beq 	Command_Dim
.1089	88		dey				dey 								; unpick get
.108a	60		rts				rts

;******  Return to file: main/main.asm


;******  Processing file: main/commands/for.asm

.2a8e					Command_FOR:
.2a8e	a9 46		lda #$46			lda 	#markerFOR 					; allocate the space.
.2a90	a2 0b		ldx #$0b			ldx 	#11
.2a92	20 95 21	jsr $2195			jsr 	RSClaim
.2a95	20 c7 10	jsr $10c7			jsr 	CommandLET 					; do the same as LET.
.2a98	a5 40		lda $40				lda 	esType 						; check type should be integer reference.
.2a9a	c9 80		cmp #$80			cmp 	#$80
.2a9c	d0 4c		bne $2aea			bne 	_CFType
.2a9e	a9 cb		lda #$cb			lda 	#TKW_TO 					; check TO present.
.2aa0	20 62 21	jsr $2162			jsr 	CheckToken
.2aa3	a2 01		ldx #$01			ldx 	#1 							; keep the variable address in stack 0
.2aa5	20 df 1a	jsr $1adf			jsr 	EvaluateInteger				; get terminal value in stack 1
.2aa8	98		tya				tya
.2aa9	48		pha				pha
.2aaa	a0 04		ldy #$04			ldy 	#4
.2aac	a5 48		lda $48				lda		esInt0 						; the address of the index into 4 and 5
.2aae	91 78		sta ($78),y			sta 	(rsPointer),y
.2ab0	c8		iny				iny
.2ab1	a5 50		lda $50				lda		esInt1
.2ab3	91 78		sta ($78),y			sta 	(rsPointer),y
.2ab5	c8		iny				iny
.2ab6	a9 01		lda #$01			lda 	#1  						; the default step in 6
.2ab8	91 78		sta ($78),y			sta 	(rsPointer),y
.2aba	c8		iny				iny
.2abb	a5 49		lda $49				lda		esInt0+1 					; terminal value in 7 to 11.
.2abd	91 78		sta ($78),y			sta 	(rsPointer),y
.2abf	c8		iny				iny
.2ac0	a5 51		lda $51				lda		esInt1+1
.2ac2	91 78		sta ($78),y			sta 	(rsPointer),y
.2ac4	c8		iny				iny
.2ac5	a5 59		lda $59				lda		esInt2+1
.2ac7	91 78		sta ($78),y			sta 	(rsPointer),y
.2ac9	c8		iny				iny
.2aca	a5 61		lda $61				lda		esInt3+1
.2acc	91 78		sta ($78),y			sta 	(rsPointer),y
.2ace	68		pla				pla
.2acf	a8		tay				tay
.2ad0	b1 02		lda ($02),y			lda 	(codePtr),y 				; followed by STEP.
.2ad2	c9 cc		cmp #$cc			cmp 	#TKW_STEP
.2ad4	d0 0e		bne $2ae4			bne 	_CFDone
.2ad6	c8		iny				iny									; skip over step.
.2ad7	20 df 1a	jsr $1adf			jsr 	EvaluateInteger 			; get step
.2ada	98		tya				tya
.2adb	48		pha				pha
.2adc	b5 48		lda $48,x			lda 	esInt0,x 					; copy it into step (bit lazy here)
.2ade	a0 06		ldy #$06			ldy 	#6
.2ae0	91 78		sta ($78),y			sta 	(rsPointer),y
.2ae2	68		pla				pla
.2ae3	a8		tay				tay
.2ae4					_CFDone:
.2ae4	a9 01		lda #$01			lda 	#1
.2ae6	20 c1 21	jsr $21c1			jsr 	RSSavePosition 				; save position.
.2ae9	60		rts				rts
.2aea					_CFType:
.2aea	a2 07		ldx #$07			ldx 	#ErrorID_BadType
.2aec	20 36 22	jsr $2236		jsr	errorHandler
.2aef					Command_NEXT:
.2aef	a2 00		ldx #$00			ldx 	#0 							; get TOS return stack
.2af1	a1 78		lda ($78,x)			lda 	(rsPointer,x)
.2af3	c9 46		cmp #$46			cmp 	#markerFOR 						; does it match
.2af5	f0 05		beq $2afc			beq 	_isok
.2af7	a2 10		ldx #$10			ldx 	#ErrorID_nextErr
.2af9	20 36 22	jsr $2236		jsr	errorHandler
.2afc					_isok:
.2afc	b1 02		lda ($02),y			lda 	(codePtr),y 				; is it NEXT <index>
.2afe	c9 40		cmp #$40			cmp 	#$40 						; e.g. a variable follows 00-3F
.2b00	b0 18		bcs $2b1a			bcs 	_CNNoIndex
.2b02	a2 00		ldx #$00			ldx 	#0 							; start on stack
.2b04	20 0c 1b	jsr $1b0c			jsr 	EvaluateReference 			; this is the variable/parameter to localise.
.2b07	98		tya				tya
.2b08	48		pha				pha
.2b09	a0 04		ldy #$04			ldy 	#4 							; check same variable
.2b0b	b1 78		lda ($78),y			lda 	(rsPointer),y
.2b0d	d5 48		cmp $48,x			cmp 	esInt0,x
.2b0f	d0 76		bne $2b87			bne 	_CNBadIndex
.2b11	c8		iny				iny
.2b12	b1 78		lda ($78),y			lda 	(rsPointer),y
.2b14	d5 50		cmp $50,x			cmp 	esInt1,x
.2b16	d0 6f		bne $2b87			bne 	_CNBadIndex
.2b18	68		pla				pla
.2b19	a8		tay				tay
.2b1a					_CNNoIndex:
.2b1a	98		tya				tya
.2b1b	48		pha				pha
.2b1c	a0 04		ldy #$04			ldy 	#4 							; make temp0 point to the index
.2b1e	b1 78		lda ($78),y			lda 	(rsPointer),y
.2b20	85 04		sta $04				sta 	temp0
.2b22	c8		iny				iny
.2b23	b1 78		lda ($78),y			lda 	(rsPointer),y
.2b25	85 05		sta $05				sta 	temp0+1
.2b27	c8		iny				iny
.2b28	a2 00		ldx #$00			ldx 	#0 							; X is the sign extend part of the step.
.2b2a	b1 78		lda ($78),y			lda 	(rsPointer),y 				; get the step.
.2b2c	85 09		sta $09				sta 	temp2+1 					; save for later.
.2b2e	10 01		bpl $2b31			bpl 	_CNSignX
.2b30	ca		dex				dex  								; X = $FF
.2b31					_CNSignX:
.2b31	18		clc				clc 								; add to the LSB
.2b32	a0 00		ldy #$00			ldy 	#0
.2b34	71 04		adc ($04),y			adc 	(temp0),y
.2b36	91 04		sta ($04),y			sta 	(temp0),y
.2b38					_CNPropogate:
.2b38	c8		iny				iny  								; add the sign extended in X to the rest.
.2b39	8a		txa				txa
.2b3a	71 04		adc ($04),y			adc 	(temp0),y
.2b3c	91 04		sta ($04),y			sta 	(temp0),y
.2b3e	c8		iny				iny
.2b3f	8a		txa				txa
.2b40	71 04		adc ($04),y			adc 	(temp0),y
.2b42	91 04		sta ($04),y			sta 	(temp0),y
.2b44	c8		iny				iny
.2b45	8a		txa				txa
.2b46	71 04		adc ($04),y			adc 	(temp0),y
.2b48	91 04		sta ($04),y			sta 	(temp0),y
.2b4a	18		clc				clc 								; point temp1 to the terminal value stored in the stack.
.2b4b	a5 78		lda $78				lda 	rsPointer
.2b4d	69 07		adc #$07			adc 	#7
.2b4f	85 06		sta $06				sta 	temp1
.2b51	a9 00		lda #$00			lda 	#0
.2b53	85 08		sta $08				sta 	temp2 						; clear temp2, which is the OR of all the subtractions.
.2b55	a8		tay				tay 								; and clear the Y register again.
.2b56	65 79		adc $79				adc 	rsPointer+1
.2b58	85 07		sta $07				sta 	temp1+1
.2b5a	38		sec				sec 								; calculate current - limit oring interim values.
.2b5b	20 93 2b	jsr $2b93			jsr 	_CNCompare
.2b5e	20 93 2b	jsr $2b93			jsr 	_CNCompare
.2b61	20 93 2b	jsr $2b93			jsr 	_CNCompare
.2b64	20 93 2b	jsr $2b93			jsr 	_CNCompare
.2b67	50 02		bvc $2b6b			bvc 	_CNNoOverflow 				; converts to a signed comparison on the sign bit.
.2b69	49 80		eor #$80			eor 	#$80
.2b6b					_CNNoOverflow:
.2b6b	a4 09		ldy $09				ldy 	temp2+1						; get step back
.2b6d	30 1d		bmi $2b8c			bmi 	_CNCheckDownto
.2b6f	c9 00		cmp #$00			cmp 	#0
.2b71	30 0c		bmi $2b7f			bmi 	_CNLoopRound 				; loop round if < =
.2b73	a5 08		lda $08				lda 	temp2
.2b75	f0 08		beq $2b7f			beq 	_CNLoopRound
.2b77					_CNLoopExit:
.2b77	68		pla				pla
.2b78	a8		tay				tay
.2b79	a9 0b		lda #$0b			lda 	#11
.2b7b	20 b7 21	jsr $21b7			jsr 	RSFree
.2b7e	60		rts				rts
.2b7f					_CNLoopRound:
.2b7f	68		pla				pla
.2b80	a8		tay				tay
.2b81	a9 01		lda #$01			lda 	#1
.2b83	20 d4 21	jsr $21d4			jsr 	RSLoadPosition				; go back to the loop top
.2b86	60		rts				rts
.2b87					_CNBadIndex:
.2b87	a2 13		ldx #$13			ldx 	#ErrorID_BadIndex
.2b89	20 36 22	jsr $2236		jsr	errorHandler
.2b8c					_CNCheckDownto:
.2b8c	c9 00		cmp #$00			cmp 	#0
.2b8e	10 ef		bpl $2b7f			bpl 	_CNLoopRound
.2b90	4c 77 2b	jmp $2b77			jmp 	_CNLoopExit
.2b93					_CNCompare:
.2b93	b1 04		lda ($04),y			lda 	(temp0),y 					; do the subtraction - compare don't care about answer
.2b95	f1 06		sbc ($06),y			sbc 	(temp1),y
.2b97	05 08		ora $08				ora 	temp2 						; Or into temp2 (does not affect carry)
.2b99	85 08		sta $08				sta 	temp2
.2b9b	c8		iny				iny
.2b9c	60		rts				rts

;******  Return to file: main/main.asm


;******  Processing file: main/commands/if.asm

.108b					CommandIf:
.108b	20 dd 1a	jsr $1add			jsr 	EvaluateRootInteger 		; if what ?
.108e	b1 02		lda ($02),y			lda 	(codePtr),y 				; check for IF .. THEN or IF .. GOTO which are single lines.
.1090	c9 d6		cmp #$d6			cmp 	#TKW_GOTO
.1092	f0 04		beq $1098			beq 	_IfSimple
.1094	c9 a1		cmp #$a1			cmp 	#TKW_THEN
.1096	d0 1b		bne $10b3			bne 	_IfComplex
.1098					_IfSimple:
.1098	20 21 21	jsr $2121			jsr 	MInt32Zero					; check if TOS zero
.109b	f0 10		beq $10ad			beq 	_IfEOL 						; go to next line.
.109d	b1 02		lda ($02),y			lda 	(codePtr),y 				; get and skip token.
.109f	c8		iny				iny
.10a0	c9 d6		cmp #$d6			cmp 	#TKW_GOTO 					; was it if GOTO ?
.10a2	f0 0c		beq $10b0			beq 	_IfGoto 					; do the Goto code
.10a4	b1 02		lda ($02),y			lda 	(codePtr),y 				; what follows the THEN ?
.10a6	29 c0		and #$c0			and 	#$C0 						; check $40-$7F
.10a8	c9 40		cmp #$40			cmp 	#$40 						; e.g. number IF x = 0 THEN 170
.10aa	f0 04		beq $10b0			beq 	_IfGoto
.10ac	60		rts				rts 								; else continue on this line.
.10ad					_IfEOL:
.10ad	4c 48 16	jmp $1648			jmp 	AdvanceNextLine 			; go to next line
.10b0					_IfGoto:
.10b0	4c 87 16	jmp $1687			jmp 	CommandGoto
.10b3					_IfComplex:
.10b3	20 21 21	jsr $2121			jsr 	MInt32Zero 					; is it true ?
.10b6	f0 01		beq $10b9			beq 	_IFSkip 					; if non-zero then skip to ELSE/ENDIF
.10b8	60		rts				rts 								; else continue.
.10b9					_IFSkip:
.10b9	a9 d3		lda #$d3			lda	 	#TKW_ELSE 					; test failed, go to ELSE or ENDIF whichever comes first.
.10bb	a2 a2		ldx #$a2			ldx 	#TKW_ENDIF
.10bd	4c 06 2c	jmp $2c06			jmp		ScanForward
.10c0					Command_ELSE:
.10c0	a2 a2		ldx #$a2			ldx 	#TKW_ENDIF
.10c2	8a		txa				txa
.10c3	4c 06 2c	jmp $2c06			jmp		ScanForward
.10c6					Command_ENDIF:
.10c6	60		rts				rts

;******  Return to file: main/main.asm


;******  Processing file: main/commands/let.asm

.10c7					CommandLet:
.10c7	a2 00		ldx #$00			ldx 	#0  						; get address to write.
.10c9	20 0c 1b	jsr $1b0c			jsr 	EvaluateReference
.10cc	a9 8d		lda #$8d			lda 	#TKW_EQUAL 					; check for equals
.10ce	20 62 21	jsr $2162			jsr 	CheckToken
.10d1	e8		inx				inx 								; do RHS
.10d2	20 c0 1a	jsr $1ac0			jsr 	Evaluate 					; evaluate and derefernce
.10d5	ca		dex				dex
.10d6	20 da 10	jsr $10da			jsr 	WriteValue 					; write it out
.10d9	60		rts				rts
.10da					WriteValue:
.10da	98		tya				tya
.10db	48		pha				pha
.10dc	20 3c 11	jsr $113c			jsr 	TOSToTemp0 					; set temp0 to point to target address.
.10df	b5 40		lda $40,x			lda 	esType,x 					; check the string/integer flags match
.10e1	55 41		eor $41,x			eor 	esType+1,x
.10e3	29 40		and #$40			and 	#$40
.10e5	d0 50		bne $1137			bne		_WVType
.10e7	a0 01		ldy #$01			ldy 	#1 							; for string, copy 0 and 1.
.10e9	b5 40		lda $40,x			lda 	esType,x 					; check for string assignment
.10eb	29 40		and #$40			and 	#$40
.10ed	d0 1f		bne $110e			bne 	_WVCopyString
.10ef	b5 40		lda $40,x			lda 	esType,x 					; check both are integer.
.10f1	15 41		ora $41,x			ora 	esType+1,x
.10f3	4a		lsr a				lsr 	a
.10f4	90 22		bcc $1118			bcc 	_WVCopyData4
.10f6	b5 40		lda $40,x			lda 	esType,x
.10f8	4a		lsr a				lsr 	a
.10f9	90 3c		bcc $1137			bcc 	_WVType
.10fb	e8		inx				inx 								; force the value being written to be a float.
.10fc	20 f9 16	jsr $16f9			jsr 	BPMakeFloat
.10ff	ca		dex				dex
.1100	20 3c 11	jsr $113c			jsr 	TOSToTemp0 					; set Temp0 to write address
.1103	e8		inx				inx
.1104	8a		txa				txa
.1105	a2 20		ldx #$20		ldx	#32
.1107	20 21 25	jsr $2521		jsr	floatingpointHandler
.110a	aa		tax				tax
.110b	4c 34 11	jmp $1134			jmp 	_WVCopyExit
.110e					_WVCopyString:
.110e	8a		txa				txa
.110f	a2 0c		ldx #$0c		ldx	#12
.1111	20 bd 27	jsr $27bd		jsr	stringHandler
.1114	aa		tax				tax
.1115	4c 34 11	jmp $1134			jmp 	_WVCopyExit
.1118					_WVCopyData4:
.1118	b5 40		lda $40,x			lda 	esType,x 					; is the int ref a byte ref ?
.111a	29 20		and #$20			and 	#$20
.111c	d0 10		bne $112e			bne 	_WVCopyData1
.111e	a0 03		ldy #$03			ldy 	#3
.1120	b5 61		lda $61,x			lda 	esInt3+1,x
.1122	91 04		sta ($04),y			sta 	(temp0),y
.1124	88		dey				dey
.1125	b5 59		lda $59,x			lda 	esInt2+1,x
.1127	91 04		sta ($04),y			sta 	(temp0),y
.1129	88		dey				dey
.112a	b5 51		lda $51,x			lda 	esInt1+1,x
.112c	91 04		sta ($04),y			sta 	(temp0),y
.112e					_WVCopyData1:
.112e	a0 00		ldy #$00			ldy 	#0
.1130	b5 49		lda $49,x			lda 	esInt0+1,x
.1132	91 04		sta ($04),y			sta 	(temp0),y
.1134					_WVCopyExit:
.1134	68		pla				pla
.1135	a8		tay				tay
.1136	60		rts				rts
.1137					_WVType:
.1137	a2 07		ldx #$07			ldx 	#ErrorID_BadType
.1139	20 36 22	jsr $2236		jsr	errorHandler
.113c					TOSToTemp0:
.113c	b5 48		lda $48,x			lda 	esInt0,x
.113e	85 04		sta $04				sta 	temp0
.1140	b5 50		lda $50,x			lda 	esInt1,x
.1142	85 05		sta $05				sta 	temp0+1
.1144	60		rts				rts

;******  Return to file: main/main.asm


;******  Processing file: main/commands/local.asm

.0af0					storeSize:
>0af0							.fill 	1
.1145					CommandLocal:
.1145	a2 00		ldx #$00			ldx 	#0
.1147	20 63 11	jsr $1163			jsr 	LocaliseVariable 			; localise one.
.114a					_CLCheckNext:
.114a	b1 02		lda ($02),y			lda 	(codePtr),y 				; what follows ?
.114c	c8		iny				iny
.114d	c9 8d		cmp #$8d			cmp 	#TKW_EQUAL 					; local x = 2 ?
.114f	f0 06		beq $1157			beq 	_CLAssignment
.1151	c9 c8		cmp #$c8			cmp 	#TKW_COMMA 					; comma try again.
.1153	f0 f0		beq $1145			beq 	CommandLocal
.1155	88		dey				dey
.1156	60		rts				rts
.1157					_CLAssignment:
.1157	a2 01		ldx #$01			ldx 	#1
.1159	20 c0 1a	jsr $1ac0			jsr 	Evaluate 					; evaluate RHS
.115c	ca		dex				dex
.115d	20 da 10	jsr $10da			jsr 	WriteValue
.1160	4c 4a 11	jmp $114a			jmp 	_CLCheckNext
.1163					LocaliseVariable:
.1163	b1 02		lda ($02),y			lda 	(codePtr),y 				; check it's a variable.
.1165	c9 40		cmp #$40			cmp 	#$40
.1167	b0 67		bcs $11d0			bcs 	_LVSyntax
.1169	8a		txa				txa 								; get the address of that variable.
.116a	a2 00		ldx #$00		ldx	#0
.116c	20 85 2a	jsr $2a85		jsr	variableHandler
.116f	aa		tax				tax
.1170	8a		txa				txa
.1171	48		pha				pha
.1172	98		tya				tya
.1173	48		pha				pha
.1174	20 3c 11	jsr $113c			jsr 	TOSToTemp0 					; the address of the variable is now in temp0.
.1177	b5 40		lda $40,x			lda 	esType,x 					; get the type
.1179	0a		asl a				asl 	a
.117a	10 16		bpl $1192			bpl 	_LVPushNumber
.117c	a0 00		ldy #$00			ldy 	#0 							; put address of data in temp1
.117e	b1 04		lda ($04),y			lda 	(temp0),y
.1180	c8		iny				iny
.1181	85 06		sta $06				sta 	temp1
.1183	b1 04		lda ($04),y			lda 	(temp0),y
.1185	85 07		sta $07				sta 	temp1+1
.1187	a0 00		ldy #$00			ldy 	#0 	 						; get length
.1189	b1 06		lda ($06),y			lda 	(temp1),y
.118b	aa		tax				tax 								; into X
.118c	e8		inx				inx 								; +1 for length.
.118d	a9 24		lda #$24			lda 	#markerString
.118f	4c a7 11	jmp $11a7			jmp 	_LVWriteFrame
.1192					_LVPushNumber:
.1192	a5 04		lda $04				lda 	temp0 						; storage address and data source are the same
.1194	85 06		sta $06				sta 	temp1
.1196	a5 05		lda $05				lda 	temp0+1
.1198	85 07		sta $07				sta 	temp1+1
.119a	b5 40		lda $40,x			lda 	esType,x 					; put float flag into carry.
.119c	4a		lsr a				lsr 	a
.119d	a9 25		lda #$25			lda 	#markerInt 					; get marker and size.
.119f	a2 04		ldx #$04			ldx 	#VarISize
.11a1	90 04		bcc $11a7			bcc 	_LVIsInteger
.11a3	a9 23		lda #$23			lda 	#markerFloat
.11a5	a2 06		ldx #$06			ldx 	#VarFSize
.11a7					_LVIsInteger:
.11a7					_LVWriteFrame:
.11a7	8e f0 0a	stx $0af0			stx 	storeSize 					; number of bytes to copy from (temp0)
.11aa	e8		inx				inx 								; allocate 3 bytes, 2 for the address, 1 for the marker.
.11ab	e8		inx				inx
.11ac	e8		inx				inx
.11ad	20 95 21	jsr $2195			jsr 	RSClaim 					; create the stack frame.
.11b0	a5 04		lda $04				lda 	temp0 						; copy the target address to slots 1 & 2
.11b2	a0 01		ldy #$01			ldy 	#1
.11b4	91 78		sta ($78),y			sta 	(rsPointer),y
.11b6	c8		iny				iny
.11b7	a5 05		lda $05				lda 	temp0+1
.11b9	91 78		sta ($78),y			sta 	(rsPointer),y
.11bb	a0 00		ldy #$00			ldy 	#0
.11bd					_LVCopyData:
.11bd	b1 06		lda ($06),y			lda 	(temp1),y 					; get data from source, temp1
.11bf	c8		iny				iny 								; write allowing for the header bit.
.11c0	c8		iny				iny
.11c1	c8		iny				iny
.11c2	91 78		sta ($78),y			sta 	(rsPointer),y
.11c4	88		dey				dey
.11c5	88		dey				dey
.11c6	ce f0 0a	dec $0af0			dec 	storeSize 					; do it storesize times
.11c9	d0 f2		bne $11bd			bne 	_LVCopyData
.11cb	68		pla				pla
.11cc	a8		tay				tay
.11cd	68		pla				pla
.11ce	aa		tax				tax
.11cf	60		rts				rts
.11d0					_LVSyntax:
.11d0	a2 02		ldx #$02			ldx 	#ErrorID_Syntax
.11d2	20 36 22	jsr $2236		jsr	errorHandler
.11d5					RestoreLocals:
.11d5	a2 00		ldx #$00			ldx 	#0
.11d7	a1 78		lda ($78,x)			lda 	(rsPointer,x)
.11d9	c9 40		cmp #$40			cmp	 	#64
.11db	90 01		bcc $11de			bcc 	_RLocal
.11dd	60		rts				rts
.11de					_RLocal:
.11de	8a		txa				txa
.11df	48		pha				pha
.11e0	98		tya				tya
.11e1	48		pha				pha
.11e2	a0 01		ldy #$01			ldy 	#1 							; copy target address to temp0
.11e4	b1 78		lda ($78),y			lda 	(rsPointer),y
.11e6	85 04		sta $04				sta 	temp0
.11e8	c8		iny				iny
.11e9	b1 78		lda ($78),y			lda 	(rsPointer),y
.11eb	85 05		sta $05				sta 	temp0+1
.11ed	a0 00		ldy #$00			ldy 	#0 							; get type back.
.11ef	b1 78		lda ($78),y			lda 	(rsPointer),y
.11f1	c9 24		cmp #$24			cmp 	#markerString 				; string is ... different :)
.11f3	f0 28		beq $121d			beq 	_RString
.11f5	a2 04		ldx #$04			ldx		#VARISize 					; size integer
.11f7	c9 25		cmp #$25			cmp 	#markerInt
.11f9	f0 02		beq $11fd			beq 	_RIsInteger
.11fb	a2 06		ldx #$06			ldx 	#VARFSize 					; size float
.11fd					_RIsInteger:
.11fd	8a		txa				txa
.11fe	48		pha				pha
.11ff	a0 03		ldy #$03			ldy 	#3							; start size to copy back from pointer.
.1201					_RCopyBack:
.1201	b1 78		lda ($78),y			lda 	(rsPointer),y
.1203	88		dey				dey
.1204	88		dey				dey
.1205	88		dey				dey
.1206	91 04		sta ($04),y			sta 	(temp0),y
.1208	c8		iny				iny
.1209	c8		iny				iny
.120a	c8		iny				iny
.120b	c8		iny				iny
.120c	ca		dex				dex
.120d	d0 f2		bne $1201			bne 	_RCopyBack
.120f	68		pla				pla 								; get size add 3
.1210	18		clc				clc
.1211	69 03		adc #$03			adc 	#3 							; (2 for address one for marker)
.1213					_RRestoreAAndLoop:
.1213	20 b7 21	jsr $21b7			jsr 	RSFree
.1216	68		pla				pla
.1217	a8		tay				tay
.1218	68		pla				pla
.1219	aa		tax				tax
.121a	4c d5 11	jmp $11d5			jmp 	RestoreLocals 				; go see if there are any more locals.
.121d					_RString:
.121d	a2 00		ldx #$00			ldx 	#0
.121f	a0 01		ldy #$01			ldy 	#1 							; set up for a string write.
.1221	b1 78		lda ($78),y			lda 	(rsPointer),y
.1223	95 48		sta $48,x			sta 	esInt0,x
.1225	c8		iny				iny
.1226	b1 78		lda ($78),y			lda 	(rsPointer),y
.1228	95 50		sta $50,x			sta 	esInt1,x
.122a	18		clc				clc
.122b	a5 78		lda $78				lda 	rsPointer
.122d	69 03		adc #$03			adc 	#3
.122f	95 49		sta $49,x			sta 	esInt0+1,x
.1231	a5 79		lda $79				lda 	rsPointer+1
.1233	69 00		adc #$00			adc 	#0
.1235	95 51		sta $51,x			sta 	esInt1+1,x
.1237	8a		txa				txa
.1238	a2 0c		ldx #$0c		ldx	#12
.123a	20 bd 27	jsr $27bd		jsr	stringHandler
.123d	a0 03		ldy #$03			ldy 	#3 							; get string length
.123f	b1 78		lda ($78),y			lda 	(rsPointer),y
.1241	18		clc				clc
.1242	69 04		adc #$04			adc 	#4 							; add 4 (pointer, marker, length) to restore.
.1244	4c 13 12	jmp $1213			jmp 	_RRestoreAAndLoop

;******  Return to file: main/main.asm


;******  Processing file: main/commands/new.asm

.1247					Command_New:
.1247	20 81 14	jsr $1481			jsr 	ResetCodeAddress 			; point to first line
.124a	a0 00		ldy #$00			ldy 	#0 							; and zap it.
.124c	98		tya				tya
.124d	91 02		sta ($02),y			sta 	(codePtr),y
.124f	20 2d 10	jsr $102d			jsr 	CommandClear 				; clear everything down.
.1252	4c 45 16	jmp $1645			jmp 	CommandEND 					; do END code, as there's nothing to run.

;******  Return to file: main/main.asm


;******  Processing file: main/commands/poke.asm

.1255					Command_Poke:
.1255	a9 01		lda #$01			lda 	#1
.1257	d0 06		bne $125f			bne 	PokeGeneral
.1259					Command_Doke:
.1259	a9 02		lda #$02			lda 	#2
.125b	d0 02		bne $125f			bne 	PokeGeneral
.125d					Command_Loke:
.125d	a9 03		lda #$03			lda 	#3
.125f					PokeGeneral:
.125f	48		pha				pha 								; save size
.1260	20 dd 1a	jsr $1add			jsr 	EvaluateRootInteger 		; target address
.1263	20 7a 21	jsr $217a			jsr	 	CheckComma
.1266	e8		inx				inx
.1267	20 df 1a	jsr $1adf			jsr 	EvaluateInteger 			; what value to POKE ?
.126a	ca		dex				dex
.126b	20 3c 11	jsr $113c			jsr 	TOSToTemp0 					; temp0 points to the target address
.126e	84 0c		sty $0c				sty 	tempShort 					; save Y
.1270	68		pla				pla 								; get copy type and dispatch
.1271	aa		tax				tax
.1272	ca		dex				dex
.1273	f0 14		beq $1289			beq 	_Poke1
.1275	ca		dex				dex
.1276	f0 0b		beq $1283			beq 	_Poke2
.1278	a0 03		ldy #$03			ldy 	#3
.127a	a5 61		lda $61				lda 	esInt3+1
.127c	91 04		sta ($04),y			sta 	(temp0),y
.127e	88		dey				dey
.127f	a5 59		lda $59				lda 	esInt2+1
.1281	91 04		sta ($04),y			sta 	(temp0),y
.1283					_Poke2:
.1283	a0 01		ldy #$01			ldy 	#1
.1285	a5 51		lda $51				lda 	esInt1+1
.1287	91 04		sta ($04),y			sta 	(temp0),y
.1289					_Poke1:
.1289	a0 00		ldy #$00			ldy 	#0
.128b	a5 49		lda $49				lda 	esInt0+1
.128d	91 04		sta ($04),y			sta 	(temp0),y
.128f	a4 0c		ldy $0c				ldy 	tempShort 					; restore Y and exit
.1291	60		rts				rts

;******  Return to file: main/main.asm


;******  Processing file: main/commands/print.asm

.0af1					lastPrintToken:
>0af1							.fill 	1
.1292					Command_Print:
.1292	a9 00		lda #$00			lda 	#0 							; clear LPT flag
.1294	8d f1 0a	sta $0af1			sta 	lastPrintToken
.1297	88		dey				dey
.1298					_PrintLoopSkip:
.1298	c8		iny				iny
.1299					_PrintLoop:
.1299	b1 02		lda ($02),y			lda 	(codePtr),y 				; what follows
.129b	c9 80		cmp #$80			cmp 	#TOK_EOL  					; done if end of line or colon
.129d	f0 5b		beq $12fa			beq 	_PrintExit
.129f	c9 c7		cmp #$c7			cmp 	#TKW_COLON
.12a1	f0 57		beq $12fa			beq 	_PrintExit
.12a3	8d f1 0a	sta $0af1			sta 	lastPrintToken 				; update LPT
.12a6	c9 c9		cmp #$c9			cmp 	#TKW_SEMICOLON 				; ignore semicolon
.12a8	f0 ee		beq $1298			beq 	_PrintLoopSkip
.12aa	c9 ca		cmp #$ca			cmp 	#TKW_QUOTE 					; ' is new line
.12ac	f0 3c		beq $12ea			beq	 	_PrintNewLine
.12ae	c9 c8		cmp #$c8			cmp 	#TKW_COMMA 					; , is print tab
.12b0	f0 40		beq $12f2			beq 	_PrintTab
.12b2	20 be 1a	jsr $1abe			jsr 	EvaluateRoot 				; evaluate something at the root
.12b5	a9 cd		lda #$cd			lda 	#(convertBuffer) & $FF
.12b7	85 04		sta $04				sta 	temp0
.12b9	a9 0a		lda #$0a			lda 	#(convertBuffer) >> 8
.12bb	85 05		sta $05				sta 	1+(temp0)
.12bd	a5 40		lda $40				lda 	esType 						; get type
.12bf	f0 15		beq $12d6			beq		_PrintInteger
.12c1	4a		lsr a				lsr 	a 							; check for floating point
.12c2	b0 08		bcs $12cc			bcs 	_PrintFloat
.12c4					_PrintString:
.12c4	a2 00		ldx #$00			ldx 	#0 							; bottom string to temp0
.12c6	20 3c 11	jsr $113c			jsr 	TOSToTemp0
.12c9	4c e4 12	jmp $12e4			jmp 	_PrintTemp0 				; print no leading space.
.12cc					_PrintFloat:
.12cc	a9 00		lda #$00			lda 	#0 							; stack level.
.12ce	a2 14		ldx #$14		ldx	#20
.12d0	20 21 25	jsr $2521		jsr	floatingpointHandler
.12d3	4c dd 12	jmp $12dd			jmp 	_PrintSpaceTemp0
.12d6					_PrintInteger:
.12d6	a9 8a		lda #$8a			lda 	#10+$80 					; base 10 signed
.12d8	a2 00		ldx #$00			ldx 	#0 							; bottom stack element
.12da	20 50 20	jsr $2050			jsr 	MInt32ToString				; convert to text
.12dd					_PrintSpaceTemp0:
.12dd	a9 20		lda #$20			lda 	#32
.12df	a2 06		ldx #$06		ldx	#6
.12e1	20 27 22	jsr $2227		jsr	deviceHandler
.12e4					_PrintTemp0:
.12e4	20 0b 13	jsr $130b			jsr 	PrintString
.12e7	4c 99 12	jmp $1299			jmp 	_PrintLoop
.12ea					_PrintNewLine:
.12ea	a2 00		ldx #$00		ldx	#0
.12ec	20 27 22	jsr $2227		jsr	deviceHandler
.12ef	4c 98 12	jmp $1298			jmp 	_PrintLoopSkip
.12f2					_PrintTab:
.12f2	a2 08		ldx #$08		ldx	#8
.12f4	20 27 22	jsr $2227		jsr	deviceHandler
.12f7	4c 98 12	jmp $1298			jmp 	_PrintLoopSkip
.12fa					_PrintExit:
.12fa	ad f1 0a	lda $0af1			lda		lastPrintToken 				; check last token
.12fd	c9 c9		cmp #$c9			cmp 	#TKW_SEMICOLON 				; if , or ; do not print NL
.12ff	f0 09		beq $130a			beq 	_PrintExit2
.1301	c9 c8		cmp #$c8			cmp 	#TKW_COMMA
.1303	f0 05		beq $130a			beq 	_PrintExit2
.1305	a2 00		ldx #$00		ldx	#0
.1307	20 27 22	jsr $2227		jsr	deviceHandler
.130a					_PrintExit2:
.130a	60		rts				rts
.130b					PrintString:
.130b	8a		txa				txa
.130c	48		pha				pha
.130d	98		tya				tya
.130e	48		pha				pha
.130f	a0 00		ldy #$00			ldy 	#0							; get length
.1311	b1 04		lda ($04),y			lda 	(temp0),y
.1313	aa		tax				tax 								; into X
.1314	e0 00		cpx #$00	_PSLoop:cpx 	#0 							; finished ?
.1316	f0 10		beq $1328			beq 	_PSExit
.1318	ca		dex				dex
.1319	8a		txa				txa
.131a	48		pha				pha
.131b	c8		iny				iny
.131c	b1 04		lda ($04),y			lda 	(temp0),y
.131e	a2 06		ldx #$06		ldx	#6
.1320	20 27 22	jsr $2227		jsr	deviceHandler
.1323	68		pla				pla
.1324	aa		tax				tax
.1325	4c 14 13	jmp $1314			jmp 	_PSLoop
.1328					_PSExit:
.1328	68		pla				pla
.1329	a8		tay				tay
.132a	68		pla				pla
.132b	aa		tax				tax
.132c	60		rts				rts

;******  Return to file: main/main.asm


;******  Processing file: main/commands/proc.asm

.0af2					paramCount:
>0af2							.fill 	1
.132d					CallProc:
.132d	20 68 15	jsr $1568			jsr 	FindProcedure 				; find procedure, put in temp0. A contains name length.
.1330	48		pha				pha 								; save length on stack
.1331	85 0c		sta $0c				sta 	tempShort 					; save length in tempShort
.1333	a5 05		lda $05				lda 	temp0+1 					; save procedure target on stack.
.1335	48		pha				pha
.1336	a5 04		lda $04				lda 	temp0
.1338	48		pha				pha
.1339	98		tya				tya 								; calculate Y + length
.133a	18		clc				clc
.133b	65 0c		adc $0c				adc 	tempShort
.133d	a8		tay				tay
.133e	a2 00		ldx #$00			ldx 	#0 							; where the first parameter goes - 1
.1340					_CallProcEvalParams:
.1340	e8		inx				inx
.1341	b1 02		lda ($02),y			lda 	(codePtr),y 				; do we have ) ?
.1343	c9 c6		cmp #$c6			cmp 	#TKW_RPAREN
.1345	f0 0b		beq $1352			beq 	_CPDoneParams
.1347	20 c0 1a	jsr $1ac0			jsr 	Evaluate 					; evaluate a parameter
.134a	b1 02		lda ($02),y			lda 	(codePtr),Y 				; get what's next, preconsume
.134c	c8		iny				iny
.134d	c9 c8		cmp #$c8			cmp 	#TKW_COMMA 					; if comma, go get another parameter
.134f	f0 ef		beq $1340			beq 	_CallProcEvalParams
.1351	88		dey				dey 								; undo consumption.
.1352					_CPDoneParams:
.1352	20 6d 21	jsr $216d			jsr 	CheckRightParen 			; check closing parenthesis.
.1355	8e f2 0a	stx $0af2			stx 	paramCount 					; store parameter count+1
.1358	a2 04		ldx #$04			ldx 	#4							; make space on stack
.135a	a9 50		lda #$50			lda 	#markerPROC
.135c	20 95 21	jsr $2195			jsr 	RSClaim
.135f	a9 01		lda #$01			lda 	#1 							; store return address.
.1361	20 c1 21	jsr $21c1			jsr 	RSSavePosition
.1364	68		pla				pla 								; get the new code Ptr
.1365	85 02		sta $02				sta 	codePtr
.1367	68		pla				pla
.1368	85 03		sta $03				sta 	codePtr+1
.136a	68		pla				pla 								; length of name + 4 is the param start.
.136b	18		clc				clc
.136c	69 04		adc #$04			adc 	#4
.136e	a8		tay				tay
.136f	a2 ff		ldx #$ff			ldx 	#$FF
.1371					_CPLoadParameters:
.1371	e8		inx				inx 								; point to where the address should be loaded.
.1372	ec f2 0a	cpx $0af2			cpx 	paramCount 					; too many parameters in definition ?
.1375	f0 1e		beq $1395			beq 	_CPParamError
.1377	b1 02		lda ($02),y			lda 	(codePtr),y					; what follows
.1379	c9 c6		cmp #$c6			cmp 	#TKW_RPAREN 				; is it the right bracket
.137b	f0 0e		beq $138b			beq 	_CPParamComplete 			; done all the parameters
.137d	20 63 11	jsr $1163			jsr 	LocaliseVariable 			; make following variable local, ref in tos,x
.1380	20 da 10	jsr $10da			jsr 	WriteValue 					; copy the evaluated parameter into there.
.1383	b1 02		lda ($02),y			lda 	(codePtr),y 				; followed by a comma ?
.1385	c8		iny				iny
.1386	c9 c8		cmp #$c8			cmp 	#TKW_COMMA
.1388	f0 e7		beq $1371			beq 	_CPLoadParameters
.138a	88		dey				dey 								; no, unconsume and check for )
.138b					_CPParamComplete:
.138b	20 6d 21	jsr $216d			jsr 	CheckRightParen 			; check )
.138e	e8		inx				inx 								; check right number of parameters
.138f	ec f2 0a	cpx $0af2			cpx 	paramCount
.1392	d0 01		bne $1395			bne 	_CPParamError
.1394	60		rts				rts
.1395					_CPParamError:
.1395	a2 18		ldx #$18			ldx 	#ErrorID_Params
.1397	20 36 22	jsr $2236		jsr	errorHandler
.139a					ReturnProc:
.139a	20 d5 11	jsr $11d5			jsr 	RestoreLocals 				; get the locals back.
.139d	a2 00		ldx #$00			ldx 	#0 							; get TOS return stack
.139f	a1 78		lda ($78,x)			lda 	(rsPointer,x)
.13a1	c9 50		cmp #$50			cmp 	#markerPROC 						; does it match
.13a3	f0 05		beq $13aa			beq 	_isok
.13a5	a2 12		ldx #$12			ldx 	#ErrorID_endProcErr
.13a7	20 36 22	jsr $2236		jsr	errorHandler
.13aa					_isok:
.13aa	a9 01		lda #$01			lda 	#1
.13ac	20 d4 21	jsr $21d4			jsr 	RSLoadPosition 				; reload the position from offset 1.
.13af	a9 04		lda #$04			lda 	#4 							; throw 4 bytes from stack.
.13b1	20 b7 21	jsr $21b7			jsr 	RSFree
.13b4	60		rts				rts

;******  Return to file: main/main.asm


;******  Processing file: main/commands/readdata.asm

.0af3					dataPtr:
>0af3							.fill 	2
.0af5					dataIndex:
>0af5							.fill 	1
.13b5					CommandRead:
.13b5	a2 00		ldx #$00			ldx 	#0 							; get a reference to a variable in stack:0
.13b7	20 0c 1b	jsr $1b0c			jsr 	EvaluateReference
.13ba	20 fa 13	jsr $13fa			jsr 	SwapDPCP 					; use the data pointer.
.13bd	b1 02		lda ($02),y			lda 	(codePtr),y 				; see where it is.
.13bf	c8		iny				iny
.13c0	c9 c8		cmp #$c8			cmp 	#TKW_COMMA 					; if it is on a comma, it is in data.
.13c2	f0 07		beq $13cb			beq 	_CRInData
.13c4	88		dey				dey
.13c5	a9 d9		lda #$d9			lda 	#TKW_DATA 					; scan forward to a DATA statement.
.13c7	aa		tax				tax
.13c8	20 06 2c	jsr $2c06			jsr 	ScanForward
.13cb					_CRInData:
.13cb	a2 01		ldx #$01			ldx 	#1 							; evaluate a value at Stack,1
.13cd	20 c0 1a	jsr $1ac0			jsr 	Evaluate
.13d0	ca		dex				dex 								; and write the value.
.13d1	20 da 10	jsr $10da			jsr 	WriteValue
.13d4	20 fa 13	jsr $13fa			jsr 	SwapDPCP 					; get the code pointer back.
.13d7	b1 02		lda ($02),y			lda 	(codePtr),y 				; what follows ?
.13d9	c8		iny				iny
.13da	c9 c8		cmp #$c8			cmp 	#TKW_COMMA 					; if comma, another variable
.13dc	f0 d7		beq $13b5			beq 	CommandRead
.13de	88		dey				dey
.13df	60		rts				rts
.13e0					CommandData:
.13e0	a9 80		lda #$80			lda 	#TOK_EOL 					; go forward to end of line or colon.
.13e2	a2 c7		ldx #$c7			ldx 	#TKW_COLON
.13e4	20 06 2c	jsr $2c06			jsr 	ScanForward
.13e7	60		rts				rts
.13e8					CommandRestore:
.13e8	ad c8 0a	lda $0ac8			lda 	basePage
.13eb	8d f3 0a	sta $0af3			sta 	dataPtr
.13ee	ad c9 0a	lda $0ac9			lda 	basePage+1
.13f1	8d f4 0a	sta $0af4			sta 	dataPtr+1
.13f4	a9 03		lda #$03			lda 	#3
.13f6	8d f5 0a	sta $0af5			sta 	dataIndex
.13f9	60		rts				rts
.13fa					SwapDPCP:
.13fa	8a		txa				txa
.13fb	48		pha				pha
.13fc	98		tya				tya 								; swap Y, DataIndex
.13fd	ac f5 0a	ldy $0af5			ldy 	DataIndex
.1400	8d f5 0a	sta $0af5			sta 	DataIndex
.1403	a5 02		lda $02				lda 	codePtr 					; swap code/dataptr low
.1405	ae f3 0a	ldx $0af3			ldx 	dataptr
.1408	8d f3 0a	sta $0af3			sta 	dataPtr
.140b	86 02		stx $02				stx 	codePtr
.140d	a5 03		lda $03				lda 	codePtr+1 					; swap code/dataptr high.
.140f	ae f4 0a	ldx $0af4			ldx 	dataptr+1
.1412	8d f4 0a	sta $0af4			sta 	dataPtr+1
.1415	86 03		stx $03				stx 	codePtr+1
.1417	68		pla				pla
.1418	aa		tax				tax
.1419	60		rts				rts

;******  Return to file: main/main.asm


;******  Processing file: main/commands/rem.asm

.141a					Command_Rem:
.141a					Command_Rem2:
.141a	b1 02		lda ($02),y			lda 	(codePtr),y 				; what follows
.141c	c9 85		cmp #$85			cmp 	#TOK_STR 					; if it is a string then skip it.
.141e	d0 06		bne $1426			bne 	_CRNotString
.1420	c8		iny				iny
.1421	98		tya				tya
.1422	38		sec				sec
.1423	71 02		adc ($02),y			adc 	(codePtr),y 				; get string size, add to Y, +1 for the length
.1425	a8		tay				tay
.1426					_CRNotString:
.1426	60		rts				rts

;******  Return to file: main/main.asm


;******  Processing file: main/commands/repeat.asm

.2b9d					Command_Repeat:
.2b9d	a2 04		ldx #$04			ldx 	#4 							; allocate 4 bytes on stack for REPEAT
.2b9f	a9 52		lda #$52			lda 	#markerREPEAT 				; repeat marker allocate 4 bytes
.2ba1	20 95 21	jsr $2195			jsr 	RSClaim
.2ba4	a9 01		lda #$01			lda 	#1 							; save position at offset 1.
.2ba6	20 c1 21	jsr $21c1			jsr 	RSSavePosition
.2ba9	60		rts				rts
.2baa					Command_Until:
.2baa	a2 00		ldx #$00			ldx 	#0 							; get TOS return stack
.2bac	a1 78		lda ($78,x)			lda 	(rsPointer,x)
.2bae	c9 52		cmp #$52			cmp 	#markerREPEAT 						; does it match
.2bb0	f0 05		beq $2bb7			beq 	_isok
.2bb2	a2 0f		ldx #$0f			ldx 	#ErrorID_untilErr
.2bb4	20 36 22	jsr $2236		jsr	errorHandler
.2bb7					_isok:
.2bb7	20 dd 1a	jsr $1add			jsr 	EvaluateRootInteger 		; at the bottom.
.2bba	20 21 21	jsr $2121			jsr 	MInt32Zero					; check if TOS zero
.2bbd	d0 06		bne $2bc5			bne 	_CUExit
.2bbf	a9 01		lda #$01			lda 	#1
.2bc1	20 d4 21	jsr $21d4			jsr 	RSLoadPosition 				; reload the position from offset 1.
.2bc4	60		rts				rts
.2bc5					_CUExit:
.2bc5	a9 04		lda #$04			lda 	#4 							; throw 4 bytes from stack.
.2bc7	20 b7 21	jsr $21b7			jsr 	RSFree
.2bca	60		rts				rts

;******  Return to file: main/main.asm


;******  Processing file: main/commands/run.asm

.1427					Command_Run:
.1427	a2 ff		ldx #$ff			ldx 	#$FF
.1429	9a		txs				txs
.142a	20 2d 10	jsr $102d			jsr 	CommandClear 				; clear everything.
.142d	20 81 14	jsr $1481			jsr 	ResetCodeAddress 			; back to the start.
.1430	a0 03		ldy #$03			ldy 	#3
.1432					CRNextInstruction:
.1432	64 7b		stz $7b				stz 	softMemAlloc+1
.1434	b1 02		lda ($02),y			lda 	(codePtr),y 				; get next token.
.1436	10 1c		bpl $1454			bpl 	_CRNotToken
.1438	c9 c6		cmp #$c6			cmp 	#TOK_TOKENS 				; if in the tokens then do that token.
.143a	b0 0c		bcs $1448			bcs 	_CRExecute
.143c	c9 a4		cmp #$a4			cmp 	#TOK_UNARYST 				; unary is ignored.
.143e	b0 4e		bcs $148e			bcs 	Unimplemented
.1440	c9 99		cmp #$99			cmp 	#TOK_STRUCTST 				; execute structures.
.1442	b0 04		bcs $1448			bcs 	_CRExecute
.1444	c9 86		cmp #$86			cmp 	#TOK_BINARYST 				; if one of the system tokens $80-$85 do that
.1446	b0 16		bcs $145e			bcs 	_CRCheckIndirect 			; if in that unused range check for ! or ?
.1448					_CRExecute:
.1448	c8		iny				iny 								; consume it.
.1449	0a		asl a				asl 	a 							; double it, losing most significant bit.
.144a	aa		tax				tax
.144b	20 51 14	jsr $1451			jsr 	_CRRunRoutine 				; we want to do jsr (group0vectors,x)
.144e	4c 32 14	jmp $1432			jmp 	CRNextInstruction
.1451					_CRRunRoutine:
.1451	7c 98 14	jmp ($1498,x)			jmp 	(Group0Vectors,x)
.1454					_CRNotToken:
.1454	c9 40		cmp #$40			cmp 	#$40 						; if 0-3F then it is a letter
.1456	b0 36		bcs $148e			bcs 	Unimplemented
.1458					_CRDefaultLet:
.1458	20 c7 10	jsr $10c7			jsr 	CommandLet 					; do the default, LET
.145b	4c 32 14	jmp $1432			jmp 	CRNextInstruction
.145e					_CRCheckIndirect:
.145e	c9 97		cmp #$97			cmp 	#TKW_PLING 					; !<term> =
.1460	f0 f6		beq $1458			beq 	_CRDefaultLet
.1462	c9 98		cmp #$98			cmp 	#TKW_QMARK 					; ?<term> =
.1464	f0 f2		beq $1458			beq 	_CRDefaultLet
.1466	d0 26		bne $148e			bne 	Unimplemented
.1468					CommandShift1:
.1468	b1 02		lda ($02),y			lda 	(codePtr),y 				; get shifted value
.146a	10 22		bpl $148e			bpl 	Unimplemented 				; we have an error as this should not happen.
.146c	0a		asl a				asl 	a 							; double into X
.146d	aa		tax				tax
.146e	c8		iny				iny 								; advance over it.
.146f	20 75 14	jsr $1475			jsr 	_RunIt 						; we have no jsr (aaaa,X)
.1472	4c 32 14	jmp $1432			jmp 	CRNextInstruction
.1475					_RunIt:
.1475	7c 48 15	jmp ($1548,x)			jmp 	(Group1Vectors-12,x) 		; and do the code.
.1478					CommandShift2:
.1478	a9 ff		lda #$ff			lda 	#$FF 						; $FF means command not unary function.
.147a	20 90 24	jsr $2490		jsr	extensionHandler
.147d	4c 32 14	jmp $1432			jmp 	CRNextInstruction
.1480					CommandColon:
.1480	60		rts				rts
.1481					ResetCodeAddress:
.1481	ad c8 0a	lda $0ac8			lda 	basePage 					; copy basePage to code Pointer
.1484	85 02		sta $02				sta 	codePtr
.1486	ad c9 0a	lda $0ac9			lda 	basePage+1
.1489	85 03		sta $03				sta 	codePtr+1
.148b	a0 03		ldy #$03			ldy 	#3 							; offset after offset link and line#
.148d	60		rts				rts
.148e					Unimplemented:
.148e	a2 01		ldx #$01			ldx 	#ErrorID_Missing
.1490	20 36 22	jsr $2236		jsr	errorHandler
.1493					TKErr01:
.1493					TKErr02:
.1493					TKErr03:
.1493					TKErr04:
.1493					TKErr05:
.1493					TKErr06:
.1493					TKErr07:
.1493					TKErr08:
.1493					TKErr09:
.1493					TKErr10:
.1493	a2 02		ldx #$02			ldx 	#ErrorID_Syntax
.1495	20 36 22	jsr $2236		jsr	errorHandler

;******  Processing file: main/commands/../../generated/tokenvectors0.inc

.1498					Group0Vectors:
>1498	48 16					.word	AdvanceNextLine          ; $80 [[eol]]
>149a	68 14					.word	CommandShift1            ; $81 [[sh1]]
>149c	78 14					.word	CommandShift2            ; $82 [[sh2]]
>149e	93 14					.word	TKErr09                  ; $83 [[sh3]]
>14a0	93 14					.word	TKErr10                  ; $84 [[fpc]]
>14a2	93 14					.word	TKErr08                  ; $85 [[str]]
>14a4	9b 17					.word	AndHandler               ; $86 and
>14a6	88 17					.word	OrHandler                ; $87 or
>14a8	75 17					.word	XorHandler               ; $88 xor
>14aa	bd 18					.word	CompareGreaterEq         ; $89 >=
>14ac	c7 18					.word	CompareLessEq            ; $8a <=
>14ae	a9 18					.word	CompareGreater           ; $8b >
>14b0	9f 18					.word	CompareLess              ; $8c <
>14b2	95 18					.word	CompareEquals            ; $8d =
>14b4	b3 18					.word	CompareNotEquals         ; $8e <>
>14b6	06 17					.word	AddHandler               ; $8f +
>14b8	29 17					.word	SubHandler               ; $90 -
>14ba	c1 17					.word	ShrHandler               ; $91 >>
>14bc	ae 17					.word	ShlHandler               ; $92 <<
>14be	3c 17					.word	MulHandler               ; $93 *
>14c0	4f 17					.word	DivHandler               ; $94 /
>14c2	62 17					.word	ModHandler               ; $95 mod
>14c4	fa 17					.word	PowerHandler             ; $96 ^
>14c6	d4 17					.word	WordRefHandler           ; $97 !
>14c8	e7 17					.word	ByteRefHandler           ; $98 ?
>14ca	9d 2b					.word	Command_Repeat           ; $99 repeat
>14cc	cb 2b					.word	Command_While            ; $9a while
>14ce	8e 2a					.word	Command_FOR              ; $9b for
>14d0	8b 10					.word	CommandIf                ; $9c if
>14d2	93 14					.word	TKErr04                  ; $9d defproc
>14d4	aa 2b					.word	Command_Until            ; $9e until
>14d6	ee 2b					.word	Command_Wend             ; $9f wend
>14d8	ef 2a					.word	Command_NEXT             ; $a0 next
>14da	93 14					.word	TKErr06                  ; $a1 then
>14dc	c6 10					.word	Command_ENDIF            ; $a2 endif
>14de	9a 13					.word	ReturnProc               ; $a3 endproc
>14e0	96 1a					.word	UnaryParenthesis         ; $a4 (
>14e2	ee 1b					.word	UnaryLen                 ; $a5 len(
>14e4	32 1c					.word	UnarySgn                 ; $a6 sgn(
>14e6	1b 1c					.word	UnaryAbs                 ; $a7 abs(
>14e8	8b 1c					.word	Unary_Random             ; $a8 random(
>14ea	d5 1c					.word	Unary_Page               ; $a9 page
>14ec	f6 20					.word	MInt32True               ; $aa true
>14ee	fa 20					.word	MInt32False              ; $ab false
>14f0	a0 1c					.word	Unary_Min                ; $ac min(
>14f2	a4 1c					.word	Unary_Max                ; $ad max(
>14f4	8b 1d					.word	UnarySys                 ; $ae sys(
>14f6	4e 1d					.word	UnaryTimer               ; $af timer(
>14f8	6b 1b					.word	EventFunction            ; $b0 event(
>14fa	77 1d					.word	UnaryGet                 ; $b1 get(
>14fc	67 1d					.word	UnaryInkey               ; $b2 inkey(
>14fe	22 1d					.word	UnaryAlloc               ; $b3 alloc(
>1500	b3 1d					.word	ExecChr                  ; $b4 chr$(
>1502	e3 1d					.word	ExecLeft                 ; $b5 left$(
>1504	00 1e					.word	ExecMid                  ; $b6 mid$(
>1506	28 1e					.word	ExecRight                ; $b7 right$(
>1508	d7 18					.word	Event_Str                ; $b8 str$(
>150a	06 19					.word	UnaryVal                 ; $b9 val(
>150c	49 1c					.word	UnaryPeek                ; $ba peek(
>150e	4f 1c					.word	UnaryDeek                ; $bb deek(
>1510	55 1c					.word	UnaryLeek                ; $bc leek(
>1512	0c 1c					.word	UnaryAsc                 ; $bd asc(
>1514	00 1d					.word	UnaryIntToFloat          ; $be int(
>1516	13 1d					.word	UnaryFloatToInt          ; $bf float(
>1518	09 19					.word	UnaryIsVal               ; $c0 isval(
>151a	ca 1d					.word	ExecUpper                ; $c1 upper$(
>151c	c7 1d					.word	ExecLower                ; $c2 lower$(
>151e	e3 1c					.word	UnaryReference           ; $c3 @
>1520	f9 1c					.word	UnaryComplement          ; $c4 ~
>1522	f6 1c					.word	UnaryHexMarker           ; $c5 &
>1524	93 14					.word	TKErr01                  ; $c6 )
>1526	80 14					.word	CommandColon             ; $c7 :
>1528	93 14					.word	TKErr02                  ; $c8 ,
>152a	93 14					.word	TKErr03                  ; $c9 ;
>152c	1a 14					.word	Command_Rem2             ; $ca '
>152e	93 14					.word	TKErr07                  ; $cb to
>1530	93 14					.word	TKErr05                  ; $cc step
>1532	2d 13					.word	CallProc                 ; $cd proc
>1534	45 11					.word	CommandLocal             ; $ce local
>1536	7d 10					.word	Command_Dim              ; $cf dim
>1538	1a 14					.word	Command_Rem              ; $d0 rem
>153a	c7 10					.word	CommandLet               ; $d1 let
>153c	8e 14					.word	Unimplemented            ; $d2 input
>153e	c0 10					.word	Command_ELSE             ; $d3 else
>1540	b9 16					.word	Command_VDU              ; $d4 vdu
>1542	92 12					.word	Command_Print            ; $d5 print
>1544	87 16					.word	CommandGOTO              ; $d6 goto
>1546	5c 16					.word	CommandGOSUB             ; $d7 gosub
>1548	6f 16					.word	CommandRETURN            ; $d8 return
>154a	e0 13					.word	CommandData              ; $d9 data
>154c	1f 10					.word	Command_Assert           ; $da assert
>154e	55 12					.word	Command_Poke             ; $db poke
>1550	59 12					.word	Command_Doke             ; $dc doke
>1552	5d 12					.word	Command_Loke             ; $dd loke

;******  Return to file: main/commands/run.asm


;******  Processing file: main/commands/../../generated/tokenvectors1.inc

.1554					Group1Vectors:
>1554	2d 10					.word	CommandClear             ; $86 clear
>1556	8e 14					.word	Unimplemented            ; $87 load
>1558	8e 14					.word	Unimplemented            ; $88 save
>155a	8e 14					.word	Unimplemented            ; $89 list
>155c	47 12					.word	Command_New              ; $8a new
>155e	27 14					.word	Command_Run              ; $8b run
>1560	b5 13					.word	CommandRead              ; $8c read
>1562	e8 13					.word	CommandRestore           ; $8d restore
>1564	45 16					.word	CommandEnd               ; $8e end
>1566	40 16					.word	CommandStop              ; $8f stop

;******  Return to file: main/commands/run.asm


;******  Return to file: main/main.asm


;******  Processing file: main/commands/scanner.asm

.0af6					procList:
>0af6							.fill 	2		 					; terminated by name high.
.0af8					yInLine:
>0af8							.fill 	1
.1568					FindProcedure:
.1568	8c f8 0a	sty $0af8			sty 	yInLine
.156b	20 26 16	jsr $1626			jsr 	CalculateProcedureHash		; calculate the hash of the procedure.
.156e	85 06		sta $06				sta 	temp1
.1570	ad f6 0a	lda $0af6			lda		procList 					; put procList address in temp2
.1573	85 08		sta $08				sta 	temp2
.1575	ad f7 0a	lda $0af7			lda 	procList+1
.1578	85 09		sta $09				sta 	temp2+1
.157a	a0 00		ldy #$00			ldy 	#0 							; position in this table.
.157c					_FPLoop:
.157c	b1 08		lda ($08),y			lda 	(temp2),y
.157e	f0 4f		beq $15cf			beq 	_FPError 					; if so, we don't know this procedure.
.1580	85 05		sta $05				sta 	temp0+1 					; copy MSB/LSB to temp0 as we go.
.1582	c8		iny				iny
.1583	b1 08		lda ($08),y			lda 	(temp2),y
.1585	85 04		sta $04				sta 	temp0
.1587	c8		iny				iny
.1588	b1 08		lda ($08),y			lda 	(temp2),y					; check the procedure hash.
.158a	c5 06		cmp $06				cmp 	temp1
.158c	d0 2b		bne $15b9			bne 	_FPNext 					; hash is different, go to next.
.158e	38		sec				sec
.158f	ad f8 0a	lda $0af8			lda 	yInLine 					; position in line must be at least 4
.1592	e9 04		sbc #$04			sbc 	#4
.1594	18		clc				clc
.1595	65 02		adc $02				adc 	codePtr
.1597	85 0a		sta $0a				sta 	temp3
.1599	a5 03		lda $03				lda 	codePtr+1
.159b	69 00		adc #$00			adc 	#0
.159d	85 0b		sta $0b				sta 	temp3+1
.159f	98		tya				tya
.15a0	48		pha				pha
.15a1	a0 04		ldy #$04			ldy 	#4
.15a3					_FPCName:
.15a3	b1 0a		lda ($0a),y			lda 	(temp3),y 					; check the same
.15a5	d1 04		cmp ($04),y			cmp 	(temp0),y
.15a7	d0 0e		bne $15b7			bne 	_FPpulYNext 				; if different go to next one.
.15a9	c8		iny				iny
.15aa	c9 3a		cmp #$3a			cmp 	#$3A
.15ac	90 f5		bcc $15a3			bcc 	_FPCName 					; compare the whole lot....
.15ae	68		pla				pla 								; throw away the saved Y
.15af	98		tya				tya 								; length of name is Y-4
.15b0	38		sec				sec
.15b1	e9 04		sbc #$04			sbc 	#4
.15b3	ac f8 0a	ldy $0af8			ldy 	yInLine  					; get the original Y back
.15b6	60		rts				rts
.15b7					_FPpulYNext:
.15b7	68		pla				pla
.15b8	a8		tay				tay
.15b9					_FPNext:
.15b9	c8		iny				iny 								; next procedure record.
.15ba	10 c0		bpl $157c			bpl 	_FPLoop 					; if done 128 already ... e.g. Y -ve
.15bc	98		tya				tya 								; subtract 128 from Y
.15bd	38		sec				sec
.15be	e9 80		sbc #$80			sbc 	#128
.15c0	a8		tay				tay
.15c1	18		clc				clc 								; add 128 to temp2, so we can have more than
.15c2	a5 08		lda $08				lda 	temp2 						; 255/3 = 85 procedures
.15c4	69 80		adc #$80			adc 	#128
.15c6	85 08		sta $08				sta 	temp2
.15c8	90 b2		bcc $157c			bcc 	_FPLoop
.15ca	e6 09		inc $09				inc 	temp2+1
.15cc	4c 7c 15	jmp $157c			jmp 	_FPLoop
.15cf					_FPError:
.15cf	a2 17		ldx #$17			ldx 	#ErrorID_NoProc
.15d1	20 36 22	jsr $2236		jsr	errorHandler
.15d4					ScanProc:
.15d4	98		tya				tya
.15d5	48		pha				pha
.15d6	a5 0f		lda $0f				lda 	lowMemory 					; copy the start of the procList, at low memory
.15d8	8d f6 0a	sta $0af6			sta 	procList
.15db	a5 10		lda $10				lda 	lowMemory+1
.15dd	8d f7 0a	sta $0af7			sta 	procList+1
.15e0	20 81 14	jsr $1481			jsr 	ResetCodeAddress 			; back to the start.
.15e3					_ScanLoop:
.15e3	a0 00		ldy #$00			ldy 	#0 							; check reached program end
.15e5	b1 02		lda ($02),y			lda 	(codePtr),y
.15e7	f0 2a		beq $1613			beq 	_ScanExit
.15e9	a0 03		ldy #$03			ldy 	#3							; get first token
.15eb	b1 02		lda ($02),y			lda 	(codePtr),y
.15ed	c9 9d		cmp #$9d			cmp 	#TKW_DEFPROC				; skip next if not DEFPROC
.15ef	d0 12		bne $1603			bne 	_ScanNext
.15f1	a5 03		lda $03				lda 	codePtr+1 					; write high and low
.15f3	20 1b 16	jsr $161b			jsr 	_ScanWrite
.15f6	a5 02		lda $02				lda 	codePtr
.15f8	20 1b 16	jsr $161b			jsr 	_ScanWrite
.15fb	a0 04		ldy #$04			ldy 	#4 							; start of name part
.15fd	20 26 16	jsr $1626			jsr 	CalculateProcedureHash 		; calculate procedure hash
.1600	20 1b 16	jsr $161b			jsr 	_ScanWrite
.1603					_ScanNext:
.1603	18		clc				clc
.1604	a0 00		ldy #$00			ldy 	#0
.1606	b1 02		lda ($02),y			lda 	(codePtr),y
.1608	65 02		adc $02				adc 	codePtr
.160a	85 02		sta $02				sta 	codePtr
.160c	90 d5		bcc $15e3			bcc 	_ScanLoop
.160e	e6 03		inc $03				inc 	codePtr+1
.1610	4c e3 15	jmp $15e3			jmp 	_ScanLoop
.1613					_ScanExit:
.1613	a9 00		lda #$00			lda 	#0 							; write ending zero.
.1615	20 1b 16	jsr $161b			jsr 	_ScanWrite
.1618	68		pla				pla
.1619	a8		tay				tay
.161a	60		rts				rts
.161b					_ScanWrite:
.161b	a0 00		ldy #$00			ldy 	#0
.161d	91 0f		sta ($0f),y			sta 	(lowMemory),y
.161f	e6 0f		inc $0f				inc 	lowMemory
.1621	d0 02		bne $1625			bne 	_SWNoCarry
.1623	e6 10		inc $10				inc 	lowMemory+1
.1625					_SWNoCarry:
.1625	60		rts				rts
.1626					CalculateProcedureHash:
.1626	a9 00		lda #$00			lda 	#0 							; clear hash.
.1628	85 04		sta $04				sta 	temp0
.162a					_CPHLoop:
.162a	18		clc				clc 								; add character and rotate and add carry back in
.162b	b1 02		lda ($02),y			lda 	(codePtr),y
.162d	65 04		adc $04				adc 	temp0
.162f	6a		ror a				ror 	a
.1630	69 0d		adc #$0d			adc 	#13 						; primes usually good for this sort of thing.
.1632	85 04		sta $04				sta 	temp0 						; (down with this sort of thing)
.1634	b1 02		lda ($02),y			lda 	(codePtr),y
.1636	c8		iny				iny 								; advance incase we go round again.
.1637	c9 3a		cmp #$3a			cmp 	#$3A
.1639	90 ef		bcc $162a			bcc 	_CPHLoop
.163b	a5 04		lda $04				lda 	temp0
.163d	a9 aa		lda #$aa			lda 	#$AA
.163f	60		rts				rts

;******  Return to file: main/main.asm


;******  Processing file: main/commands/stopend.asm

.1640					CommandStop:
.1640	a2 06		ldx #$06			ldx 	#ErrorID_Stop
.1642	20 36 22	jsr $2236		jsr	errorHandler
.1645					CommandEnd:
.1645	4c ff ff	jmp $ffff			jmp 	$FFFF 						; fudge to crash out of emulator
.1648					AdvanceNextLine:
.1648	a0 00		ldy #$00			ldy 	#0 							; get offset
.164a	b1 02		lda ($02),y			lda 	(codePtr),y
.164c	18		clc				clc 								; add to codePtr
.164d	65 02		adc $02				adc 	codePtr
.164f	85 02		sta $02				sta 	codePtr
.1651	90 02		bcc $1655			bcc 	_ANLNoCarry
.1653	e6 03		inc $03				inc 	codePtr+1
.1655					_ANLNoCarry:
.1655	b1 02		lda ($02),y			lda 	(codePtr),y 				; if end of program (or was just stand alone.
.1657	f0 ec		beq $1645			beq 	CommandEnd 					; execute END
.1659	a0 03		ldy #$03			ldy 	#3 							; start of tokens on line.
.165b	60		rts				rts

;******  Return to file: main/main.asm


;******  Processing file: main/commands/transfer.asm

.165c					CommandGOSUB:
.165c	20 dd 1a	jsr $1add			jsr 	EvaluateRootInteger			; get GOSUB line on stack top.
.165f	a2 04		ldx #$04			ldx 	#4 							; allocate 4 bytes on stack for GOSUB
.1661	a9 47		lda #$47			lda 	#markerGOSUB  				; <marker> <return addr/offset>
.1663	20 95 21	jsr $2195			jsr 	RSClaim
.1666	a9 01		lda #$01			lda 	#1 							; save position at offset 1.
.1668	20 c1 21	jsr $21c1			jsr 	RSSavePosition
.166b	a2 00		ldx #$00			ldx 	#0 							; point back at GOSUB line
.166d	f0 1b		beq $168a			beq 	GotoTOS 					; and do a GOTO there.
.166f					CommandRETURN:
.166f	a2 00		ldx #$00			ldx 	#0 							; get TOS return stack
.1671	a1 78		lda ($78,x)			lda 	(rsPointer,x)
.1673	c9 47		cmp #$47			cmp 	#markerGOSUB 						; does it match
.1675	f0 05		beq $167c			beq 	_isok
.1677	a2 0e		ldx #$0e			ldx 	#ErrorID_returnErr
.1679	20 36 22	jsr $2236		jsr	errorHandler
.167c					_isok:
.167c	a9 01		lda #$01			lda 	#1
.167e	20 d4 21	jsr $21d4			jsr 	RSLoadPosition 				; reload the position from offset 1.
.1681	a9 04		lda #$04			lda 	#4 							; throw 4 bytes from stack.
.1683	20 b7 21	jsr $21b7			jsr 	RSFree
.1686	60		rts				rts
.1687					CommandGOTO:
.1687	20 dd 1a	jsr $1add			jsr 	EvaluateRootInteger 		; get GOTO line on stack top.
.168a					GotoTOS:
.168a	20 81 14	jsr $1481			jsr 	ResetCodeAddress 			; simple search.
.168d					_GotoSearch:
.168d	a0 00		ldy #$00			ldy 	#0 							; get offset
.168f	b1 02		lda ($02),y			lda 	(codePtr),y
.1691	f0 21		beq $16b4			beq 	_GotoError 					; not found.
.1693	c8		iny				iny									; check LSB match
.1694	b1 02		lda ($02),y			lda 	(codePtr),y
.1696	d5 48		cmp $48,x			cmp 	esInt0,x
.1698	d0 07		bne $16a1			bne 	_GotoNext
.169a	c8		iny				iny
.169b	b1 02		lda ($02),y			lda 	(codePtr),y
.169d	d5 50		cmp $50,x			cmp 	esInt1,x
.169f	f0 10		beq $16b1			beq 	_GotoFound
.16a1					_GotoNext:
.16a1	a0 00		ldy #$00			ldy 	#0 							; go next line
.16a3	b1 02		lda ($02),y			lda 	(codePtr),y
.16a5	18		clc				clc
.16a6	65 02		adc $02				adc 	codePtr
.16a8	85 02		sta $02				sta 	codePtr
.16aa	90 e1		bcc $168d			bcc 	_GotoSearch
.16ac	e6 03		inc $03				inc 	codePtr+1
.16ae	4c 8d 16	jmp $168d			jmp 	_GotoSearch
.16b1					_GotoFound:
.16b1	a0 03		ldy #$03			ldy 	#3 							; continue from that line
.16b3	60		rts				rts
.16b4					_GotoError:
.16b4	a2 0c		ldx #$0c			ldx 	#ErrorID_LineNumber
.16b6	20 36 22	jsr $2236		jsr	errorHandler

;******  Return to file: main/main.asm


;******  Processing file: main/commands/vdu.asm

.16b9					Command_VDU:
.16b9	20 dd 1a	jsr $1add			jsr 	EvaluateRootInteger 			; get integer at root.
.16bc	a5 48		lda $48				lda 	esInt0
.16be	a2 06		ldx #$06		ldx	#6
.16c0	20 27 22	jsr $2227		jsr	deviceHandler
.16c3					_CVNext:
.16c3	b1 02		lda ($02),y			lda 	(codePtr),y 					; what follows ?
.16c5	c8		iny				iny
.16c6	c9 c8		cmp #$c8			cmp 	#TKW_COMMA 						; comma, do again
.16c8	f0 ef		beq $16b9			beq 	Command_VDU
.16ca	c9 c9		cmp #$c9			cmp 	#TKW_SEMICOLON 					; semicolon, print MSB
.16cc	d0 0a		bne $16d8			bne 	_CVExit
.16ce	a5 50		lda $50				lda 	esInt1
.16d0	a2 06		ldx #$06		ldx	#6
.16d2	20 27 22	jsr $2227		jsr	deviceHandler
.16d5	4c c3 16	jmp $16c3			jmp 	_CVNext
.16d8	88		dey		_CVExit:dey
.16d9	60		rts				rts

;******  Return to file: main/main.asm


;******  Processing file: main/commands/while.asm

.2bcb					Command_While:
.2bcb	a9 57		lda #$57			lda 	#markerWhile 				; gosub marker allocate 4 bytes.
.2bcd	a2 04		ldx #$04			ldx 	#4
.2bcf	20 95 21	jsr $2195			jsr 	RSClaim 					; create on stack.
.2bd2	88		dey				dey
.2bd3	a9 01		lda #$01			lda 	#1
.2bd5	20 c1 21	jsr $21c1			jsr 	RSSavePosition 				; save position before the WHILE keyword.
.2bd8	c8		iny				iny
.2bd9	20 df 1a	jsr $1adf			jsr 	EvaluateInteger				; get the conditional
.2bdc	20 21 21	jsr $2121			jsr 	MInt32Zero 	 				; if zero, skip forward.
.2bdf	f0 01		beq $2be2			beq 	_CWFail
.2be1	60		rts				rts
.2be2					_CWFail:
.2be2	a9 04		lda #$04			lda 	#4
.2be4	20 b7 21	jsr $21b7			jsr 	RSFree 						; close the just opened position.
.2be7	a9 9f		lda #$9f			lda 	#TKW_WEND 					; scan forward past WEND.
.2be9	aa		tax				tax
.2bea	20 06 2c	jsr $2c06			jsr 	ScanForward
.2bed	60		rts				rts
.2bee					Command_Wend:
.2bee	a2 00		ldx #$00			ldx 	#0 							; get TOS return stack
.2bf0	a1 78		lda ($78,x)			lda 	(rsPointer,x)
.2bf2	c9 57		cmp #$57			cmp 	#markerWHILE 						; does it match
.2bf4	f0 05		beq $2bfb			beq 	_isok
.2bf6	a2 11		ldx #$11			ldx 	#ErrorID_wendErr
.2bf8	20 36 22	jsr $2236		jsr	errorHandler
.2bfb					_isok:
.2bfb	a9 01		lda #$01			lda 	#1
.2bfd	20 d4 21	jsr $21d4			jsr 	RSLoadPosition				; go back until true
.2c00	a9 04		lda #$04			lda 	#4
.2c02	20 b7 21	jsr $21b7			jsr 	RSFree 						; close the loop
.2c05	60		rts				rts

;******  Return to file: main/main.asm


;******  Processing file: main/evaluate/binary.asm

.16da					BinaryProcess:
.16da	b5 40		lda $40,x			lda 	esType,x 					; or type bytes together and check bit 6.
.16dc	15 41		ora $41,x			ora 	esType+1,x
.16de	0a		asl a				asl 	a
.16df	30 0e		bmi $16ef			bmi 	_BPStringType 				; if one is set, then string type.
.16e1	18		clc				clc 								; return CC for integer
.16e2	29 02		and #$02			and 	#$02 						; $02 because of ASL A.
.16e4	f0 08		beq $16ee			beq 	_BPExit 					; if both integer then return with CC.
.16e6	20 f4 16	jsr $16f4			jsr 	BPMakeBothFloat 			; make both float
.16e9	a9 01		lda #$01			lda 	#$01 						; set result type to float
.16eb	95 40		sta $40,x			sta 	esType,x
.16ed	38		sec				sec 								; and return with carry set.
.16ee					_BPExit:
.16ee	60		rts				rts
.16ef					_BPStringType:
.16ef	a2 07		ldx #$07			ldx 	#ErrorID_BadType
.16f1	20 36 22	jsr $2236		jsr	errorHandler
.16f4					BPMakeBothFloat:
.16f4	e8		inx				inx
.16f5	20 f9 16	jsr $16f9			jsr 	BPMakeFloat 				; one is a float, so we do both as floats.
.16f8	ca		dex				dex
.16f9					BPMakeFloat:
.16f9	b5 40		lda $40,x			lda 	esType,x 					; get type bit.
.16fb	4a		lsr a				lsr 	a
.16fc	b0 07		bcs $1705			bcs 	_BPIsFloat
.16fe	8a		txa				txa
.16ff	a2 1a		ldx #$1a		ldx	#26
.1701	20 21 25	jsr $2521		jsr	floatingpointHandler
.1704	aa		tax				tax
.1705					_BPIsFloat:
.1705	60		rts				rts
.1706					AddHandler:
.1706	20 55 19	jsr $1955			jsr 	DereferenceTwo 				; dereference top two on stack.
.1709	b5 40		lda $40,x			lda 	esType,x 					; check two strings.
.170b	35 41		and $41,x			and 	esType+1,x
.170d	29 40		and #$40			and 	#$40 						; if both have bit 6 set ...
.170f	d0 10		bne $1721			bne 	_AHStringConcat				; concatenate strings.
.1711	20 da 16	jsr $16da			jsr 	BinaryProcess 				; check to see if either is float
.1714	b0 03		bcs $1719			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.1716	4c e3 1f	jmp $1fe3			jmp 	MInt32Add 							; else do it as integer.
.1719					_IsFPOperation:
.1719	8a		txa				txa 								; call the relevant fp routine
.171a	a2 02		ldx #$02		ldx	#2
.171c	20 21 25	jsr $2521		jsr	floatingpointHandler
.171f	aa		tax				tax
.1720	60		rts				rts
.1721					_AHStringConcat:
.1721	8a		txa				txa
.1722	a2 04		ldx #$04		ldx	#4
.1724	20 bd 27	jsr $27bd		jsr	stringHandler
.1727	aa		tax				tax
.1728	60		rts				rts
.1729					SubHandler:
.1729	20 55 19	jsr $1955			jsr 	DereferenceTwo
.172c	20 da 16	jsr $16da			jsr 	BinaryProcess 				; check to see if either is float
.172f	b0 03		bcs $1734			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.1731	4c fd 1f	jmp $1ffd			jmp 	MInt32Sub 							; else do it as integer.
.1734					_IsFPOperation:
.1734	8a		txa				txa 								; call the relevant fp routine
.1735	a2 10		ldx #$10		ldx	#16
.1737	20 21 25	jsr $2521		jsr	floatingpointHandler
.173a	aa		tax				tax
.173b	60		rts				rts
.173c					MulHandler:
.173c	20 55 19	jsr $1955			jsr 	DereferenceTwo
.173f	20 da 16	jsr $16da			jsr 	BinaryProcess 				; check to see if either is float
.1742	b0 03		bcs $1747			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.1744	4c 17 20	jmp $2017			jmp 	MInt32Multiply 							; else do it as integer.
.1747					_IsFPOperation:
.1747	8a		txa				txa 								; call the relevant fp routine
.1748	a2 0a		ldx #$0a		ldx	#10
.174a	20 21 25	jsr $2521		jsr	floatingpointHandler
.174d	aa		tax				tax
.174e	60		rts				rts
.174f					DivHandler:
.174f	20 55 19	jsr $1955			jsr 	DereferenceTwo
.1752	20 da 16	jsr $16da			jsr 	BinaryProcess 				; check to see if either is float
.1755	b0 03		bcs $175a			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.1757	4c db 1e	jmp $1edb			jmp 	MInt32SDivide 							; else do it as integer.
.175a					_IsFPOperation:
.175a	8a		txa				txa 								; call the relevant fp routine
.175b	a2 06		ldx #$06		ldx	#6
.175d	20 21 25	jsr $2521		jsr	floatingpointHandler
.1760	aa		tax				tax
.1761	60		rts				rts
.1762					ModHandler:
.1762	20 55 19	jsr $1955			jsr 	DereferenceTwo
.1765	20 da 16	jsr $16da			jsr 	BinaryProcess 				; check to see if either is float
.1768	b0 03		bcs $176d			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.176a	4c 59 1f	jmp $1f59			jmp 	MInt32Modulus 							; else do it as integer.
.176d					_IsFPOperation:
.176d	8a		txa				txa 								; call the relevant fp routine
.176e	a2 08		ldx #$08		ldx	#8
.1770	20 21 25	jsr $2521		jsr	floatingpointHandler
.1773	aa		tax				tax
.1774	60		rts				rts
.1775					XorHandler:
.1775	20 55 19	jsr $1955			jsr 	DereferenceTwo
.1778	20 da 16	jsr $16da			jsr 	BinaryProcess 				; check to see if either is float
.177b	b0 03		bcs $1780			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.177d	4c 8d 1e	jmp $1e8d			jmp 	MInt32Xor 							; else do it as integer.
.1780					_IsFPOperation:
.1780	8a		txa				txa 								; call the relevant fp routine
.1781	a2 08		ldx #$08		ldx	#8
.1783	20 21 25	jsr $2521		jsr	floatingpointHandler
.1786	aa		tax				tax
.1787	60		rts				rts
.1788					OrHandler:
.1788	20 55 19	jsr $1955			jsr 	DereferenceTwo
.178b	20 da 16	jsr $16da			jsr 	BinaryProcess 				; check to see if either is float
.178e	b0 03		bcs $1793			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.1790	4c 74 1e	jmp $1e74			jmp 	MInt32Or 							; else do it as integer.
.1793					_IsFPOperation:
.1793	8a		txa				txa 								; call the relevant fp routine
.1794	a2 08		ldx #$08		ldx	#8
.1796	20 21 25	jsr $2521		jsr	floatingpointHandler
.1799	aa		tax				tax
.179a	60		rts				rts
.179b					AndHandler:
.179b	20 55 19	jsr $1955			jsr 	DereferenceTwo
.179e	20 da 16	jsr $16da			jsr 	BinaryProcess 				; check to see if either is float
.17a1	b0 03		bcs $17a6			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.17a3	4c 5b 1e	jmp $1e5b			jmp 	MInt32And 							; else do it as integer.
.17a6					_IsFPOperation:
.17a6	8a		txa				txa 								; call the relevant fp routine
.17a7	a2 08		ldx #$08		ldx	#8
.17a9	20 21 25	jsr $2521		jsr	floatingpointHandler
.17ac	aa		tax				tax
.17ad	60		rts				rts
.17ae					ShlHandler:
.17ae	20 55 19	jsr $1955			jsr 	DereferenceTwo
.17b1	20 da 16	jsr $16da			jsr 	BinaryProcess 				; check to see if either is float
.17b4	b0 03		bcs $17b9			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.17b6	4c 2f 18	jmp $182f			jmp 	Mint32ShiftLeftX 							; else do it as integer.
.17b9					_IsFPOperation:
.17b9	8a		txa				txa 								; call the relevant fp routine
.17ba	a2 08		ldx #$08		ldx	#8
.17bc	20 21 25	jsr $2521		jsr	floatingpointHandler
.17bf	aa		tax				tax
.17c0	60		rts				rts
.17c1					ShrHandler:
.17c1	20 55 19	jsr $1955			jsr 	DereferenceTwo
.17c4	20 da 16	jsr $16da			jsr 	BinaryProcess 				; check to see if either is float
.17c7	b0 03		bcs $17cc			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.17c9	4c 32 18	jmp $1832			jmp 	MInt32ShiftRightX 							; else do it as integer.
.17cc					_IsFPOperation:
.17cc	8a		txa				txa 								; call the relevant fp routine
.17cd	a2 08		ldx #$08		ldx	#8
.17cf	20 21 25	jsr $2521		jsr	floatingpointHandler
.17d2	aa		tax				tax
.17d3	60		rts				rts
.17d4					WordRefHandler:
.17d4	20 55 19	jsr $1955			jsr 	DereferenceTwo
.17d7	20 da 16	jsr $16da			jsr 	BinaryProcess 				; check to see if either is float
.17da	b0 03		bcs $17df			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.17dc	4c 21 18	jmp $1821			jmp 	MInt32WordIndirect 							; else do it as integer.
.17df					_IsFPOperation:
.17df	8a		txa				txa 								; call the relevant fp routine
.17e0	a2 08		ldx #$08		ldx	#8
.17e2	20 21 25	jsr $2521		jsr	floatingpointHandler
.17e5	aa		tax				tax
.17e6	60		rts				rts
.17e7					ByteRefHandler:
.17e7	20 55 19	jsr $1955			jsr 	DereferenceTwo
.17ea	20 da 16	jsr $16da			jsr 	BinaryProcess 				; check to see if either is float
.17ed	b0 03		bcs $17f2			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.17ef	4c 25 18	jmp $1825			jmp 	MInt32ByteIndirect 							; else do it as integer.
.17f2					_IsFPOperation:
.17f2	8a		txa				txa 								; call the relevant fp routine
.17f3	a2 08		ldx #$08		ldx	#8
.17f5	20 21 25	jsr $2521		jsr	floatingpointHandler
.17f8	aa		tax				tax
.17f9	60		rts				rts
.17fa					PowerHandler:
.17fa	20 55 19	jsr $1955			jsr 	DereferenceTwo
.17fd	20 da 16	jsr $16da			jsr 	BinaryProcess 				; check to see if either is float
.1800	b0 03		bcs $1805			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.1802	4c 0d 18	jmp $180d			jmp 	PowerInteger 							; else do it as integer.
.1805					_IsFPOperation:
.1805	8a		txa				txa 								; call the relevant fp routine
.1806	a2 16		ldx #$16		ldx	#22
.1808	20 21 25	jsr $2521		jsr	floatingpointHandler
.180b	aa		tax				tax
.180c	60		rts				rts
.180d					PowerInteger:
.180d	20 f4 16	jsr $16f4			jsr 	BPMakeBothFloat				; make them float.
.1810	8a		txa				txa
.1811	a2 16		ldx #$16		ldx	#22
.1813	20 21 25	jsr $2521		jsr	floatingpointHandler
.1816	a2 12		ldx #$12		ldx	#18
.1818	20 21 25	jsr $2521		jsr	floatingpointHandler
.181b	aa		tax				tax
.181c	a9 00		lda #$00			lda 	#0 							; make type integer
.181e	95 40		sta $40,x			sta 	esType,x
.1820	60		rts				rts
.1821					Mint32WordIndirect:
.1821	a9 80		lda #$80			lda 	#$80 				 		; word reference type
.1823	d0 02		bne $1827			bne 	Min32Indirect
.1825					Mint32ByteIndirect:
.1825	a9 a0		lda #$a0			lda 	#$A0 						; byte reference type
.1827					Min32Indirect:
.1827	48		pha				pha 								; save the indirection
.1828	20 e3 1f	jsr $1fe3			jsr 	MInt32Add 					; add a!b a?b
.182b	68		pla				pla 								; and set the type to reference.
.182c	95 40		sta $40,x			sta 	esType,x
.182e	60		rts				rts
.182f					Mint32ShiftLeftX:
.182f	18		clc				clc
.1830	90 01		bcc $1833			bcc 	Mint32Shift
.1832					Mint32ShiftRightX:
.1832	38		sec				sec
.1833					Mint32Shift:
.1833	08		php				php 								; save carry flag on stack.
.1834	b5 51		lda $51,x			lda 	esInt1+1,x 					; if shift >= 32 then it is zero.
.1836	15 59		ora $59,x			ora 	esInt2+1,x
.1838	15 61		ora $61,x			ora 	esInt3+1,x
.183a	d0 1e		bne $185a			bne 	_MShiftZero
.183c	b5 49		lda $49,x			lda 	esInt0+1,x
.183e	c9 20		cmp #$20			cmp 	#32
.1840	b0 18		bcs $185a			bcs 	_MShiftZero
.1842					_MShiftLoop:
.1842	b5 49		lda $49,x			lda 	esInt0+1,x 					; check count is zero
.1844	f0 12		beq $1858			beq 	_MShiftExit
.1846	d6 49		dec $49,x			dec 	esInt0+1,x
.1848	28		plp				plp 								; restore and save carry
.1849	08		php				php
.184a	90 06		bcc $1852			bcc 	_MShiftLeft
.184c	20 18 21	jsr $2118			jsr 	Mint32ShiftRight
.184f	4c 42 18	jmp $1842			jmp 	_MShiftLoop
.1852					_MShiftLeft:
.1852	20 0f 21	jsr $210f			jsr 	Mint32ShiftLeft
.1855	4c 42 18	jmp $1842			jmp 	_MShiftLoop
.1858					_MShiftExit:
.1858	28		plp				plp	 								; throw saved carry and exit
.1859	60		rts				rts
.185a					_MShiftZero:
.185a	4c fa 20	jmp $20fa			jmp 	MInt32False 				; return 0.

;******  Return to file: main/main.asm


;******  Processing file: main/evaluate/compare.asm

.185d					PerformComparison:
.185d	20 55 19	jsr $1955			jsr 	DereferenceTwo 				; make both values.
.1860	b5 40		lda $40,x			lda 	esType,x 					; check for two strings.
.1862	35 41		and $41,x			and 	esType+1,x
.1864	0a		asl a				asl 	a
.1865	30 1d		bmi $1884			bmi 	_PCIsString
.1867	b5 40		lda $40,x			lda 	esType,x 					; check either is floating point.
.1869	15 41		ora $41,x			ora 	esType+1,x
.186b	0a		asl a				asl 	a 							; shift bit 6 (string) to bit 7
.186c	30 22		bmi $1890			bmi 	_PCError
.186e	29 02		and #$02			and 	#$02 						; because of ASL, check type in bit 0
.1870	f0 0f		beq $1881			beq 	_PCIsInteger 				; if not two integers
.1872	20 f4 16	jsr $16f4			jsr 	BPMakeBothFloat 			; make both float
.1875	8a		txa				txa
.1876	a2 04		ldx #$04		ldx	#4
.1878	20 21 25	jsr $2521		jsr	floatingpointHandler
.187b	86 0c		stx $0c				stx 	tempShort 					; save result
.187d	aa		tax				tax
.187e	a5 0c		lda $0c				lda 	tempShort
.1880	60		rts				rts
.1881					_PCIsInteger:
.1881	4c a6 1e	jmp $1ea6			jmp 	MInt32Compare
.1884					_PCIsString:
.1884	8a		txa				txa 								; A has SP
.1885	a2 06		ldx #$06		ldx	#6
.1887	20 bd 27	jsr $27bd		jsr	stringHandler
.188a	86 0c		stx $0c				stx 	tempShort 					; save result
.188c	aa		tax				tax 								; put SP back in X and get result.
.188d	a5 0c		lda $0c				lda 	tempShort
.188f	60		rts				rts
.1890					_PCError:
.1890	a2 07		ldx #$07			ldx 	#ErrorID_BadType
.1892	20 36 22	jsr $2236		jsr	errorHandler
.1895					CompareEquals:
.1895	20 5d 18	jsr $185d			jsr 	PerformComparison
.1898	c9 00		cmp #$00			cmp 	#$00
.189a	f0 35		beq $18d1			beq  	CompareTrue
.189c	4c d4 18	jmp $18d4			jmp 	CompareFalse
.189f					CompareLess:
.189f	20 5d 18	jsr $185d			jsr 	PerformComparison
.18a2	c9 ff		cmp #$ff			cmp 	#$FF
.18a4	f0 2b		beq $18d1			beq  	CompareTrue
.18a6	4c d4 18	jmp $18d4			jmp 	CompareFalse
.18a9					CompareGreater:
.18a9	20 5d 18	jsr $185d			jsr 	PerformComparison
.18ac	c9 01		cmp #$01			cmp 	#$01
.18ae	f0 21		beq $18d1			beq  	CompareTrue
.18b0	4c d4 18	jmp $18d4			jmp 	CompareFalse
.18b3					CompareNotEquals:
.18b3	20 5d 18	jsr $185d			jsr 	PerformComparison
.18b6	c9 00		cmp #$00			cmp 	#$00
.18b8	d0 17		bne $18d1			bne  	CompareTrue
.18ba	4c d4 18	jmp $18d4			jmp 	CompareFalse
.18bd					CompareGreaterEq:
.18bd	20 5d 18	jsr $185d			jsr 	PerformComparison
.18c0	c9 ff		cmp #$ff			cmp 	#$FF
.18c2	d0 0d		bne $18d1			bne  	CompareTrue
.18c4	4c d4 18	jmp $18d4			jmp 	CompareFalse
.18c7					CompareLessEq:
.18c7	20 5d 18	jsr $185d			jsr 	PerformComparison
.18ca	c9 01		cmp #$01			cmp 	#$01
.18cc	d0 03		bne $18d1			bne  	CompareTrue
.18ce	4c d4 18	jmp $18d4			jmp 	CompareFalse
.18d1					CompareTrue:
.18d1	4c f6 20	jmp $20f6			jmp 	MInt32True
.18d4					CompareFalse:
.18d4	4c fa 20	jmp $20fa			jmp 	MInt32False

;******  Return to file: main/main.asm


;******  Processing file: main/evaluate/convert.asm

.18d7					Event_Str:
.18d7	20 c9 1a	jsr $1ac9			jsr 	EvaluateNumeric 			; get a number.
.18da	b5 40		lda $40,x			lda 	esType,x 					; is it floating point
.18dc	d0 13		bne $18f1			bne 	_ESFloat
.18de	20 34 19	jsr $1934			jsr 	ConvertGetBase
.18e1	a9 cd		lda #$cd			lda 	#(convertBuffer) & $FF
.18e3	85 04		sta $04				sta 	temp0
.18e5	a9 0a		lda #$0a			lda 	#(convertBuffer) >> 8
.18e7	85 05		sta $05				sta 	1+(temp0)
.18e9	b5 49		lda $49,x			lda 	esInt0+1,x 					; get the base
.18eb	20 50 20	jsr $2050			jsr 	MInt32ToString 				; convert to string.
.18ee	4c fe 18	jmp $18fe			jmp 	_ESCloneExit 				; clone and exit.
.18f1					_ESFloat:
.18f1	20 6d 21	jsr $216d			jsr 	CheckRightParen 			; check closing )
.18f4	20 3c 11	jsr $113c			jsr 	TOSToTemp0 					; string address in temp0, goes here.
.18f7	8a		txa				txa
.18f8	a2 14		ldx #$14		ldx	#20
.18fa	20 21 25	jsr $2521		jsr	floatingpointHandler
.18fd	aa		tax				tax
.18fe					_ESCloneExit:
.18fe	8a		txa				txa
.18ff	a2 02		ldx #$02		ldx	#2
.1901	20 bd 27	jsr $27bd		jsr	stringHandler
.1904	aa		tax				tax
.1905	60		rts				rts
.1906					UnaryVal:
.1906	38		sec				sec
.1907	b0 01		bcs $190a			bcs 	ValueMain
.1909					UnaryIsVal:
.1909	18		clc				clc
.190a					ValueMain:
.190a	08		php				php 								; save results (CS is value, CC is validation)
.190b	20 d4 1a	jsr $1ad4			jsr 	EvaluateString
.190e	20 34 19	jsr $1934			jsr 	ConvertGetBase 				; get base, if any.
.1911	98		tya				tya
.1912	48		pha				pha
.1913	20 3c 11	jsr $113c			jsr 	TOSToTemp0 					; string address in temp0, goes here.
.1916	b5 49		lda $49,x			lda 	esInt0+1,x 					; get the base
.1918	29 7f		and #$7f			and 	#$7F 						; ignore the sign bit.
.191a	20 6d 1f	jsr $1f6d			jsr 	MInt32FromString 			; convert it back from a string.
.191d	b0 0c		bcs $192b			bcs 	_VMSuccess 					; successfully converted.
.191f	b5 49		lda $49,x			lda 	esInt0+1,x 					; is base the default
.1921	c9 8a		cmp #$8a			cmp 	#$80+10 					; if no, then it is integer only.
.1923	f0 00		beq $1925			beq 	_VMFailed 	 				; so we failed.
.1925					_VMFailed:
.1925	68		pla				pla
.1926	a8		tay				tay
.1927	28		plp				plp
.1928	4c fa 20	jmp $20fa			jmp 	MInt32False 				; return 0 whatever.
.192b					_VMSuccess:
.192b	68		pla				pla
.192c	a8		tay				tay
.192d	28		plp				plp 								; if CS the it was val() so we want the value.
.192e	b0 03		bcs $1933			bcs 	_VMExit
.1930	4c f6 20	jmp $20f6			jmp 	MInt32True 					; otherwise return true as successful.
.1933					_VMExit:
.1933	60		rts				rts
.1934					ConvertGetBase:
.1934	a9 8a		lda #$8a			lda 	#10+$80 					; default base 10 signed.
.1936	95 49		sta $49,x			sta 	esInt0+1,x
.1938	b1 02		lda ($02),y			lda 	(codePtr),y
.193a	c9 c8		cmp #$c8			cmp 	#TKW_COMMA
.193c	d0 0e		bne $194c			bne 	_CGBDone
.193e	e8		inx				inx 								; next level
.193f	c8		iny				iny 								; skip comma.
.1940	20 e7 1a	jsr $1ae7			jsr 	EvaluateSmallInteger		; evaluate the base.
.1943	ca		dex				dex
.1944	c9 02		cmp #$02			cmp 	#2
.1946	90 08		bcc $1950			bcc 	_CGBValue
.1948	c9 11		cmp #$11			cmp 	#17
.194a	b0 04		bcs $1950			bcs 	_CGBValue
.194c					_CGBDone:
.194c	20 6d 21	jsr $216d			jsr 	CheckRightParen
.194f	60		rts				rts
.1950					_CGBValue:
.1950	a2 08		ldx #$08			ldx 	#ErrorID_BadValue
.1952	20 36 22	jsr $2236		jsr	errorHandler

;******  Return to file: main/main.asm


;******  Processing file: main/evaluate/dereference.asm

.1955					DereferenceTwo:
.1955	e8		inx				inx
.1956	20 5a 19	jsr $195a			jsr 	DereferenceOne
.1959	ca		dex				dex
.195a					DereferenceOne:
.195a	b5 40		lda $40,x			lda 	esType,x
.195c	10 3d		bpl $199b			bpl 	_DRNotReference 			; is it a reference ?
.195e	4a		lsr a				lsr 	a 							; do float dereference if bit 0 set.
.195f	b0 3b		bcs $199c			bcs 	_DRFloatDeReference
.1961	98		tya				tya
.1962	48		pha				pha
.1963	b5 48		lda $48,x			lda 	esInt0,x 					; copy address to temp0
.1965	85 04		sta $04				sta 	temp0
.1967	b5 50		lda $50,x			lda 	esInt1,x
.1969	85 05		sta $05				sta 	temp0+1
.196b	a9 00		lda #$00			lda 	#0 							; clear esInt1..3
.196d	95 50		sta $50,x			sta 	esInt1,x
.196f	95 58		sta $58,x			sta 	esInt2,x
.1971	95 60		sta $60,x			sta 	esInt3,x
.1973	b5 40		lda $40,x			lda 	esType,x 					; get the type byte.
.1975	29 60		and #$60			and 	#$60 						; get string flag ($40) and byte flag ($20)
.1977	0a		asl a				asl 	a 							; now string ($80) byte ($40)
.1978	30 0d		bmi $1987			bmi 	_DeRefString 				; string, 2 bytes only
.197a	d0 11		bne $198d			bne 	_DeRefByte 					; byte 1 byte only
.197c					_DeRefLong:
.197c	a0 03		ldy #$03			ldy 	#3
.197e	b1 04		lda ($04),y			lda 	(temp0),y
.1980	95 60		sta $60,x			sta 	esInt3,x
.1982	88		dey				dey
.1983	b1 04		lda ($04),y			lda 	(temp0),y
.1985	95 58		sta $58,x			sta 	esInt2,x
.1987					_DeRefString:
.1987	a0 01		ldy #$01			ldy 	#1
.1989	b1 04		lda ($04),y			lda 	(temp0),y
.198b	95 50		sta $50,x			sta 	esInt1,x
.198d					_DeRefByte:
.198d	a0 00		ldy #$00			ldy 	#0
.198f	b1 04		lda ($04),y			lda 	(temp0),y
.1991	95 48		sta $48,x			sta 	esInt0,x
.1993	b5 40		lda $40,x			lda 	esType,x 					; clear byte and deref bits.
.1995	29 40		and #$40			and 	#$40
.1997	95 40		sta $40,x			sta 	esType,x
.1999	68		pla				pla
.199a	a8		tay				tay
.199b					_DRNotReference
.199b	60		rts				rts
.199c					_DRFloatDereference:
.199c	20 3c 11	jsr $113c			jsr 	TOSToTemp0 					; address to deref in temp0
.199f	8a		txa				txa
.19a0	a2 1c		ldx #$1c		ldx	#28
.19a2	20 21 25	jsr $2521		jsr	floatingpointHandler
.19a5	aa		tax				tax
.19a6	a9 01		lda #$01			lda 	#$01 						; type to FP (float)
.19a8	95 40		sta $40,x			sta 	esType,x
.19aa	60		rts				rts

;******  Return to file: main/main.asm


;******  Processing file: main/evaluate/evaluate.asm

.19ab					EvaluateLevel:
.19ab	48		pha				pha 								; save precedence level.
.19ac	a9 00		lda #$00			lda 	#0 							; zero the current stack level.
.19ae	95 48		sta $48,x			sta 	esInt0,x
.19b0	95 50		sta $50,x			sta 	esInt1,x
.19b2	95 58		sta $58,x			sta 	esInt2,x
.19b4	95 60		sta $60,x			sta 	esInt3,x
.19b6	95 40		sta $40,x			sta 	esType,x 					; zero the type (integer value)
.19b8	b1 02		lda ($02),y			lda 	(codePtr),y	 				; look at first token/character
.19ba	30 21		bmi $19dd			bmi 	_ELIsToken 					; if -ve could be string, float, or unary function.
.19bc	0a		asl a				asl 	a 							; if 00-3F then will now be PL and it's a variable.
.19bd	30 0a		bmi $19c9			bmi 	_ELIsConstant 				; 40-7F will be -ve and that's an integer constant.
.19bf	8a		txa				txa 								; stack level in X
.19c0	a2 00		ldx #$00		ldx	#0
.19c2	20 85 2a	jsr $2a85		jsr	variableHandler
.19c5	aa		tax				tax
.19c6	4c 06 1a	jmp $1a06			jmp		_ELHasTerm
.19c9					_ELIsConstant:
.19c9	4a		lsr a				lsr 	a 							; get the value back
.19ca	29 3f		and #$3f			and 	#$3F 						; force into range 0-63
.19cc	95 48		sta $48,x			sta 	esInt0,x 					; and put in LSB.
.19ce					_ELCheckNext:
.19ce	c8		iny				iny 								; look at next
.19cf	b1 02		lda ($02),y			lda 	(codePtr),y
.19d1	49 40		eor #$40			eor 	#$40 						; shift around so 40-7F => 00-3F
.19d3	c9 40		cmp #$40			cmp 	#$40 						; out of range ?
.19d5	b0 2f		bcs $1a06			bcs 	_ELHasTerm 					; done getting the constant.
.19d7	20 1f 1b	jsr $1b1f			jsr 	ELShiftByteIn 				; shift byte into position.
.19da	4c ce 19	jmp $19ce			jmp 	_ELCheckNext
.19dd					_ELIsToken:
.19dd	c9 85		cmp #$85			cmp 	#TOK_STR 					; handle strings.
.19df	f0 0f		beq $19f0			beq 	_ELIsString
.19e1	c9 84		cmp #$84			cmp 	#TOK_FPC 					; if no, then check unary.
.19e3	d0 5f		bne $1a44			bne 	_ELCheckUnary
.19e5	8a		txa				txa 								; put X into A
.19e6	c8		iny				iny 								; skip over the float marker
.19e7	a2 18		ldx #$18		ldx	#24
.19e9	20 21 25	jsr $2521		jsr	floatingpointHandler
.19ec	aa		tax				tax 								; restore X
.19ed	4c 06 1a	jmp $1a06			jmp 	_ELHasTerm
.19f0					_ELIsString:
.19f0	98		tya				tya 								; address of string is codePtr+y+1
.19f1	38		sec				sec
.19f2	65 02		adc $02				adc 	codePtr
.19f4	95 48		sta $48,x			sta 	esInt0,x
.19f6	a5 03		lda $03				lda 	codePtr+1
.19f8	69 00		adc #$00			adc 	#0
.19fa	95 50		sta $50,x			sta 	esInt1,x
.19fc	a9 40		lda #$40			lda 	#$40 						; set type to string value
.19fe	95 40		sta $40,x			sta 	esType,x
.1a00	c8		iny				iny 								; skip over string.
.1a01	98		tya				tya
.1a02	38		sec				sec									; +1 for the length itself.
.1a03	71 02		adc ($02),y			adc 	(codePtr),y
.1a05	a8		tay				tay 								; and fall through to term loop code.
.1a06					_ELHasTerm:
.1a06	b1 02		lda ($02),y			lda 	(codePtr),y
.1a08	c9 86		cmp #$86			cmp 	#TOK_BINARYST 				; check in the correct range for binary tokens.
.1a0a	90 04		bcc $1a10			bcc 	_ELPopExit
.1a0c	c9 99		cmp #$99			cmp 	#TOK_STRUCTST
.1a0e	90 02		bcc $1a12			bcc 	_ELHasBinaryTerm
.1a10					_ELPopExit:
.1a10	68		pla				pla
.1a11					_ELExit:
.1a11	60		rts				rts
.1a12					_ELHasBinaryTerm:
.1a12	84 0c		sty $0c				sty 	tempShort 					; save position
.1a14	a8		tay				tay 								; use token as an index and get the precedence.
.1a15	b9 c7 1a	lda $1ac7,y			lda 	ELBinaryOperatorInfo-TOK_BINARYST,y
.1a18	a4 0c		ldy $0c				ldy 	tempShort 					; restore Y
.1a1a	85 0c		sta $0c				sta 	tempShort 					; save precedence in memory.
.1a1c	68		pla				pla 								; restore current level.
.1a1d	c5 0c		cmp $0c				cmp 	tempShort 					; if current >= operator then exit
.1a1f	b0 f0		bcs $1a11			bcs 	_ELExit
.1a21	48		pha				pha 								; save current level back on the stack.
.1a22	b1 02		lda ($02),y			lda 	(codePtr),y 				; save the binary operator on the stack and skip it.
.1a24	48		pha				pha
.1a25	c8		iny				iny
.1a26	e8		inx				inx 								; calculate the RHS at the operator precedence.
.1a27	a5 0c		lda $0c				lda 	tempShort
.1a29	20 ab 19	jsr $19ab			jsr 	EvaluateLevel
.1a2c	ca		dex				dex
.1a2d	68		pla				pla 								; get the operator back out.
.1a2e					_ELExecuteA:
.1a2e	86 0c		stx $0c				stx 	tempShort 					; upload the vectors. Would be nice to use jmp (aaaa,x)
.1a30	0a		asl a				asl 	a 							; but not practical. May use push/rts later.
.1a31	aa		tax				tax
.1a32	bd 98 14	lda $1498,x			lda 	Group0Vectors,x
.1a35	85 04		sta $04				sta 	temp0
.1a37	bd 99 14	lda $1499,x			lda 	Group0Vectors+1,x
.1a3a	85 05		sta $05				sta 	temp0+1
.1a3c	a6 0c		ldx $0c				ldx 	tempShort
.1a3e	20 8b 1a	jsr $1a8b			jsr 	_ELCallTemp0
.1a41	4c 06 1a	jmp $1a06			jmp 	_ELHasTerm 					; and loop back round.
.1a44					_ELCheckUnary:
.1a44	c8		iny				iny 								; skip over token.
.1a45	c9 90		cmp #$90			cmp 	#TKW_MINUS 					; is it - term
.1a47	f0 19		beq $1a62			beq 	_ELMinus
.1a49	c9 97		cmp #$97			cmp 	#TKW_PLING 					; is it ! or ? term
.1a4b	f0 2c		beq $1a79			beq 	_ELIndirect
.1a4d	c9 98		cmp #$98			cmp 	#TKW_QMARK
.1a4f	f0 28		beq $1a79			beq 	_ELIndirect
.1a51	c9 83		cmp #$83			cmp 	#TOK_SHIFT3 				; is it the unary extension.
.1a53	f0 39		beq $1a8e			beq 	_ELExtension
.1a55	c9 a4		cmp #$a4			cmp 	#TOK_UNARYST 				; must be TOK_UNARYST ... TOK_TOKENS
.1a57	90 04		bcc $1a5d			bcc 	_ELUSyntax
.1a59	c9 c6		cmp #$c6			cmp 	#TOK_TOKENS
.1a5b	90 d1		bcc $1a2e			bcc 	_ELExecuteA 				; if so do that token.
.1a5d					_ELUSyntax:
.1a5d	a2 02		ldx #$02			ldx 	#ErrorID_Syntax
.1a5f	20 36 22	jsr $2236		jsr	errorHandler
.1a62					_ELMinus:
.1a62	20 a8 1a	jsr $1aa8			jsr 	EvaluateNumericTerm 		; get a number to negate.
.1a65	b5 40		lda $40,x			lda 	esType,x 					; is it integer
.1a67	f0 0a		beq $1a73			beq 	_ELMinusInteger
.1a69	8a		txa				txa
.1a6a	a2 0c		ldx #$0c		ldx	#12
.1a6c	20 21 25	jsr $2521		jsr	floatingpointHandler
.1a6f	aa		tax				tax
.1a70	4c 06 1a	jmp $1a06			jmp 	_ELHasTerm
.1a73					_ELMinusInteger:
.1a73	20 b4 20	jsr $20b4			jsr 	MInt32Negate 				; do int negate
.1a76	4c 06 1a	jmp $1a06			jmp 	_ELHasTerm
.1a79					_ELIndirect:
.1a79	48		pha				pha 								; save what we want (TKW_QMARK TWK_PLING)
.1a7a	20 b1 1a	jsr $1ab1			jsr 	EvaluateIntegerTerm 		; integer address
.1a7d	68		pla				pla
.1a7e	49 97		eor #$97			eor 	#TKW_PLING 					; now $00 if !
.1a80	f0 02		beq $1a84			beq 	_ELHaveModifier
.1a82	a9 20		lda #$20			lda 	#$20 						; now $00 if !, $20 if ?
.1a84					_ELHaveModifier:
.1a84	09 80		ora #$80			ora 	#$80						; make it the appropriate reference.
.1a86	95 40		sta $40,x			sta 	esType,x
.1a88	4c 06 1a	jmp $1a06			jmp 	_ELHasTerm
.1a8b					_ELCallTemp0:
.1a8b	6c 04 00	jmp ($0004)			jmp 	(temp0)
.1a8e					_ELExtension:
.1a8e	8a		txa				txa 								; stack pos in A
.1a8f	20 90 24	jsr $2490		jsr	extensionHandler
.1a92	aa		tax				tax 								; restore stack
.1a93	4c 06 1a	jmp $1a06			jmp 	_ELHasTerm
.1a96					UnaryParenthesis:
.1a96	a9 00		lda #$00			lda 	#0 							; ( is a unary function ....
.1a98	20 ab 19	jsr $19ab			jsr 	EvaluateLevel
.1a9b	20 6d 21	jsr $216d			jsr 	CheckRightParen 			; check for )
.1a9e	60		rts				rts
.1a9f					EvaluateTerm:
.1a9f	a9 0f		lda #$0f			lda 	#15
.1aa1	20 ab 19	jsr $19ab			jsr 	EvaluateLevel
.1aa4	20 5a 19	jsr $195a			jsr 	DereferenceOne
.1aa7	60		rts				rts
.1aa8					EvaluateNumericTerm:
.1aa8	20 9f 1a	jsr $1a9f			jsr 	EvaluateTerm
.1aab	b5 40		lda $40,x			lda 	esType,x
.1aad	0a		asl a				asl 	a 							; see if it's a string.
.1aae	30 09		bmi $1ab9			bmi 	ENTType
.1ab0	60		rts				rts
.1ab1					EvaluateIntegerTerm:
.1ab1	20 9f 1a	jsr $1a9f			jsr 	EvaluateTerm
.1ab4	b5 40		lda $40,x			lda 	esType,x
.1ab6	d0 01		bne $1ab9			bne 	ENTType
.1ab8	60		rts				rts
.1ab9					ENTType:
.1ab9	a2 07		ldx #$07			ldx 	#ErrorID_BadType
.1abb	20 36 22	jsr $2236		jsr	errorHandler
.1abe					EvaluateRoot:
.1abe	a2 00		ldx #$00			ldx 	#0
.1ac0					Evaluate:
.1ac0	a9 00		lda #$00			lda 	#0
.1ac2	20 ab 19	jsr $19ab			jsr 	EvaluateLevel
.1ac5	20 5a 19	jsr $195a			jsr 	DereferenceOne
.1ac8	60		rts				rts
.1ac9					EvaluateNumeric:
.1ac9	20 c0 1a	jsr $1ac0			jsr 	Evaluate
.1acc	b5 40		lda $40,x			lda 	esType,x
.1ace	0a		asl a				asl 	a 							; see if it's a string.
.1acf	30 e8		bmi $1ab9			bmi 	ENTType
.1ad1	4a		lsr a				lsr 	a 							; shift float flag into carry.
.1ad2	4a		lsr a				lsr 	a
.1ad3	60		rts				rts
.1ad4					EvaluateString:
.1ad4	20 c0 1a	jsr $1ac0			jsr 	Evaluate
.1ad7	b5 40		lda $40,x			lda 	esType,x
.1ad9	0a		asl a				asl 	a 							; see if it's a string.
.1ada	10 dd		bpl $1ab9			bpl 	ENTType
.1adc	60		rts				rts
.1add					EvaluateRootInteger:
.1add	a2 00		ldx #$00			ldx 	#0
.1adf					EvaluateInteger:
.1adf	20 c0 1a	jsr $1ac0			jsr 	Evaluate
.1ae2	b5 40		lda $40,x			lda 	esType,x
.1ae4	d0 d3		bne $1ab9			bne 	ENTType
.1ae6	60		rts				rts
.1ae7					EvaluateSmallInteger:
.1ae7	20 df 1a	jsr $1adf			jsr 	EvaluateInteger
.1aea	b5 50		lda $50,x			lda 	esInt1,x
.1aec	15 58		ora $58,x			ora 	esInt2,x
.1aee	15 60		ora $60,x			ora 	esInt3,x
.1af0	d0 03		bne $1af5			bne 	_ESIValue
.1af2	b5 48		lda $48,x			lda 	esInt0,x
.1af4	60		rts				rts
.1af5					_ESIValue:
.1af5	a2 08		ldx #$08			ldx 	#ErrorID_BadValue
.1af7	20 36 22	jsr $2236		jsr	errorHandler
.1afa					LinkEvaluate:
.1afa	aa		tax				tax
.1afb	20 c0 1a	jsr $1ac0			jsr 	Evaluate
.1afe	8a		txa				txa
.1aff	60		rts				rts
.1b00					LinkEvaluateInteger:
.1b00	aa		tax				tax
.1b01	20 df 1a	jsr $1adf			jsr 	EvaluateInteger
.1b04	8a		txa				txa
.1b05	60		rts				rts
.1b06					LinkEvaluateSmallInt:
.1b06	aa		tax				tax
.1b07	20 e7 1a	jsr $1ae7			jsr 	EvaluateSmallInteger
.1b0a	8a		txa				txa
.1b0b	60		rts				rts
.1b0c					EvaluateReference:
.1b0c	ad 5e 1b	lda $1b5e			lda 	ELBinaryOperatorInfo+TKW_PLING-TOK_BINARYST
.1b0f	38		sec				sec 								; sub 1 to allow a!x b?x to work.
.1b10	e9 01		sbc #$01			sbc 	#1
.1b12	20 ab 19	jsr $19ab			jsr 	EvaluateLevel
.1b15	b5 40		lda $40,x			lda 	esType,x
.1b17	10 01		bpl $1b1a			bpl 	_ERFail
.1b19	60		rts				rts
.1b1a					_ERFail:
.1b1a	a2 0b		ldx #$0b			ldx 	#ErrorID_NoReference
.1b1c	20 36 22	jsr $2236		jsr	errorHandler
.1b1f					ELShiftByteIn:
.1b1f	48		pha				pha 								; save bits to shift in.
.1b20	b5 60		lda $60,x			lda 	esInt3,x 					; save top most byte
.1b22	48		pha				pha
.1b23	b5 58		lda $58,x			lda 	esInt2,x 					; shift everything left 8 bits
.1b25	95 60		sta $60,x			sta 	esInt3,x
.1b27	b5 50		lda $50,x			lda 	esInt1,x
.1b29	95 58		sta $58,x			sta 	esInt2,x
.1b2b	b5 48		lda $48,x			lda 	esInt0,x
.1b2d	95 50		sta $50,x			sta 	esInt1,x
.1b2f	a9 00		lda #$00			lda 	#0
.1b31	95 48		sta $48,x			sta 	esInt0,x
.1b33	68		pla				pla 								; now A:TOS is a 5 byte register, shift right twice.
.1b34	29 03		and #$03			and 	#3 							; only want lower 2 bits
.1b36	09 04		ora #$04			ora 	#4  						; set bit 2 - when 1 we are done
.1b38					_ELShiftLoop:
.1b38	4a		lsr a				lsr 	a
.1b39	76 60		ror $60,x			ror 	esInt3,x
.1b3b	76 58		ror $58,x			ror 	esInt2,x
.1b3d	76 50		ror $50,x			ror 	esInt1,x
.1b3f	76 48		ror $48,x			ror 	esInt0,x
.1b41	c9 01		cmp #$01			cmp 	#1
.1b43	d0 f3		bne $1b38			bne 	_ELShiftLoop
.1b45	68		pla				pla 								; get original 6 bit value and OR in.
.1b46	29 3f		and #$3f			and 	#$3F
.1b48	15 48		ora $48,x			ora 	esInt0,x
.1b4a	95 48		sta $48,x			sta 	esInt0,x
.1b4c	60		rts				rts
.1b4d					ELBinaryOperatorInfo:

;******  Processing file: main/evaluate/../../generated/binarystructinfo.inc

>1b4d	01					.byte	$01			; $86 and
>1b4e	01					.byte	$01			; $87 or
>1b4f	01					.byte	$01			; $88 xor
>1b50	02					.byte	$02			; $89 >=
>1b51	02					.byte	$02			; $8a <=
>1b52	02					.byte	$02			; $8b >
>1b53	02					.byte	$02			; $8c <
>1b54	02					.byte	$02			; $8d =
>1b55	02					.byte	$02			; $8e <>
>1b56	03					.byte	$03			; $8f +
>1b57	03					.byte	$03			; $90 -
>1b58	04					.byte	$04			; $91 >>
>1b59	04					.byte	$04			; $92 <<
>1b5a	04					.byte	$04			; $93 *
>1b5b	04					.byte	$04			; $94 /
>1b5c	04					.byte	$04			; $95 mod
>1b5d	05					.byte	$05			; $96 ^
>1b5e	06					.byte	$06			; $97 !
>1b5f	06					.byte	$06			; $98 ?
>1b60	82					.byte	$82			; $99 repeat
>1b61	82					.byte	$82			; $9a while
>1b62	82					.byte	$82			; $9b for
>1b63	82					.byte	$82			; $9c if
>1b64	82					.byte	$82			; $9d defproc
>1b65	80					.byte	$80			; $9e until
>1b66	80					.byte	$80			; $9f wend
>1b67	80					.byte	$80			; $a0 next
>1b68	80					.byte	$80			; $a1 then
>1b69	80					.byte	$80			; $a2 endif
>1b6a	80					.byte	$80			; $a3 endproc

;******  Return to file: main/evaluate/evaluate.asm


;******  Return to file: main/main.asm


;******  Processing file: main/evaluate/event.asm

.1b6b					EventFunction:
.1b6b	20 0c 1b	jsr $1b0c			jsr 	EvaluateReference			; get the variable reference.
.1b6e	b5 40		lda $40,x			lda 	esType,x
.1b70	c9 80		cmp #$80			cmp 	#$80 						; must be int ref
.1b72	d0 5b		bne $1bcf			bne 	_EFType
.1b74	20 7a 21	jsr $217a			jsr 	CheckComma
.1b77	e8		inx				inx
.1b78	20 df 1a	jsr $1adf			jsr 	EvaluateInteger		 		; get the elapsed time between firing.
.1b7b	20 6d 21	jsr $216d			jsr 	CheckRightParen 			; finish off with the
.1b7e	ca		dex				dex
.1b7f	b5 50		lda $50,x			lda 	esInt1,x 					; check max of 32767
.1b81	29 80		and #$80			and 	#$80
.1b83	15 58		ora $58,x			ora 	esInt2,x
.1b85	15 60		ora $60,x			ora 	esInt3,x
.1b87	d0 41		bne $1bca			bne 	_EFValue
.1b89	98		tya				tya
.1b8a	48		pha				pha
.1b8b	8a		txa				txa
.1b8c	48		pha				pha
.1b8d	a2 0a		ldx #$0a		ldx	#10
.1b8f	20 27 22	jsr $2227		jsr	deviceHandler
.1b92	84 07		sty $07				sty 	temp1+1
.1b94	85 06		sta $06				sta 	temp1
.1b96	68		pla				pla
.1b97	aa		tax				tax
.1b98	20 3c 11	jsr $113c			jsr 	TOSToTemp0 					; point temp0 to the variable.
.1b9b	a0 03		ldy #$03			ldy 	#3							; if -ve
.1b9d	b1 04		lda ($04),y			lda 	(temp0),y
.1b9f	30 23		bmi $1bc4			bmi 	_EFFail 	 				; straight out with fail, means on pause.
.1ba1	a0 00		ldy #$00			ldy 	#0 							; is the fire time zero ?
.1ba3	b1 04		lda ($04),y			lda 	(temp0),y
.1ba5	c8		iny				iny
.1ba6	11 04		ora ($04),y			ora 	(temp0),y
.1ba8	f0 17		beq $1bc1			beq 	_EFInitialise 				; if so, initialise the value but return false.
.1baa	a0 00		ldy #$00			ldy 	#0 							; calculate trigger - timer
.1bac	38		sec				sec
.1bad	b1 04		lda ($04),y			lda 	(temp0),y
.1baf	e5 06		sbc $06				sbc 	temp1
.1bb1	c8		iny				iny
.1bb2	b1 04		lda ($04),y			lda 	(temp0),y
.1bb4	e5 07		sbc $07				sbc 	temp1+1
.1bb6	10 0c		bpl $1bc4			bpl 	_EFFail 					; if trigger >= timer then return False
.1bb8	20 d4 1b	jsr $1bd4			jsr 	SetEventTimer 				; reset the timer for next time.
.1bbb	20 f6 20	jsr $20f6			jsr	 	MInt32True 					; and treutn true as fired.
.1bbe	68		pla				pla
.1bbf	a8		tay				tay
.1bc0	60		rts				rts
.1bc1					_EFInitialise:
.1bc1	20 d4 1b	jsr $1bd4			jsr		SetEventTimer 				; set trigger time to time + elapsed
.1bc4					_EFFail:
.1bc4	68		pla				pla
.1bc5	a8		tay				tay
.1bc6	20 fa 20	jsr $20fa			jsr 	MInt32False
.1bc9	60		rts				rts
.1bca					_EFValue:
.1bca	a2 08		ldx #$08			ldx 	#ErrorID_BadValue
.1bcc	20 36 22	jsr $2236		jsr	errorHandler
.1bcf					_EFType:
.1bcf	a2 07		ldx #$07			ldx 	#ErrorID_BadType
.1bd1	20 36 22	jsr $2236		jsr	errorHandler
.1bd4					SetEventTimer:
.1bd4	a0 00		ldy #$00			ldy 	#0 							; add elapsed to current time, store in variable
.1bd6	18		clc				clc
.1bd7	a5 06		lda $06				lda 	temp1
.1bd9	75 49		adc $49,x			adc 	esInt0+1,x
.1bdb	91 04		sta ($04),y			sta		(temp0),y
.1bdd	c8		iny				iny
.1bde	a5 07		lda $07				lda 	temp1+1
.1be0	75 51		adc $51,x			adc 	esInt1+1,x
.1be2	91 04		sta ($04),y			sta		(temp0),y
.1be4	88		dey				dey
.1be5	11 04		ora ($04),y			ora 	(temp0),y 					; if the result is non zero, exit
.1be7	d0 04		bne $1bed			bne 	_SETExit
.1be9	a9 01		lda #$01			lda 	#1 							; timer zero won't work, so make it 1, which is
.1beb	91 04		sta ($04),y			sta 	(temp0),y 					; near enough.
.1bed					_SETExit:
.1bed	60		rts				rts

;******  Return to file: main/main.asm


;******  Processing file: main/evaluate/unary.asm

.1bee					UnaryLen:
.1bee	20 fc 1b	jsr $1bfc			jsr 	ULStart
.1bf1					ULFinish:
.1bf1	b1 04		lda ($04),y			lda 	(temp0),y
.1bf3	a4 0c		ldy $0c				ldy 	tempShort
.1bf5	20 09 21	jsr $2109			jsr 	MInt32Set8Bit
.1bf8	20 6d 21	jsr $216d			jsr 	CheckRightParen
.1bfb	60		rts				rts
.1bfc	20 d4 1a	jsr $1ad4	ULStart:jsr 	EvaluateString
.1bff	b5 48		lda $48,x			lda 	esInt0,x 					; copy address of string to temp0
.1c01	85 04		sta $04				sta 	temp0
.1c03	b5 50		lda $50,x			lda 	esInt1,x
.1c05	85 05		sta $05				sta 	temp0+1
.1c07	84 0c		sty $0c				sty 	tempShort 					; get length
.1c09	a0 00		ldy #$00			ldy 	#0
.1c0b	60		rts				rts
.1c0c					UnaryAsc:
.1c0c	20 fc 1b	jsr $1bfc			jsr 	ULStart 					; same as LEN() get string, save Y, point to length.
.1c0f	b1 04		lda ($04),y			lda 	(temp0),y
.1c11	c8		iny				iny 		 						; point to first character, we can do LEN code after that
.1c12	c9 00		cmp #$00			cmp 	#0
.1c14	d0 db		bne $1bf1			bne 	ULFinish
.1c16	a2 08		ldx #$08			ldx 	#ErrorID_BadValue
.1c18	20 36 22	jsr $2236		jsr	errorHandler
.1c1b					UnaryAbs:
.1c1b	20 c9 1a	jsr $1ac9			jsr 	EvaluateNumeric
.1c1e	b0 07		bcs $1c27			bcs 	_UAFloat
.1c20	20 af 20	jsr $20af			jsr 	MInt32Absolute
.1c23	20 6d 21	jsr $216d			jsr 	CheckRightParen
.1c26	60		rts				rts
.1c27					_UAFloat:
.1c27	8a		txa				txa
.1c28	a2 00		ldx #$00		ldx	#0
.1c2a	20 21 25	jsr $2521		jsr	floatingpointHandler
.1c2d	aa		tax				tax
.1c2e	20 6d 21	jsr $216d			jsr 	CheckRightParen
.1c31	60		rts				rts
.1c32					UnarySgn:
.1c32	20 c9 1a	jsr $1ac9			jsr 	EvaluateNumeric
.1c35	b0 07		bcs $1c3e			bcs 	_USFloat
.1c37	20 e7 20	jsr $20e7			jsr 	MInt32Sign
.1c3a	20 6d 21	jsr $216d			jsr 	CheckRightParen
.1c3d	60		rts				rts
.1c3e					_USFloat:
.1c3e	8a		txa				txa
.1c3f	a2 0e		ldx #$0e		ldx	#14
.1c41	20 21 25	jsr $2521		jsr	floatingpointHandler
.1c44	aa		tax				tax
.1c45	20 6d 21	jsr $216d			jsr 	CheckRightParen
.1c48	60		rts				rts
.1c49					UnaryPeek:
.1c49	20 75 1c	jsr $1c75			jsr 	PDLCode
.1c4c	4c 69 1c	jmp $1c69			jmp 	PDLByte0
.1c4f					UnaryDeek:
.1c4f	20 75 1c	jsr $1c75			jsr 	PDLCode
.1c52	4c 63 1c	jmp $1c63			jmp 	PDLByte1
.1c55					UnaryLeek:
.1c55	20 75 1c	jsr $1c75			jsr 	PDLCode
.1c58	a0 03		ldy #$03			ldy 	#3
.1c5a	b1 04		lda ($04),y			lda 	(temp0),y
.1c5c	95 60		sta $60,x			sta 	esInt3,x
.1c5e	88		dey				dey
.1c5f	b1 04		lda ($04),y			lda 	(temp0),y
.1c61	95 58		sta $58,x			sta 	esInt2,x
.1c63					PDLByte1:
.1c63	a0 01		ldy #$01			ldy 	#1
.1c65	b1 04		lda ($04),y			lda 	(temp0),y
.1c67	95 50		sta $50,x			sta 	esInt1,x
.1c69					PDLByte0:
.1c69	a0 00		ldy #$00			ldy 	#0
.1c6b	b1 04		lda ($04),y			lda 	(temp0),y
.1c6d	95 48		sta $48,x			sta 	esInt0,x
.1c6f	a4 0c		ldy $0c				ldy 	tempShort 					; restore Y
.1c71	20 6d 21	jsr $216d			jsr 	CheckRightParen 			; check right and return
.1c74	60		rts				rts
.1c75					PDLCode:
.1c75	20 df 1a	jsr $1adf			jsr 	EvaluateInteger
.1c78	b5 48		lda $48,x			lda 	esInt0,x 					; copy address of string to temp0
.1c7a	85 04		sta $04				sta 	temp0
.1c7c	b5 50		lda $50,x			lda 	esInt1,x
.1c7e	85 05		sta $05				sta 	temp0+1
.1c80	a9 00		lda #$00			lda 	#0 							; zero upper 3 bytes of result, type okay.
.1c82	95 50		sta $50,x			sta 	esInt1,x
.1c84	95 58		sta $58,x			sta 	esInt2,x
.1c86	95 60		sta $60,x			sta 	esInt3,x
.1c88	84 0c		sty $0c				sty 	tempShort 					; save Y
.1c8a	60		rts				rts
.1c8b					Unary_Random:
.1c8b	20 2a 21	jsr $212a			jsr 	MInt32Random 				; generate random number.
.1c8e	b1 02		lda ($02),y			lda 	(codePtr),y 				; check followed by )
.1c90	c9 c6		cmp #$c6			cmp 	#TKW_RPAREN
.1c92	f0 08		beq $1c9c			beq 	_URExit
.1c94	e8		inx				inx 								; load range 0..r-1 into +1
.1c95	20 df 1a	jsr $1adf			jsr 	EvaluateInteger
.1c98	ca		dex				dex
.1c99	20 59 1f	jsr $1f59			jsr 	MInt32Modulus 				; calculate random % modulus
.1c9c					_URExit:
.1c9c	20 6d 21	jsr $216d			jsr 	CheckRightParen 			; check right and return
.1c9f	60		rts				rts
.1ca0					Unary_Min:
.1ca0	a9 01		lda #$01			lda 	#1 							; c1 cmp c2 needs to be > e.g. c1 > c2
.1ca2	d0 02		bne $1ca6			bne 	UnaryMBody
.1ca4					Unary_Max:
.1ca4	a9 ff		lda #$ff			lda 	#$FF 						; c1 cmp c2 needs to be < e.g. c1 < c2
.1ca6					UnaryMBody:
.1ca6	48		pha				pha 								; save comparator on stack.
.1ca7	20 c0 1a	jsr $1ac0			jsr 	Evaluate 					; get the first thing to check
.1caa					_UnaryMLoop:
.1caa	b1 02		lda ($02),y			lda 	(codePtr),y 				; found ), indicates end.
.1cac	c8		iny				iny
.1cad	c9 c6		cmp #$c6			cmp 	#TKW_RPAREN
.1caf	f0 09		beq $1cba			beq 	_UnaryMExit
.1cb1	c9 c8		cmp #$c8			cmp 	#TKW_COMMA 					; found , indicates more.
.1cb3	f0 07		beq $1cbc			beq 	_UnaryMCompare
.1cb5	a2 02		ldx #$02			ldx 	#ErrorID_Syntax
.1cb7	20 36 22	jsr $2236		jsr	errorHandler
.1cba					_UnaryMExit:
.1cba	68		pla				pla 								; throw comparator and return.
.1cbb	60		rts				rts
.1cbc					_UnaryMCompare:
.1cbc	e8		inx				inx 								; get the 2nd thing to evaluate
.1cbd	20 c0 1a	jsr $1ac0			jsr 	Evaluate
.1cc0	ca		dex				dex
.1cc1	20 5d 18	jsr $185d			jsr 	PerformComparison 			; this is part of evaluate/compare.asm
.1cc4	85 0c		sta $0c				sta 	tempShort 					; save result
.1cc6	68		pla				pla 								; get what we need
.1cc7	48		pha				pha
.1cc8	c5 0c		cmp $0c				cmp 	tempShort 					; did we get it
.1cca	d0 de		bne $1caa			bne 	_UnaryMLoop 				; no, try another value.
.1ccc	20 fa 20	jsr $20fa			jsr 	MInt32False 				; promote 2nd to 1st.
.1ccf	20 e3 1f	jsr $1fe3			jsr 	MInt32Add
.1cd2	4c aa 1c	jmp $1caa			jmp 	_UnaryMLoop
.1cd5					Unary_Page:
.1cd5	20 fa 20	jsr $20fa			jsr 	MInt32False 				; zero
.1cd8	ad c8 0a	lda $0ac8			lda 	basePage 					; copy base page address in.
.1cdb	95 48		sta $48,x			sta 	esInt0,x
.1cdd	ad c9 0a	lda $0ac9			lda 	basePage+1
.1ce0	95 50		sta $50,x			sta 	esInt1,x
.1ce2	60		rts				rts
.1ce3					UnaryReference:
.1ce3	a9 0f		lda #$0f			lda 	#15
.1ce5	20 ab 19	jsr $19ab			jsr 	EvaluateLevel 				; evaluate term and don't deference.
.1ce8	b5 40		lda $40,x			lda 	esType,x 					; check it's a reference.
.1cea	10 05		bpl $1cf1			bpl 	UType
.1cec	a9 00		lda #$00			lda 	#0 							; make it an integer
.1cee	95 40		sta $40,x			sta 	esType,x
.1cf0	60		rts				rts
.1cf1					UType:
.1cf1	a2 07		ldx #$07			ldx 	#ErrorID_BadType
.1cf3	20 36 22	jsr $2236		jsr	errorHandler
.1cf6					UnaryHexMarker:
.1cf6	4c b1 1a	jmp $1ab1			jmp 	EvaluateIntegerTerm
.1cf9					UnaryComplement:
.1cf9	20 b1 1a	jsr $1ab1			jsr 	EvaluateIntegerTerm
.1cfc	20 ce 20	jsr $20ce			jsr 	MInt32Not
.1cff	60		rts				rts
.1d00					UnaryIntToFloat:
.1d00	20 c9 1a	jsr $1ac9			jsr 	EvaluateNumeric
.1d03	b5 40		lda $40,x			lda 	esType,x
.1d05	d0 0b		bne $1d12			bne 	_UIFExit
.1d07	8a		txa				txa
.1d08	a2 1a		ldx #$1a		ldx	#26
.1d0a	20 21 25	jsr $2521		jsr	floatingpointHandler
.1d0d	aa		tax				tax
.1d0e	a9 01		lda #$01			lda 	#1
.1d10	95 40		sta $40,x			sta 	esType,x
.1d12					_UIFExit:
.1d12	60		rts				rts
.1d13					UnaryFloatToInt:
.1d13	20 c9 1a	jsr $1ac9			jsr 	EvaluateNumeric
.1d16	b5 40		lda $40,x			lda 	esType,x
.1d18	f0 07		beq $1d21			beq 	_UFIExit
.1d1a	8a		txa				txa
.1d1b	a2 12		ldx #$12		ldx	#18
.1d1d	20 21 25	jsr $2521		jsr	floatingpointHandler
.1d20	aa		tax				tax
.1d21					_UFIExit:
.1d21	60		rts				rts
.1d22					UnaryAlloc:
.1d22	e8		inx				inx 								; evaluate memory required
.1d23	20 df 1a	jsr $1adf			jsr 	EvaluateInteger
.1d26	20 6d 21	jsr $216d			jsr 	CheckRightParen
.1d29	ca		dex				dex
.1d2a	b5 59		lda $59,x			lda 	esInt2+1,x 					; check at least in 64k range.
.1d2c	15 61		ora $61,x			ora 	esInt3+1,x
.1d2e	d0 19		bne $1d49			bne 	_UABadValue
.1d30	20 fa 20	jsr $20fa			jsr 	MInt32False					; zero return.
.1d33	a5 10		lda $10				lda 	lowMemory+1 				; copy low memory in
.1d35	95 50		sta $50,x			sta 	esInt1,x
.1d37	a5 0f		lda $0f				lda 	lowMemory
.1d39	95 48		sta $48,x			sta 	esInt0,x
.1d3b	18		clc				clc 								; add alloc required.
.1d3c	75 49		adc $49,x			adc 	esInt0+1,x
.1d3e	85 0f		sta $0f				sta 	lowMemory
.1d40	a5 10		lda $10				lda 	lowMemory+1
.1d42	75 51		adc $51,x			adc 	esInt1+1,x
.1d44	85 10		sta $10				sta 	lowMemory+1
.1d46	b0 01		bcs $1d49			bcs		_UABadValue 				; overflow definitely bad.
.1d48	60		rts				rts
.1d49					_UABadValue:
.1d49	a2 08		ldx #$08			ldx 	#ErrorID_BadValue
.1d4b	20 36 22	jsr $2236		jsr	errorHandler

;******  Return to file: main/main.asm


;******  Processing file: main/evaluate/unary2.asm

.1d4e					UnaryTimer:
.1d4e	20 6d 21	jsr $216d			jsr 	CheckRightParen
.1d51	98		tya				tya
.1d52	48		pha				pha
.1d53	20 21 21	jsr $2121			jsr 	MInt32Zero 					; zero result
.1d56	86 04		stx $04				stx 	temp0 						; returning in YA so can't use .pshx
.1d58	a2 0a		ldx #$0a		ldx	#10
.1d5a	20 27 22	jsr $2227		jsr	deviceHandler
.1d5d	a6 04		ldx $04				ldx 	temp0						; restore X and update 16 bit result
.1d5f	95 48		sta $48,x			sta 	esInt0,x
.1d61	98		tya				tya
.1d62	95 50		sta $50,x			sta 	esInt1,x
.1d64	68		pla				pla
.1d65	a8		tay				tay
.1d66	60		rts				rts
.1d67					UnaryInkey:
.1d67	20 6d 21	jsr $216d			jsr 	CheckRightParen
.1d6a	86 04		stx $04				stx 	temp0
.1d6c	a2 04		ldx #$04		ldx	#4
.1d6e	20 27 22	jsr $2227		jsr	deviceHandler
.1d71	a6 04		ldx $04				ldx 	temp0
.1d73	20 09 21	jsr $2109			jsr 	MInt32Set8Bit
.1d76	60		rts				rts
.1d77					UnaryGet:
.1d77	20 6d 21	jsr $216d			jsr 	CheckRightParen
.1d7a	86 04		stx $04				stx 	temp0
.1d7c					_UGLoop:
.1d7c	a2 04		ldx #$04		ldx	#4
.1d7e	20 27 22	jsr $2227		jsr	deviceHandler
.1d81	c9 00		cmp #$00			cmp 	#0
.1d83	f0 f7		beq $1d7c			beq 	_UGLoop
.1d85	a6 04		ldx $04				ldx 	temp0
.1d87	20 09 21	jsr $2109			jsr 	MInt32Set8Bit
.1d8a	60		rts				rts
.1d8b					UnarySys:
.1d8b	20 df 1a	jsr $1adf			jsr 	EvaluateInteger 				; get the address
.1d8e	20 6d 21	jsr $216d			jsr 	CheckRightParen
.1d91	20 3c 11	jsr $113c			jsr 	TOSToTemp0 						; copy to temp0
.1d94	8a		txa				txa
.1d95	48		pha				pha
.1d96	98		tya				tya
.1d97	48		pha				pha
.1d98	ad 00 0a	lda $0a00			lda 	("A"-"A")*4+SingleLetterVar 	; load AXY
.1d9b	ae 5c 0a	ldx $0a5c			ldx 	("X"-"A")*4+SingleLetterVar
.1d9e	ac 60 0a	ldy $0a60			ldy 	("Y"-"A")*4+SingleLetterVar
.1da1	20 b0 1d	jsr $1db0			jsr 	_CallTemp0
.1da4	85 0c		sta $0c				sta 	tempShort 						; restore YX
.1da6	68		pla				pla
.1da7	a8		tay				tay
.1da8	68		pla				pla
.1da9	aa		tax				tax
.1daa	a5 0c		lda $0c				lda 	tempShort
.1dac	20 09 21	jsr $2109			jsr 	MInt32Set8Bit 					; return result.
.1daf	60		rts				rts
.1db0					_CallTemp0:
.1db0	6c 04 00	jmp ($0004)			jmp 	(temp0)

;******  Return to file: main/main.asm


;******  Processing file: main/evaluate/unarystr.asm

.1db3					ExecChr:
.1db3	20 e7 1a	jsr $1ae7			jsr 	EvaluateSmallInteger		; character number
.1db6	20 6d 21	jsr $216d			jsr 	CheckRightParen				; right bracket
.1db9	98		tya				tya
.1dba	48		pha				pha
.1dbb	8a		txa				txa 								; A = stack
.1dbc	b4 48		ldy $48,x			ldy 	esInt0,x					; Y = character
.1dbe	a2 00		ldx #$00		ldx	#0
.1dc0	20 bd 27	jsr $27bd		jsr	stringHandler
.1dc3	aa		tax				tax 								; X = stack
.1dc4	68		pla				pla
.1dc5	a8		tay				tay
.1dc6	60		rts				rts
.1dc7					ExecLower:
.1dc7	38		sec				sec
.1dc8	b0 01		bcs $1dcb			bcs 	ExecUpperLower
.1dca					ExecUpper:
.1dca	18		clc				clc
.1dcb					ExecUpperLower:
.1dcb	08		php				php 								; save carry
.1dcc	20 d4 1a	jsr $1ad4			jsr 	EvaluateString 				; string to stack,X
.1dcf	20 6d 21	jsr $216d			jsr 	CheckRightParen 			; check closing right bracket.
.1dd2	28		plp				plp 								; restore carry, save Y
.1dd3	98		tya				tya
.1dd4	48		pha				pha
.1dd5	a9 00		lda #$00			lda 	#0 							; A zero if upper, 1 if lower.
.1dd7	2a		rol a				rol 	a
.1dd8	a8		tay				tay 								; now in Y
.1dd9	8a		txa				txa 								; do the substring and exit.
.1dda	a2 08		ldx #$08		ldx	#8
.1ddc	20 bd 27	jsr $27bd		jsr	stringHandler
.1ddf	aa		tax				tax
.1de0	68		pla				pla
.1de1	a8		tay				tay
.1de2	60		rts				rts
.1de3					ExecLeft:
.1de3	20 d4 1a	jsr $1ad4			jsr 	EvaluateString 				; string to stack,X
.1de6	20 7a 21	jsr $217a			jsr 	CheckComma
.1de9	e8		inx				inx
.1dea	a9 01		lda #$01			lda 	#1 							; 1 for 2nd parameter.
.1dec	20 09 21	jsr $2109			jsr 	MInt32Set8Bit
.1def	e8		inx				inx
.1df0	20 e7 1a	jsr $1ae7			jsr 	EvaluateSmallInteger 		; smallint 3rd parameter
.1df3					ExecSubstring:
.1df3	ca		dex				dex 								; fix up X
.1df4	ca		dex				dex
.1df5	20 6d 21	jsr $216d			jsr 	CheckRightParen 			; check closing right bracket.
.1df8	8a		txa				txa 								; do the substring and exit.
.1df9	a2 0a		ldx #$0a		ldx	#10
.1dfb	20 bd 27	jsr $27bd		jsr	stringHandler
.1dfe	aa		tax				tax
.1dff	60		rts				rts
.1e00					ExecMid:
.1e00	20 d4 1a	jsr $1ad4			jsr 	EvaluateString 				; string to stack,X
.1e03	20 7a 21	jsr $217a			jsr 	CheckComma
.1e06	e8		inx				inx
.1e07	20 e7 1a	jsr $1ae7			jsr 	EvaluateSmallInteger 		; smallint 2nd parameter
.1e0a	c9 00		cmp #$00			cmp 	#0
.1e0c	f0 15		beq $1e23			beq 	_EMValue
.1e0e	e8		inx				inx
.1e0f	a9 ff		lda #$ff			lda 	#255 						; 255 default for 3nd parameter.
.1e11	20 09 21	jsr $2109			jsr 	MInt32Set8Bit
.1e14	b1 02		lda ($02),y			lda 	(codePtr),y 				; is there a ) next
.1e16	c9 c6		cmp #$c6			cmp 	#TKW_RPAREN 				; if so, just MID$(a$,2)
.1e18	f0 d9		beq $1df3			beq 	ExecSubString
.1e1a	20 7a 21	jsr $217a			jsr 	CheckComma
.1e1d	20 e7 1a	jsr $1ae7			jsr 	EvaluateSmallInteger 		; smallint 2nd parameter
.1e20	4c f3 1d	jmp $1df3			jmp 	ExecSubString
.1e23					_EMValue:
.1e23	a2 08		ldx #$08			ldx 	#ErrorID_BadValue
.1e25	20 36 22	jsr $2236		jsr	errorHandler
.1e28					ExecRight:
.1e28	20 d4 1a	jsr $1ad4			jsr 	EvaluateString 				; string to stack,X
.1e2b	20 7a 21	jsr $217a			jsr 	CheckComma
.1e2e	e8		inx				inx
.1e2f	20 e7 1a	jsr $1ae7			jsr 	EvaluateSmallInteger 		; smallint 2nd parameter.
.1e32	ca		dex				dex
.1e33	98		tya				tya
.1e34	48		pha				pha
.1e35	b5 48		lda $48,x			lda 	esInt0,x 					; copy address of string to temp0
.1e37	85 04		sta $04				sta 	temp0
.1e39	b5 50		lda $50,x			lda 	esInt1,x
.1e3b	85 05		sta $05				sta 	temp0+1
.1e3d	a0 00		ldy #$00			ldy 	#0 							; point to length
.1e3f	b1 04		lda ($04),y			lda 	(temp0),y 					; get the length.
.1e41	18		clc				clc 								; add 1.
.1e42	69 01		adc #$01			adc 	#1
.1e44	38		sec				sec
.1e45	f5 49		sbc $49,x			sbc 	esInt0+1,x  				; subtract right count.
.1e47	f0 02		beq $1e4b			beq		_ERMake1 					; if zero, make it 1.
.1e49	b0 02		bcs $1e4d			bcs		_EROkay
.1e4b					_ERMake1:
.1e4b	a9 01		lda #$01			lda 	#1 							; start position.
.1e4d					_EROkay:
.1e4d	e8		inx				inx 								; set start pos.
.1e4e	95 48		sta $48,x			sta 	esInt0,x
.1e50	e8		inx				inx
.1e51	a9 ff		lda #$ff			lda 	#255 						; 255 default for 3nd parameter.
.1e53	20 09 21	jsr $2109			jsr 	MInt32Set8Bit
.1e56	68		pla				pla
.1e57	a8		tay				tay
.1e58	4c f3 1d	jmp $1df3			jmp 	ExecSubString 				; do the substring code.

;******  Return to file: main/main.asm


;******  Processing file: main/imath/int32binary.asm

.1e5b					MInt32And:
.1e5b	b5 48		lda $48,x			lda 	esInt0,x
.1e5d	35 49		and $49,x			and 	esInt0+1,x
.1e5f	95 48		sta $48,x			sta 	esInt0,x
.1e61	b5 50		lda $50,x			lda 	esInt1,x
.1e63	35 51		and $51,x			and 	esInt1+1,x
.1e65	95 50		sta $50,x			sta 	esInt1,x
.1e67	b5 58		lda $58,x			lda 	esInt2,x
.1e69	35 59		and $59,x			and 	esInt2+1,x
.1e6b	95 58		sta $58,x			sta 	esInt2,x
.1e6d	b5 60		lda $60,x			lda 	esInt3,x
.1e6f	35 61		and $61,x			and 	esInt3+1,x
.1e71	95 60		sta $60,x			sta 	esInt3,x
.1e73	60		rts				rts
.1e74					MInt32Or:
.1e74	b5 48		lda $48,x			lda 	esInt0,x
.1e76	15 49		ora $49,x			ora 	esInt0+1,x
.1e78	95 48		sta $48,x			sta 	esInt0,x
.1e7a	b5 50		lda $50,x			lda 	esInt1,x
.1e7c	15 51		ora $51,x			ora 	esInt1+1,x
.1e7e	95 50		sta $50,x			sta 	esInt1,x
.1e80	b5 58		lda $58,x			lda 	esInt2,x
.1e82	15 59		ora $59,x			ora 	esInt2+1,x
.1e84	95 58		sta $58,x			sta 	esInt2,x
.1e86	b5 60		lda $60,x			lda 	esInt3,x
.1e88	15 61		ora $61,x			ora 	esInt3+1,x
.1e8a	95 60		sta $60,x			sta 	esInt3,x
.1e8c	60		rts				rts
.1e8d					MInt32Xor:
.1e8d	b5 48		lda $48,x			lda 	esInt0,x
.1e8f	55 49		eor $49,x			eor 	esInt0+1,x
.1e91	95 48		sta $48,x			sta 	esInt0,x
.1e93	b5 50		lda $50,x			lda 	esInt1,x
.1e95	55 51		eor $51,x			eor 	esInt1+1,x
.1e97	95 50		sta $50,x			sta 	esInt1,x
.1e99	b5 58		lda $58,x			lda 	esInt2,x
.1e9b	55 59		eor $59,x			eor 	esInt2+1,x
.1e9d	95 58		sta $58,x			sta 	esInt2,x
.1e9f	b5 60		lda $60,x			lda 	esInt3,x
.1ea1	55 61		eor $61,x			eor 	esInt3+1,x
.1ea3	95 60		sta $60,x			sta 	esInt3,x
.1ea5	60		rts				rts

;******  Return to file: main/main.asm


;******  Processing file: main/imath/int32compare.asm

.1ea6					MInt32Compare:
.1ea6	b5 48		lda $48,x			lda 	esInt0,x 					; equality check.
.1ea8	d5 49		cmp $49,x			cmp 	esInt0+1,x
.1eaa	d0 13		bne $1ebf			bne 	MInt32Compare2
.1eac	b5 50		lda $50,x			lda 	esInt1,x
.1eae	d5 51		cmp $51,x			cmp 	esInt1+1,x
.1eb0	d0 0d		bne $1ebf			bne 	MInt32Compare2
.1eb2	b5 58		lda $58,x			lda 	esInt2,x
.1eb4	d5 59		cmp $59,x			cmp 	esInt2+1,x
.1eb6	d0 07		bne $1ebf			bne 	MInt32Compare2
.1eb8	b5 60		lda $60,x			lda 	esInt3,x
.1eba	55 61		eor $61,x			eor 	esInt3+1,x 					; will return 0 if the same.
.1ebc	d0 01		bne $1ebf			bne 	MInt32Compare2
.1ebe	60		rts				rts
.1ebf					MInt32Compare2:
.1ebf	b5 48		lda $48,x			lda		esInt0,x 					; unsigned 32 bit comparison.
.1ec1	d5 49		cmp $49,x			cmp 	esInt0+1,x
.1ec3	b5 50		lda $50,x			lda		esInt1,x
.1ec5	f5 51		sbc $51,x			sbc 	esInt1+1,x
.1ec7	b5 58		lda $58,x			lda		esInt2,x
.1ec9	f5 59		sbc $59,x			sbc 	esInt2+1,x
.1ecb	b5 60		lda $60,x			lda		esInt3,x
.1ecd	f5 61		sbc $61,x			sbc 	esInt3+1,x
.1ecf	50 02		bvc $1ed3			bvc 	_I32LNoOverflow 			; make it signed 32 bi comparison
.1ed1	49 80		eor #$80			eor 	#$80
.1ed3					_I32LNoOverflow
.1ed3	30 03		bmi $1ed8			bmi 	MInt32CLess					; if -ve then return $FF
.1ed5	a9 01		lda #$01			lda 	#$01						; else return $01
.1ed7	60		rts				rts
.1ed8					MInt32CLess:
.1ed8	a9 ff		lda #$ff			lda 	#$FF
.1eda	60		rts				rts

;******  Return to file: main/main.asm


;******  Processing file: main/imath/int32divide.asm

.1edb					MInt32SDivide:
.1edb	98		tya				tya  								; save Y, which is the count of negations
.1edc	48		pha				pha
.1edd	a0 00		ldy #$00			ldy 	#0 							; zero count
.1edf	20 f7 1e	jsr $1ef7			jsr 	_MInt32SRemSign 			; unsign TOS
.1ee2	e8		inx				inx 								; unsign TOS+1
.1ee3	20 f7 1e	jsr $1ef7			jsr 	_MInt32SRemSign
.1ee6	ca		dex				dex
.1ee7	98		tya				tya 								; save sign count on stack
.1ee8	48		pha				pha
.1ee9	20 00 1f	jsr $1f00			jsr 	MInt32UDivide 				; unsigned division
.1eec	68		pla				pla 								; get sign count back
.1eed	29 01		and #$01			and 	#1 							; if it is odd, then negate result
.1eef	f0 03		beq $1ef4			beq 	_I32SNoNeg
.1ef1	20 b4 20	jsr $20b4			jsr 	MInt32Negate
.1ef4					_I32SNoNeg:
.1ef4	68		pla				pla 								; restoe Y and exit
.1ef5	a8		tay				tay
.1ef6	60		rts				rts
.1ef7					_MInt32SRemSign:
.1ef7	b5 60		lda $60,x			lda 	esInt3,x 					; is it -ve
.1ef9	10 04		bpl $1eff			bpl 	_MInt32SRSExit
.1efb	c8		iny				iny 								; increment the sign count
.1efc	20 b4 20	jsr $20b4			jsr 	MInt32Negate 				; negate the value.
.1eff					_MInt32SRSExit:
.1eff	60		rts				rts
.1f00					MInt32UDivide:
.1f00	b5 49		lda $49,x			lda 	esInt0+1,x 					; check for division by zero
.1f02	15 51		ora $51,x			ora 	esInt1+1,x
.1f04	15 52		ora $52,x			ora 	esInt1+2,x
.1f06	15 53		ora $53,x			ora 	esInt1+3,x
.1f08	f0 4a		beq $1f54			beq 	_MInt32DZero
.1f0a	e8		inx				inx 								; clear A
.1f0b	e8		inx				inx
.1f0c	20 fa 20	jsr $20fa			jsr 	MInt32False
.1f0f	ca		dex				dex
.1f10	ca		dex				dex
.1f11	98		tya				tya 								; save Y on the stack
.1f12	48		pha				pha
.1f13	a0 20		ldy #$20			ldy 	#32 						; number of division passes
.1f15					_MInt32UDLoop:
.1f15	16 48		asl $48,x			asl 	esInt0,x					; shift QA left. First Q
.1f17	36 50		rol $50,x			rol 	esInt1,x
.1f19	36 58		rol $58,x			rol 	esInt2,x
.1f1b	36 60		rol $60,x			rol 	esInt3,x
.1f1d	36 4a		rol $4a,x			rol 	esInt0+2,x 					; then A.
.1f1f	36 52		rol $52,x			rol 	esInt1+2,x
.1f21	36 5a		rol $5a,x			rol 	esInt2+2,x
.1f23	36 62		rol $62,x			rol 	esInt3+2,x
.1f25	38		sec				sec 								; calculate A-M saving result on the stack
.1f26	b5 4a		lda $4a,x			lda 	esInt0+2,x
.1f28	f5 49		sbc $49,x			sbc 	esInt0+1,x
.1f2a	48		pha				pha
.1f2b	b5 52		lda $52,x			lda 	esInt1+2,x
.1f2d	f5 51		sbc $51,x			sbc 	esInt1+1,x
.1f2f	48		pha				pha
.1f30	b5 5a		lda $5a,x			lda 	esInt2+2,x
.1f32	f5 59		sbc $59,x			sbc 	esInt2+1,x
.1f34	48		pha				pha
.1f35	b5 62		lda $62,x			lda 	esInt3+2,x
.1f37	f5 61		sbc $61,x			sbc 	esInt3+1,x
.1f39	90 10		bcc $1f4b			bcc		_MInt32NoSubtract 			; if A < M (e.g. carry clear) then reject this.
.1f3b	95 62		sta $62,x			sta 	esInt3+2,x 					; write result back to A
.1f3d	68		pla				pla
.1f3e	95 5a		sta $5a,x			sta 	esInt2+2,x
.1f40	68		pla				pla
.1f41	95 52		sta $52,x			sta 	esInt1+2,x
.1f43	68		pla				pla
.1f44	95 4a		sta $4a,x			sta 	esInt0+2,x
.1f46	f6 48		inc $48,x			inc 	esInt0,x 					; sets bit 0 of Q - it was shifted left previously.
.1f48	4c 4e 1f	jmp $1f4e			jmp 	_MInt32Next 					; do the next iteration
.1f4b					_MInt32NoSubtract:
.1f4b	68		pla				pla
.1f4c	68		pla				pla
.1f4d	68		pla				pla
.1f4e					_MInt32Next:
.1f4e	88		dey				dey 								; do this 32 times.
.1f4f	d0 c4		bne $1f15			bne 	_MInt32UDLoop
.1f51	68		pla				pla 								; restore Y and exit
.1f52	a8		tay				tay
.1f53	60		rts				rts
.1f54					_MInt32DZero:
.1f54	a2 05		ldx #$05			ldx 	#ErrorID_DivZero
.1f56	20 36 22	jsr $2236		jsr	errorHandler
.1f59					MInt32Modulus:
.1f59	20 00 1f	jsr $1f00			jsr 	MInt32UDivide 				; do the division.
.1f5c	b5 62		lda $62,x			lda 	esInt3+2,x 					; copy 2nd on stack (the remainder) to the top.
.1f5e	95 60		sta $60,x			sta 	esInt3,x
.1f60	b5 5a		lda $5a,x			lda 	esInt2+2,x
.1f62	95 58		sta $58,x			sta 	esInt2,x
.1f64	b5 52		lda $52,x			lda 	esInt1+2,x
.1f66	95 50		sta $50,x			sta 	esInt1,x
.1f68	b5 4a		lda $4a,x			lda 	esInt0+2,x
.1f6a	95 48		sta $48,x			sta 	esInt0,x
.1f6c	60		rts				rts

;******  Return to file: main/main.asm


;******  Processing file: main/imath/int32fromstr.asm

.0af9					fs32Length:
>0af9							.fill 	1
.1f6d					MInt32FromString:
.1f6d	85 0c		sta $0c				sta 	tempShort 					; save base
.1f6f	98		tya				tya
.1f70	48		pha				pha
.1f71	a0 00		ldy #$00			ldy 	#0 							; get length
.1f73	b1 04		lda ($04),y			lda 	(temp0),y
.1f75	8d f9 0a	sta $0af9			sta 	fs32Length
.1f78	f0 65		beq $1fdf			beq 	_I32FSFail2					; fail if length zero.
.1f7a	a0 01		ldy #$01			ldy 	#1 							; set index into string being read
.1f7c	b1 04		lda ($04),y			lda 	(temp0),y 					; look at first character
.1f7e	c9 2d		cmp #$2d			cmp 	#"-"						; is it a - character
.1f80	d0 09		bne $1f8b			bne 	_I32FSNotNegative
.1f82	ad f9 0a	lda $0af9			lda 	fs32Length 					; get length back.
.1f85	c9 01		cmp #$01			cmp 	#1 							; if 1 it is just a '-; so fail.'
.1f87	f0 56		beq $1fdf			beq 	_I32FSFail2
.1f89	a0 02		ldy #$02			ldy 	#2 							; first digit of the number.
.1f8b					_I32FSNotNegative:
.1f8b	a5 0c		lda $0c				lda 	tempShort 					; get the base back.
.1f8d	c0 02		cpy #$02			cpy 	#2 							; if we read a -ve (e.g. Y == 2)
.1f8f	d0 02		bne $1f93			bne 	_I32FSNN2
.1f91	09 80		ora #$80			ora 	#$80						; set bit 7, this indicates a negated result.
.1f93					_I32FSNN2:
.1f93	48		pha				pha 								; save base + final sign on stack.
.1f94	20 fa 20	jsr $20fa			jsr 	MInt32False 				; zero the return value.
.1f97					_I32FSMainLoop:
.1f97	68		pla				pla 								; get the base back into tempShort
.1f98	48		pha				pha
.1f99	29 7f		and #$7f			and 	#$7F
.1f9b	85 0c		sta $0c				sta 	tempShort
.1f9d	b1 04		lda ($04),y			lda 	(temp0),y 					; look at next character.
.1f9f	c9 61		cmp #$61			cmp 	#"a" 						; fix up case.
.1fa1	90 02		bcc $1fa5			bcc 	_I32FSNotLC
.1fa3	e9 20		sbc #$20			sbc 	#32
.1fa5					_I32FSNotLC:
.1fa5	38		sec				sec 								; subtract 48 (ASCII "0")
.1fa6	e9 30		sbc #$30			sbc 	#"0"
.1fa8	90 34		bcc $1fde			bcc 	_I32FSFail 					; nothing more to do.
.1faa	c9 0a		cmp #$0a			cmp 	#9+1 						; if it is 0-9 validate vs base.
.1fac	90 06		bcc $1fb4			bcc 	_I32FSValidate
.1fae	c9 11		cmp #$11			cmp 	#17 						; is it between 58 and 64 ? if so bad.
.1fb0	90 2c		bcc $1fde			bcc 	_I32FSFail
.1fb2	e9 07		sbc #$07			sbc 	#7 							; adjust into range so now character is 0->nnn
.1fb4					_I32FSValidate:
.1fb4	c5 0c		cmp $0c				cmp 	tempShort 					; compare against the base.
.1fb6	b0 26		bcs $1fde			bcs 	_I32FSFail 					; sorry, too large for this base.
.1fb8	48		pha				pha 								; save the new digit value.
.1fb9	e8		inx				inx 								; put base into next slot.
.1fba	a5 0c		lda $0c				lda 	tempShort
.1fbc	20 09 21	jsr $2109			jsr 	MInt32Set8Bit
.1fbf	ca		dex				dex
.1fc0	20 17 20	jsr $2017			jsr 	MInt32Multiply 				; multiply current by the base
.1fc3	e8		inx				inx
.1fc4	68		pla				pla  								; put additive into next slot
.1fc5	20 09 21	jsr $2109			jsr 	MInt32Set8Bit
.1fc8	ca		dex				dex
.1fc9	20 e3 1f	jsr $1fe3			jsr 	MInt32Add 					; and add it
.1fcc	c8		iny				iny 								; look at next character
.1fcd	cc f9 0a	cpy $0af9			cpy 	fs32Length 					; until > length.
.1fd0	f0 c5		beq $1f97			beq 	_I32FSMainLoop
.1fd2	90 c3		bcc $1f97			bcc 	_I32FSMainLoop
.1fd4					_I32FSDone:
.1fd4	68		pla				pla 								; get base/final sign back
.1fd5	10 03		bpl $1fda			bpl 	_I32FSNN3
.1fd7	20 b4 20	jsr $20b4			jsr 	MInt32Negate 				; negate the result.
.1fda					_I32FSNN3:
.1fda	68		pla				pla
.1fdb	a8		tay				tay
.1fdc	38		sec				sec
.1fdd	60		rts				rts
.1fde					_I32FSFail:
.1fde	68		pla				pla
.1fdf					_I32FSFail2:
.1fdf	68		pla				pla
.1fe0	a8		tay				tay
.1fe1	18		clc				clc
.1fe2	60		rts				rts

;******  Return to file: main/main.asm


;******  Processing file: main/imath/int32math.asm

.1fe3					MInt32Add:
.1fe3	18		clc				clc
.1fe4	b5 48		lda $48,x			lda 	esInt0,x
.1fe6	75 49		adc $49,x			adc 	esInt0+1,x
.1fe8	95 48		sta $48,x			sta 	esInt0,x
.1fea	b5 50		lda $50,x			lda 	esInt1,x
.1fec	75 51		adc $51,x			adc 	esInt1+1,x
.1fee	95 50		sta $50,x			sta 	esInt1,x
.1ff0	b5 58		lda $58,x			lda 	esInt2,x
.1ff2	75 59		adc $59,x			adc 	esInt2+1,x
.1ff4	95 58		sta $58,x			sta 	esInt2,x
.1ff6	b5 60		lda $60,x			lda 	esInt3,x
.1ff8	75 61		adc $61,x			adc 	esInt3+1,x
.1ffa	95 60		sta $60,x			sta 	esInt3,x
.1ffc	60		rts				rts
.1ffd					MInt32Sub:
.1ffd	38		sec				sec
.1ffe	b5 48		lda $48,x			lda 	esInt0,x
.2000	f5 49		sbc $49,x			sbc 	esInt0+1,x
.2002	95 48		sta $48,x			sta 	esInt0,x
.2004	b5 50		lda $50,x			lda 	esInt1,x
.2006	f5 51		sbc $51,x			sbc 	esInt1+1,x
.2008	95 50		sta $50,x			sta 	esInt1,x
.200a	b5 58		lda $58,x			lda 	esInt2,x
.200c	f5 59		sbc $59,x			sbc 	esInt2+1,x
.200e	95 58		sta $58,x			sta 	esInt2,x
.2010	b5 60		lda $60,x			lda 	esInt3,x
.2012	f5 61		sbc $61,x			sbc 	esInt3+1,x
.2014	95 60		sta $60,x			sta 	esInt3,x
.2016	60		rts				rts

;******  Return to file: main/main.asm


;******  Processing file: main/imath/int32multiply.asm

.2017					MInt32Multiply:
.2017	e8		inx				inx 								; copy 2nd -> 3rd
.2018	20 3d 20	jsr $203d			jsr 	MInt32CopyUp
.201b	ca		dex				dex
.201c	20 3d 20	jsr $203d			jsr 	MInt32CopyUp 				; copy 1st -> 2nd
.201f	20 fa 20	jsr $20fa			jsr 	MInt32False 					; zero 1st.
.2022					_I32Loop:
.2022	b5 4a		lda $4a,x			lda 	esInt0+2,x 					; get low bit of 3rd
.2024	29 01		and #$01			and 	#1
.2026	f0 03		beq $202b			beq 	_I32NoAdd 					; if set
.2028	20 e3 1f	jsr $1fe3			jsr 	MInt32Add 					; add 2nd to 1st.
.202b					_I32NoAdd:
.202b	e8		inx				inx 								; shift 2nd left
.202c	20 0f 21	jsr $210f			jsr 	MInt32ShiftLeft
.202f	e8		inx				inx  								; shift 3rd right
.2030	20 18 21	jsr $2118			jsr 	MInt32ShiftRight
.2033	20 21 21	jsr $2121			jsr 	MInt32Zero 					; check if zero.
.2036	08		php				php 								; save status bits
.2037	ca		dex				dex 	 							; point back to 1st
.2038	ca		dex				dex
.2039	28		plp				plp 								; get status bits
.203a	d0 e6		bne $2022			bne 	_I32Loop 					; if non-zero keep going.
.203c	60		rts				rts
.203d					MInt32CopyUp:
.203d	b5 48		lda $48,x			lda 	esInt0,x
.203f	95 49		sta $49,x			sta 	esInt0+1,x
.2041	b5 50		lda $50,x			lda 	esInt1,x
.2043	95 51		sta $51,x			sta 	esInt1+1,x
.2045	b5 58		lda $58,x			lda 	esInt2,x
.2047	95 59		sta $59,x			sta 	esInt2+1,x
.2049	b5 60		lda $60,x			lda 	esInt3,x
.204b	95 61		sta $61,x			sta 	esInt3+1,x
.204d	60		rts				rts

;******  Return to file: main/main.asm


;******  Processing file: main/imath/int32tostr.asm

>0afa					MCharCount:	.fill 	1						; count of converted characters
.204e					MLInt32ToString:
.204e	aa		tax				tax									; module passes stack in A, base in Y
.204f	98		tya				tya
.2050					MInt32ToString:
.2050	48		pha				pha 								; save base
.2051	85 0c		sta $0c				sta 	tempShort 					; save target base.
.2053	a9 00		lda #$00			lda 	#0
.2055	8d fa 0a	sta $0afa			sta 	MCharCount 					; clear character count to 0
.2058	98		tya				tya
.2059	48		pha				pha
.205a	a5 0c		lda $0c				lda 	tempShort 					; check if we are signed conversion
.205c	10 10		bpl $206e			bpl 	_I32TSUnsigned
.205e	48		pha				pha 								; save base on stack.
.205f	b5 60		lda $60,x			lda 	esInt3,x 					; is it actually negative
.2061	10 08		bpl $206b			bpl 	_I32TSNoFlip
.2063	a9 2d		lda #$2d			lda 	#"-" 						; write a '-' prefix out.
.2065	20 a1 20	jsr $20a1			jsr 	MI32WriteCharacter
.2068	20 b4 20	jsr $20b4			jsr 	MInt32Negate 				; negate the value.
.206b					_I32TSNoFlip:
.206b	68		pla				pla 								; get the base back
.206c	29 7f		and #$7f			and 	#$7F 						; clear the sign flag so it's just a base now.
.206e					_I32TSUnsigned:
.206e	20 7c 20	jsr $207c			jsr 	MI32DivideWrite 			; recursive code to output string.
.2071	a0 00		ldy #$00			ldy 	#0 							; write charcount to first character.
.2073	ad fa 0a	lda $0afa			lda 	MCharCount
.2076	91 04		sta ($04),y			sta 	(temp0),y
.2078	68		pla				pla
.2079	a8		tay				tay
.207a	68		pla				pla
.207b	60		rts				rts
.207c					MI32DivideWrite:
.207c	48		pha				pha 								; save the divisor/base
.207d	e8		inx				inx 								; write in the dividing position.
.207e	20 09 21	jsr $2109			jsr 	MInt32Set8Bit
.2081	ca		dex				dex
.2082	20 00 1f	jsr $1f00			jsr 	MInt32UDivide 				; divide number by base.
.2085	68		pla				pla 								; get the base into Y
.2086	a8		tay				tay
.2087	b5 4a		lda $4a,x			lda 	esInt0+2,x 					; get the remainder and push on the stack.
.2089	48		pha				pha
.208a	20 21 21	jsr $2121			jsr 	MInt32Zero 					; is the result zero ?
.208d	f0 04		beq $2093			beq 	_I32NoRecurse 				; if so, don't recurse.
.208f	98		tya				tya 								; put base into A
.2090	20 7c 20	jsr $207c			jsr 	MI32DivideWrite 				; and jsr the dividor recursively.
.2093					_I32NoRecurse:
.2093	68		pla				pla 								; get the remainder back
.2094	c9 0a		cmp #$0a			cmp 	#10  						; handle hexadecimals.
.2096	90 02		bcc $209a			bcc 	_I32NotHex
.2098	69 06		adc #$06			adc 	#7-1
.209a					_I32NotHex:
.209a	18		clc				clc 								; make it ASCII
.209b	69 30		adc #$30			adc 	#48
.209d	20 a1 20	jsr $20a1			jsr 	MI32WriteCharacter 			; write the character out
.20a0	60		rts				rts 								; and exit.
.20a1					MI32WriteCharacter:
.20a1	ee fa 0a	inc $0afa			inc 	MCharCount 					; bump count (space for leading count)
.20a4	ac fa 0a	ldy $0afa			ldy 	MCharCount 					; get position
.20a7	91 04		sta ($04),y			sta 	(temp0),y 					; write out with trailing 0
.20a9	c8		iny				iny
.20aa	a9 00		lda #$00			lda 	#0
.20ac	91 04		sta ($04),y			sta 	(temp0),y
.20ae	60		rts				rts

;******  Return to file: main/main.asm


;******  Processing file: main/imath/int32unary.asm

>0afb					MSeed32:	.fill 	4							; random number seed.
.20af					MInt32Absolute:
.20af	b5 60		lda $60,x			lda 	esInt3,x 					; use negate code if -ve.
.20b1	30 01		bmi $20b4			bmi 	MInt32Negate
.20b3	60		rts				rts
.20b4					MInt32Negate:
.20b4	38		sec				sec
.20b5	a9 00		lda #$00			lda 	#0
.20b7	f5 48		sbc $48,x			sbc 	esInt0,x
.20b9	95 48		sta $48,x			sta 	esInt0,x
.20bb	a9 00		lda #$00			lda 	#0
.20bd	f5 50		sbc $50,x			sbc 	esInt1,x
.20bf	95 50		sta $50,x			sta 	esInt1,x
.20c1	a9 00		lda #$00			lda 	#0
.20c3	f5 58		sbc $58,x			sbc 	esInt2,x
.20c5	95 58		sta $58,x			sta 	esInt2,x
.20c7	a9 00		lda #$00			lda 	#0
.20c9	f5 60		sbc $60,x			sbc 	esInt3,x
.20cb	95 60		sta $60,x			sta 	esInt3,x
.20cd	60		rts				rts
.20ce					MInt32Not:
.20ce	b5 48		lda $48,x			lda 	esInt0,x
.20d0	49 ff		eor #$ff			eor 	#$FF
.20d2	95 48		sta $48,x			sta 	esInt0,x
.20d4	b5 50		lda $50,x			lda 	esInt1,x
.20d6	49 ff		eor #$ff			eor 	#$FF
.20d8	95 50		sta $50,x			sta 	esInt1,x
.20da	b5 58		lda $58,x			lda 	esInt2,x
.20dc	49 ff		eor #$ff			eor 	#$FF
.20de	95 58		sta $58,x			sta 	esInt2,x
.20e0	b5 60		lda $60,x			lda 	esInt3,x
.20e2	49 ff		eor #$ff			eor 	#$FF
.20e4	95 60		sta $60,x			sta 	esInt3,x
.20e6	60		rts				rts
.20e7					MInt32Sign:
.20e7	b5 60		lda $60,x			lda 	esInt3,x					; look at MSB
.20e9	30 0b		bmi $20f6			bmi 	MInt32True 					; if set return -1 (true)
.20eb	20 21 21	jsr $2121			jsr 	MInt32Zero 					; is it zero ?
.20ee	f0 0a		beq $20fa			beq 	MInt32False 					; if zero return 0 (false)
.20f0	20 fa 20	jsr $20fa			jsr 	MInt32False 					; > 0 return 1
.20f3	f6 48		inc $48,x			inc 	esInt0,x
.20f5	60		rts				rts
.20f6					MInt32True:
.20f6	a9 ff		lda #$ff			lda 	#$FF 						; set to $FFFFFFFF
.20f8	d0 02		bne $20fc			bne 	MInt32WriteAll
.20fa					MInt32False:
.20fa	a9 00		lda #$00			lda 	#0
.20fc					MInt32WriteAll:
.20fc	95 48		sta $48,x			sta 	esInt0,x
.20fe					MInt32Write123:
.20fe	95 50		sta $50,x			sta 	esInt1,x
.2100	95 58		sta $58,x			sta 	esInt2,x
.2102	95 60		sta $60,x			sta 	esInt3,x
.2104	a9 00		lda #$00			lda 	#$00						; and make it an integer
.2106	95 40		sta $40,x			sta 	esType,x
.2108	60		rts				rts
.2109					MInt32Set8Bit:
.2109	95 48		sta $48,x			sta 	esInt0,x
.210b	a9 00		lda #$00			lda 	#0
.210d	f0 ef		beq $20fe			beq		MInt32Write123
.210f					MInt32ShiftLeft:
.210f	16 48		asl $48,x			asl 	esInt0,x
.2111	36 50		rol $50,x			rol	 	esInt1,x
.2113	36 58		rol $58,x			rol	 	esInt2,x
.2115	36 60		rol $60,x			rol	 	esInt3,x
.2117	60		rts				rts
.2118					MInt32ShiftRight:
.2118	56 60		lsr $60,x			lsr 	esInt3,x
.211a	76 58		ror $58,x			ror 	esInt2,x
.211c	76 50		ror $50,x			ror 	esInt1,x
.211e	76 48		ror $48,x			ror 	esInt0,x
.2120	60		rts				rts
.2121					MInt32Zero:
.2121	b5 48		lda $48,x			lda 	esInt0,x
.2123	15 50		ora $50,x			ora 	esInt1,x
.2125	15 58		ora $58,x			ora 	esInt2,x
.2127	15 60		ora $60,x			ora 	esInt3,x
.2129	60		rts				rts
.212a					MInt32Random:
.212a	98		tya				tya
.212b	48		pha				pha
.212c	a0 07		ldy #$07			ldy 	#7
.212e	ad fb 0a	lda $0afb			lda 	MSeed32+0
.2131	d0 03		bne $2136			bne 	_Random1
.2133	a8		tay				tay
.2134	a9 aa		lda #$aa			lda		#$AA
.2136					_Random1:
.2136	0a		asl a				asl 	a
.2137	2e fc 0a	rol $0afc			rol 	MSeed32+1
.213a	2e fd 0a	rol $0afd			rol 	MSeed32+2
.213d	2e fe 0a	rol $0afe			rol 	MSeed32+3
.2140	90 02		bcc $2144			bcc 	_Random2
.2142	49 c5		eor #$c5			eor 	#$C5
.2144					_Random2:
.2144	88		dey				dey
.2145	d0 ef		bne $2136			bne 	_Random1
.2147	8d fb 0a	sta $0afb			sta 	MSeed32+0
.214a	95 48		sta $48,x			sta 	esInt0,x
.214c	ad fc 0a	lda $0afc			lda 	MSeed32+1
.214f	95 50		sta $50,x			sta 	esInt1,x
.2151	ad fd 0a	lda $0afd			lda 	MSeed32+2
.2154	95 58		sta $58,x			sta 	esInt2,x
.2156	ad fe 0a	lda $0afe			lda 	MSeed32+3
.2159	95 60		sta $60,x			sta 	esInt3,x
.215b	68		pla				pla
.215c	a8		tay				tay
.215d	a9 00		lda #$00			lda 	#0
.215f	95 40		sta $40,x			sta 	esType,x
.2161	60		rts				rts

;******  Return to file: main/main.asm


;******  Processing file: main/utility/check.asm

.2162					CheckToken:
.2162	d1 02		cmp ($02),y			cmp 	(codePtr),y
.2164	d0 02		bne $2168			bne 	_CTError
.2166	c8		iny				iny
.2167	60		rts				rts
.2168					_CTError:
.2168	a2 02		ldx #$02			ldx 	#ErrorID_Syntax
.216a	20 36 22	jsr $2236		jsr	errorHandler
.216d					CheckRightParen:
.216d	b1 02		lda ($02),y			lda 	(codePtr),y
.216f	c8		iny				iny
.2170	c9 c6		cmp #$c6			cmp 	#TKW_RPAREN
.2172	d0 01		bne $2175			bne 	_CRPError
.2174	60		rts				rts
.2175					_CRPError:
.2175	a2 09		ldx #$09			ldx 	#ErrorID_MissingRP
.2177	20 36 22	jsr $2236		jsr	errorHandler
.217a					CheckComma:
.217a	b1 02		lda ($02),y			lda 	(codePtr),y
.217c	c8		iny				iny
.217d	c9 c8		cmp #$c8			cmp 	#TKW_COMMA
.217f	d0 01		bne $2182			bne 	_CCError
.2181	60		rts				rts
.2182					_CCError:
.2182	a2 0a		ldx #$0a			ldx 	#ErrorID_MissingComma
.2184	20 36 22	jsr $2236		jsr	errorHandler

;******  Return to file: main/main.asm


;******  Processing file: main/utility/scanner.asm

.2c06					ScanForward:
.2c06	85 06		sta $06				sta 	temp1 						; save tokens to search in temp1/temp1+1
.2c08	86 07		stx $07				stx 	temp1+1
.2c0a	a9 00		lda #$00			lda 	#0 							; temp2 counts structure levels.
.2c0c	85 08		sta $08				sta 	temp2
.2c0e	b1 02		lda ($02),y	_SFLoop:lda 	(codePtr),y 				; look at the next token.
.2c10	c8		iny				iny
.2c11	a6 08		ldx $08				ldx 	temp2 						; check structure levels are zero.
.2c13	d0 08		bne $2c1d			bne 	_SFNoCheck 					; if so, check token against entered values.
.2c15	c5 06		cmp $06				cmp 	temp1
.2c17	f0 24		beq $2c3d			beq 	_SFExit
.2c19	c5 07		cmp $07				cmp 	temp1+1
.2c1b	f0 20		beq $2c3d			beq 	_SFExit
.2c1d					_SFNoCheck:
.2c1d	c9 80		cmp #$80			cmp 	#$80 						; if it is 00-7F (variable/number) just skip it.
.2c1f	90 ed		bcc $2c0e			bcc 	_SFLoop
.2c21	c9 86		cmp #$86			cmp 	#TOK_BINARYST 				; $80-$85 is various specials.
.2c23	90 19		bcc $2c3e			bcc 	_SFSpecials
.2c25	c9 99		cmp #$99			cmp 	#TOK_STRUCTST 				; if < structure start then continue
.2c27	90 e5		bcc $2c0e			bcc 	_SFLoop
.2c29	c9 a4		cmp #$a4			cmp 	#TOK_UNARYST 				; if >= unary start (after structure) then continue.
.2c2b	b0 e1		bcs $2c0e			bcs 	_SFLoop
.2c2d	aa		tax				tax  								; token in X, and look up the adjuster.
.2c2e	bd c7 1a	lda $1ac7,x			lda 	ELBinaryOperatorInfo-TOK_BINARYST,x
.2c31	38		sec				sec 								; convert to an offset
.2c32	e9 81		sbc #$81			sbc 	#$81
.2c34	18		clc				clc 								; add to depth
.2c35	65 08		adc $08				adc 	temp2
.2c37	85 08		sta $08				sta 	temp2
.2c39	10 d3		bpl $2c0e			bpl 	_SFLoop 					; +ve okay to continue
.2c3b	30 2a		bmi $2c67			bmi 	_SFError 					; if gone -ve then we have a nesting error
.2c3d	60		rts		_SFExit:rts
.2c3e					_SFSpecials:
.2c3e	c9 80		cmp #$80			cmp 	#TOK_EOL 					; $80, advance to next line.
.2c40	f0 14		beq $2c56			beq 	_SFNextLine
.2c42	c9 84		cmp #$84			cmp 	#TOK_FPC					; $84, skip embedded float
.2c44	f0 26		beq $2c6c			beq 	_SFFloatSkip
.2c46	c9 85		cmp #$85			cmp 	#TOK_STR 					; $85, skip string
.2c48	f0 04		beq $2c4e			beq 	_SFSkipString
.2c4a	c8		iny				iny									; $81,$82,$83 shift, so just advance over the shifted
.2c4b	4c 0e 2c	jmp $2c0e			jmp 	_SFLoop 					; token.
.2c4e					_SFSkipString:
.2c4e	98		tya				tya
.2c4f	38		sec				sec
.2c50	71 02		adc ($02),y			adc 	(codePtr),y
.2c52	a8		tay				tay
.2c53	4c 0e 2c	jmp $2c0e			jmp 	_SFLoop
.2c56					_SFNextLine:
.2c56	a0 00		ldy #$00			ldy 	#0 							; get offset
.2c58	b1 02		lda ($02),y			lda 	(codePtr),y
.2c5a	18		clc				clc 								; add to code pointer.
.2c5b	65 02		adc $02				adc 	codePtr
.2c5d	85 02		sta $02				sta 	codePtr
.2c5f	90 02		bcc $2c63			bcc		_SFNLNoCarry
.2c61	e6 03		inc $03				inc 	codePtr+1
.2c63					_SFNLNoCarry:
.2c63	b1 02		lda ($02),y			lda 	(codePtr),y 				; reached the end of the program.
.2c65	d0 a7		bne $2c0e			bne		_SFLoop 					; no go round again
.2c67					_SFError:
.2c67	a2 14		ldx #$14			ldx 	#ErrorID_Struct
.2c69	20 36 22	jsr $2236		jsr	errorHandler
.2c6c					_SFFloatSkip:
.2c6c	4c 8e 14	jmp $148e			jmp 	Unimplemented

;******  Return to file: main/main.asm


;******  Processing file: main/utility/stack.asm

.0078					rsPointer:
>0078							.fill 	2							; to TOS, which is the current top-token.
.2187					RSReset:
.2187	a9 ff		lda #$ff			lda 	#(returnStack+retStackSize-1) & $FF
.2189	85 78		sta $78				sta 	rsPointer
.218b	a9 09		lda #$09			lda 	#(returnStack+retStackSize-1) >> 8
.218d	85 79		sta $79				sta 	1+(rsPointer)
.218f	a9 ff		lda #$ff			lda 	#$FF 						; put a duff marker on TOS, so nothing will pop
.2191	8d ff 09	sta $09ff			sta 	returnStack+retStackSize-1
.2194	60		rts				rts
.2195					RSClaim:
.2195	84 0c		sty $0c				sty 	tempShort 					; preserve Y
.2197	48		pha				pha 								; save marker on stack.
.2198	8a		txa				txa 								; get bytes required.
.2199	38		sec				sec
.219a	49 ff		eor #$ff			eor 	#$FF 						; add to rsPointer using 2's complement.
.219c	65 78		adc $78				adc 	rsPointer
.219e	85 78		sta $78				sta 	rsPointer
.21a0	a5 79		lda $79				lda 	rsPointer+1
.21a2	69 ff		adc #$ff			adc 	#$FF
.21a4	85 79		sta $79				sta 	rsPointer+1
.21a6	c9 08		cmp #$08			cmp 	#returnStack>>8 			; overflow. underflow actually :)
.21a8	90 08		bcc $21b2			bcc 	_RSCOverflow
.21aa	68		pla				pla 								; get marker back
.21ab	a0 00		ldy #$00			ldy 	#0 							; write marker out.
.21ad	91 78		sta ($78),y			sta 	(rsPointer),y
.21af	a4 0c		ldy $0c				ldy 	tempShort 					; restore Y and exit
.21b1	60		rts				rts
.21b2					_RSCOverflow:
.21b2	a2 16		ldx #$16			ldx 	#ErrorID_RetStack
.21b4	20 36 22	jsr $2236		jsr	errorHandler
.21b7					RSFree:
.21b7	18		clc				clc
.21b8	65 78		adc $78				adc 	rsPointer
.21ba	85 78		sta $78				sta 	rsPointer
.21bc	90 02		bcc $21c0			bcc 	_RSFExit
.21be	e6 79		inc $79				inc 	rsPointer+1
.21c0					_RSFExit:
.21c0	60		rts				rts
.21c1					RSSavePosition:
.21c1	84 0c		sty $0c				sty 	tempShort 					; save Y position
.21c3	a8		tay				tay 								; this is where we write it.
.21c4	a5 02		lda $02				lda 	codePtr 					; write codePointer out
.21c6	91 78		sta ($78),y			sta 	(rsPointer),y
.21c8	c8		iny				iny
.21c9	a5 03		lda $03				lda 	codePtr+1
.21cb	91 78		sta ($78),y			sta 	(rsPointer),y
.21cd	c8		iny				iny
.21ce	a5 0c		lda $0c				lda 	tempShort 					; write the Y position out.
.21d0	91 78		sta ($78),y			sta 	(rsPointer),y
.21d2	a8		tay				tay 								; fix Y back again to original value
.21d3	60		rts				rts
.21d4					RSLoadPosition:
.21d4	a8		tay				tay
.21d5	b1 78		lda ($78),y			lda 	(rsPointer),y 				; read codePointer back
.21d7	85 02		sta $02				sta 	codePtr
.21d9	c8		iny				iny
.21da	b1 78		lda ($78),y			lda 	(rsPointer),y
.21dc	85 03		sta $03				sta 	codePtr+1
.21de	c8		iny				iny
.21df	b1 78		lda ($78),y			lda 	(rsPointer),y 				; and the offset
.21e1	a8		tay				tay 								; to Y
.21e2	60		rts				rts

;******  Return to file: main/main.asm

.21e3					mainHandler:
.21e3	7c e6 21	jmp ($21e6,x)			jmp 	(mainVectors,x)
.21e6					mainVectors:
>21e6	6d 21					.word CheckRightParen      ; index 0
>21e8	fa 1a					.word LinkEvaluate         ; index 2
>21ea	00 1b					.word LinkEvaluateInteger  ; index 4
>21ec	06 1b					.word LinkEvaluateSmallInt ; index 6
>21ee	4e 20					.word MLInt32ToString      ; index 8
>21f0	0b 13					.word PrintString          ; index 10

;******  Return to file: basic.asm

.21f2					section_end_main:
.21f2					section_start_assembler:

;******  Processing file: assembler/assembler.asm

.21f2					assemblerHandler:
.21f2	7c f5 21	jmp ($21f5,x)			jmp 	(assemblerVectors,x)
.21f5					assemblerVectors:

;******  Return to file: basic.asm

.21f5					section_end_assembler:
.21f5					section_start_device:

;******  Processing file: device/device.asm


;******  Processing file: device/option_x16/x16io.asm

.21f5					IOInitialise:
.21f5	a9 0f		lda #$0f			lda 	#15
.21f7	20 0b 22	jsr $220b			jsr 	IOPrintChar
.21fa	60		rts				rts
.21fb					IONewLine:
.21fb	48		pha				pha
.21fc	a9 0d		lda #$0d			lda 	#13
.21fe	20 0b 22	jsr $220b			jsr 	IOPrintChar
.2201	68		pla				pla
.2202	60		rts				rts
.2203					IOTab:
.2203	48		pha				pha
.2204	a9 20		lda #$20			lda 	#32
.2206	20 0b 22	jsr $220b			jsr 	IOPrintChar
.2209	68		pla				pla
.220a	60		rts				rts
.220b					IOPrintChar:
.220b	aa		tax				tax
.220c	5a		phy				phy
.220d	8a		txa				txa
.220e	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.2211	7a		ply				ply
.2212	60		rts				rts
.2213					IOInkey:
.2213	98		tya				tya
.2214	48		pha				pha
.2215	20 e4 ff	jsr $ffe4			jsr 	$FFE4
.2218	85 0c		sta $0c				sta 	tempShort
.221a	68		pla				pla
.221b	a8		tay				tay
.221c	a5 0c		lda $0c				lda 	tempShort
.221e	60		rts				rts

;******  Return to file: device/device.asm


;******  Processing file: device/option_x16/x16timer.asm

.221f					IOReadTimer:
.221f	20 de ff	jsr $ffde			jsr 	$FFDE
.2222	48		pha				pha
.2223	8a		txa				txa
.2224	a8		tay				tay
.2225	68		pla				pla
.2226	60		rts				rts

;******  Return to file: device/device.asm

.2227					deviceHandler:
.2227	7c 2a 22	jmp ($222a,x)			jmp 	(deviceVectors,x)
.222a					deviceVectors:
>222a	fb 21					.word IONewLine            ; index 0
>222c	f5 21					.word IOInitialise         ; index 2
>222e	13 22					.word IOInkey              ; index 4
>2230	0b 22					.word IOPrintChar          ; index 6
>2232	03 22					.word IOTab                ; index 8
>2234	1f 22					.word IOReadTimer          ; index 10

;******  Return to file: basic.asm

.2236					section_end_device:
.2236					section_start_error:

;******  Processing file: error/error.asm


;******  Processing file: error/errorhandler.asm

.2236					ErrorHandler:
.2236	a9 9f		lda #$9f			lda 	#(ErrorTextList) & $FF
.2238	85 04		sta $04				sta 	temp0
.223a	a9 22		lda #$22			lda 	#(ErrorTextList) >> 8
.223c	85 05		sta $05				sta 	1+(temp0)
.223e	ca		dex		_EHFind:dex
.223f	f0 10		beq $2251			beq 	_EHFound
.2241	a0 00		ldy #$00			ldy 	#0 							; goto next text message
.2243	38		sec				sec
.2244	a5 04		lda $04				lda 	temp0
.2246	71 04		adc ($04),y			adc 	(temp0),y
.2248	85 04		sta $04				sta 	temp0
.224a	90 f2		bcc $223e			bcc 	_EHFind
.224c	e6 05		inc $05				inc 	temp0+1
.224e	4c 3e 22	jmp $223e			jmp 	_EHFind
.2251					_EHFound:
.2251	a2 0a		ldx #$0a		ldx	#10
.2253	20 e3 21	jsr $21e3		jsr	mainHandler
.2256	a0 00		ldy #$00			ldy 	#0 							; in a line ?
.2258	b1 02		lda ($02),y			lda 	(codePtr),y
.225a	f0 0d		beq $2269			beq 	_EHNoLine
.225c	a9 95		lda #$95			lda 	#(EHAtMsg) & $FF
.225e	85 04		sta $04				sta 	temp0
.2260	a9 22		lda #$22			lda 	#(EHAtMsg) >> 8
.2262	85 05		sta $05				sta 	1+(temp0)
.2264	a2 0a		ldx #$0a		ldx	#10
.2266	20 e3 21	jsr $21e3		jsr	mainHandler
.2269					_EHNoLine:
.2269	a0 01		ldy #$01			ldy 	#1
.226b	a2 00		ldx #$00			ldx 	#0
.226d	b1 02		lda ($02),y			lda 	(codePtr),y
.226f	95 48		sta $48,x			sta 	esInt0,x
.2271	c8		iny				iny
.2272	b1 02		lda ($02),y			lda 	(codePtr),y
.2274	95 50		sta $50,x			sta 	esInt1,x
.2276	a9 00		lda #$00			lda 	#0
.2278	95 58		sta $58,x			sta 	esInt2,x
.227a	95 60		sta $60,x			sta 	esInt3,x
.227c	a9 cd		lda #$cd			lda 	#(convertBuffer) & $FF
.227e	85 04		sta $04				sta 	temp0
.2280	a9 0a		lda #$0a			lda 	#(convertBuffer) >> 8
.2282	85 05		sta $05				sta 	1+(temp0)
.2284	a0 0a		ldy #$0a			ldy 	#10
.2286	a9 00		lda #$00			lda 	#0
.2288	a2 08		ldx #$08		ldx	#8
.228a	20 e3 21	jsr $21e3		jsr	mainHandler
.228d	a2 0a		ldx #$0a		ldx	#10
.228f	20 e3 21	jsr $21e3		jsr	mainHandler
.2292	4c 92 22	jmp $2292	_EHHalt:jmp 	_EHHalt
.2295					EHAtMsg:
>2295	09 20 61 74 20 6c 69 6e				.text 	9," at line "
>229d	65 20

;******  Processing file: error/../generated/errortext.inc

.229f					ErrorTextList:
>229f	13 46 65 61 74 75 72 65			.text 19,"Feature not Present"
>22a7	20 6e 6f 74 20 50 72 65 73 65 6e 74
>22b3	0c 53 79 6e 74 61 78 20			.text 12,"Syntax Error"
>22bb	45 72 72 6f 72
>22c0	0f 4d 6f 64 75 6c 65 20			.text 15,"Module disabled"
>22c8	64 69 73 61 62 6c 65 64
>22d0	10 41 73 73 65 72 74 69			.text 16,"Assertion failed"
>22d8	6f 6e 20 66 61 69 6c 65 64
>22e1	0e 44 69 76 69 64 65 20			.text 14,"Divide By Zero"
>22e9	42 79 20 5a 65 72 6f
>22f0	04 53 74 6f 70				.text 4,"Stop"
>22f5	0d 54 79 70 65 20 4d 69			.text 13,"Type Mismatch"
>22fd	73 6d 61 74 63 68
>2303	0d 49 6c 6c 65 67 61 6c			.text 13,"Illegal Value"
>230b	20 56 61 6c 75 65
>2311	15 4d 69 73 73 69 6e 67			.text 21,"Missing right bracket"
>2319	20 72 69 67 68 74 20 62 72 61 63 6b 65 74
>2327	0d 4d 69 73 73 69 6e 67			.text 13,"Missing comma"
>232f	20 63 6f 6d 6d 61
>2335	11 4d 69 73 73 69 6e 67			.text 17,"Missing reference"
>233d	20 72 65 66 65 72 65 6e 63 65
>2347	15 4c 69 6e 65 20 4e 75			.text 21,"Line Number not found"
>234f	6d 62 65 72 20 6e 6f 74 20 66 6f 75 6e 64
>235d	10 53 74 72 69 6e 67 20			.text 16,"String too long."
>2365	74 6f 6f 20 6c 6f 6e 67 2e
>236e	14 52 45 54 55 52 4e 20			.text 20,"RETURN without GOSUB"
>2376	77 69 74 68 6f 75 74 20 47 4f 53 55 42
>2383	14 55 4e 54 49 4c 20 77			.text 20,"UNTIL without REPEAT"
>238b	69 74 68 6f 75 74 20 52 45 50 45 41 54
>2398	10 4e 45 58 54 20 77 69			.text 16,"NEXT without FOR"
>23a0	74 68 6f 75 74 20 46 4f 52
>23a9	12 57 45 4e 44 20 77 69			.text 18,"WEND without WHILE"
>23b1	74 68 6f 75 74 20 57 48 49 4c 45
>23bc	14 45 4e 44 50 52 4f 43			.text 20,"ENDPROC without PROC"
>23c4	20 77 69 74 68 6f 75 74 20 50 52 4f 43
>23d1	0e 42 61 64 20 4e 45 58			.text 14,"Bad NEXT index"
>23d9	54 20 69 6e 64 65 78
>23e0	17 53 74 72 75 63 74 75			.text 23,"Structures nested wrong"
>23e8	72 65 73 20 6e 65 73 74 65 64 20 77 72 6f 6e 67
>23f8	16 43 61 6e 6e 6f 74 20			.text 22,"Cannot create variable"
>2400	63 72 65 61 74 65 20 76 61 72 69 61 62 6c 65
>240f	1a 52 65 74 75 72 6e 20			.text 26,"Return stack out of space."
>2417	73 74 61 63 6b 20 6f 75 74 20 6f 66 20 73 70 61
>2427	63 65 2e
>242a	11 55 6e 6b 6e 6f 77 6e			.text 17,"Unknown Procedure"
>2432	20 50 72 6f 63 65 64 75 72 65
>243c	18 50 61 72 61 6d 65 74			.text 24,"Parameters do not match."
>2444	65 72 73 20 64 6f 20 6e 6f 74 20 6d 61 74 63 68
>2454	2e
>2455	15 41 72 72 61 79 20 61			.text 21,"Array already defined"
>245d	6c 72 65 61 64 79 20 64 65 66 69 6e 65 64
>246b	12 44 49 4d 20 72 65 71			.text 18,"DIM requires array"
>2473	75 69 72 65 73 20 61 72 72 61 79
>247e	10 42 61 64 20 61 72 72			.text 16,"Bad array index."
>2486	61 79 20 69 6e 64 65 78 2e
>248f	00					.byte 0

;******  Return to file: error/errorhandler.asm


;******  Return to file: error/error.asm


;******  Return to file: basic.asm

.2490					section_end_error:
.2490					section_start_extension:

;******  Processing file: extension/extension.asm


;******  Processing file: extension/extensionhandler.asm

.2490					ExtensionHandler:
.2490	c9 ff		cmp #$ff			cmp 	#$FF						; A = $FF command, otherwise unary function stack level.
.2492	d0 08		bne $249c			bne 	_ExtensionUnary
.2494	b1 02		lda ($02),y			lda 	(codePtr),y
.2496	c8		iny				iny
.2497	0a		asl a				asl 	a
.2498	aa		tax				tax
.2499	7c 9a 24	jmp ($249a,x)			jmp 	(Group2Vectors-12,X)
.249c					_ExtensionUnary:
.249c	48		pha				pha 								; save stack pos in A
.249d	b1 02		lda ($02),y			lda 	(codePtr),y 				; get shifted token
.249f	c8		iny				iny
.24a0	0a		asl a				asl 	a
.24a1	aa		tax				tax
.24a2	68		pla				pla
.24a3	7c 9e 24	jmp ($249e,x)			jmp 	(Group3Vectors-12,X)

;******  Processing file: extension/../generated/tokenvectors2.inc

.24a6					Group2Vectors:
>24a6	b6 24					.word	Command_VPoke            ; $86 vpoke
>24a8	b9 24					.word	Command_VDoke            ; $87 vdoke

;******  Return to file: extension/extensionhandler.asm


;******  Processing file: extension/../generated/tokenvectors3.inc

.24aa					Group3Vectors:
>24aa	fa 24					.word	Command_VPeek            ; $86 vpeek(
>24ac	fd 24					.word	Command_VDeek            ; $87 vdeek(

;******  Return to file: extension/extensionhandler.asm

.24ae					XEvaluateInteger:
.24ae	8a		txa				txa
.24af	a2 04		ldx #$04		ldx	#4
.24b1	20 e3 21	jsr $21e3		jsr	mainHandler
.24b4	aa		tax				tax
.24b5	60		rts				rts

;******  Return to file: extension/extension.asm


;******  Processing file: extension/option_x16/vpeekpoke.asm

.24b6					Command_VPoke:
.24b6	38		sec				sec 						; one byte , CS
.24b7	b0 01		bcs $24ba			bcs 	CmdVideoWrite
.24b9					Command_VDoke:
.24b9	18		clc				clc 						; two bytes, CC
.24ba					CmdVideoWrite:
.24ba	08		php				php
.24bb	a2 00		ldx #$00			ldx 	#0  				; get address into levels 0,1
.24bd	20 ae 24	jsr $24ae			jsr 	XEvaluateInteger
.24c0	20 7a 21	jsr $217a			jsr 	CheckComma
.24c3	e8		inx				inx
.24c4	20 ae 24	jsr $24ae			jsr 	XEvaluateInteger
.24c7	ca		dex				dex
.24c8	20 d9 24	jsr $24d9			jsr 	SetUpTOSVRamAddress
.24cb	a5 49		lda $49				lda 	esInt0+1 			; get MSB of write value
.24cd	8d 23 9f	sta $9f23			sta 	$9F23
.24d0	28		plp				plp 						; if it was Poke then exit
.24d1	b0 05		bcs $24d8			bcs 	_CVWExit
.24d3	a5 51		lda $51				lda 	esInt1+1 			; doke, write the MSB.
.24d5	8d 23 9f	sta $9f23			sta 	$9F23
.24d8					_CVWExit:
.24d8	60		rts				rts
.24d9					SetUpTOSVRamAddress:
.24d9	b5 58		lda $58,x			lda 	esInt2,x 			; check range of address, data to $FFFF
.24db	29 01		and #$01			and 	#1
.24dd	15 60		ora $60,x			ora 	esInt3,x
.24df	d0 14		bne $24f5			bne 	CVWValue
.24e1	b5 48		lda $48,x			lda 	esInt0,x				; set address up
.24e3	8d 20 9f	sta $9f20			sta 	$9F20
.24e6	b5 50		lda $50,x			lda 	esInt1,x
.24e8	8d 21 9f	sta $9f21			sta	 	$9F21
.24eb	b5 58		lda $58,x			lda 	esInt2,x
.24ed	29 01		and #$01			and 	#1
.24ef	09 10		ora #$10			ora 	#$10 				; step 1.
.24f1	8d 22 9f	sta $9f22			sta 	$9F22
.24f4	60		rts				rts
.24f5					CVWValue:
.24f5	a2 08		ldx #$08			ldx 	#ErrorID_BadValue
.24f7	20 36 22	jsr $2236		jsr	errorHandler
.24fa					Command_VPeek:
.24fa	38		sec				sec 						; one byte , CS
.24fb	b0 01		bcs $24fe			bcs 	CmdVideoRead
.24fd					Command_VDeek:
.24fd	18		clc				clc 						; two bytes, CC
.24fe					CmdVideoRead:
>24fe	db						.byte 	$DB
.24ff	08		php				php 						; save action on stack.
.2500	aa		tax				tax 						; save stack position
.2501	20 ae 24	jsr $24ae			jsr 	XEvaluateInteger 	; address
.2504	20 6d 21	jsr $216d			jsr 	CheckRightParen 	; closing right bracket.
.2507	20 d9 24	jsr $24d9			jsr 	SetUpTOSVRamAddress	; set up VRAM address.
.250a	a9 00		lda #$00			lda 	#0 					; zero the return value
.250c	95 60		sta $60,x			sta 	esInt3,x
.250e	95 58		sta $58,x			sta 	esInt2,x
.2510	95 50		sta $50,x			sta 	esInt1,x
.2512	ad 23 9f	lda $9f23			lda 	$9F23
.2515	95 48		sta $48,x			sta 	esInt0,x
.2517	28		plp				plp
.2518	b0 05		bcs $251f			bcs 	_CVRExit
.251a	ad 23 9f	lda $9f23			lda 	$9F23
.251d	95 50		sta $50,x			sta 	esInt1,x
.251f					_CVRExit:
.251f	8a		txa				txa 						; return X position.
.2520	60		rts				rts

;******  Return to file: extension/extension.asm


;******  Return to file: basic.asm

.2521					section_end_extension:
.2521					section_start_floatingpoint:

;******  Processing file: floatingpoint/floatingpoint.asm

.2521					floatingpointHandler:
.2521	a2 03		ldx #$03			ldx 	#ErrorID_NoModule
.2523	20 36 22	jsr $2236		jsr	errorHandler

;******  Return to file: basic.asm

.2526					section_end_floatingpoint:
.2526					section_start_interaction:

;******  Processing file: interaction/interaction.asm

.2526					interactionHandler:
.2526	7c 29 25	jmp ($2529,x)			jmp 	(interactionVectors,x)
.2529					interactionVectors:

;******  Return to file: basic.asm

.2529					section_end_interaction:
.2529					section_start_string:

;******  Processing file: string/string.asm


;******  Processing file: string/chr.asm

.2529					StringChrs:
.2529	aa		tax				tax 								; set up stack
.252a	a9 02		lda #$02			lda 	#2
.252c	20 e3 25	jsr $25e3			jsr 	AllocateSoftString
.252f	98		tya				tya
.2530	20 09 26	jsr $2609			jsr 	WriteSoftString
.2533	20 38 25	jsr $2538			jsr 	ReturnSoftString
.2536	8a		txa				txa
.2537	60		rts				rts
.2538					ReturnSoftString:
.2538	a5 7a		lda $7a				lda 	softMemAlloc
.253a	95 48		sta $48,x			sta 	esInt0,x
.253c	a5 7b		lda $7b				lda 	softMemAlloc+1
.253e	95 50		sta $50,x			sta 	esInt1,x
.2540	a9 00		lda #$00			lda 	#0
.2542	95 58		sta $58,x			sta 	esInt2,x
.2544	95 60		sta $60,x			sta 	esInt3,x
.2546	a9 40		lda #$40			lda 	#$40
.2548	95 40		sta $40,x			sta 	esType,x
.254a	60		rts				rts

;******  Return to file: string/string.asm


;******  Processing file: string/compare.asm

.254b					STRCompare:
.254b	48		pha				pha 								; save A
.254c	aa		tax				tax 								; put stack pos in X
.254d	98		tya				tya
.254e	48		pha				pha
.254f	20 83 25	jsr $2583			jsr 	CopyStringPair
.2552	a0 00		ldy #$00			ldy 	#0 							; get the smaller of the two string sizes.
.2554	b1 04		lda ($04),y			lda 	(temp0),y
.2556	d1 06		cmp ($06),y			cmp 	(temp1),y
.2558	90 02		bcc $255c			bcc 	_SCNotSmaller
.255a	b1 06		lda ($06),y			lda 	(temp1),y
.255c					_SCNotSmaller:
.255c	aa		tax				tax 								; put that in X. We compare this many chars first.
.255d					_SCCompareLoop:
.255d	e0 00		cpx #$00			cpx 	#0 							; if compared all the smaller, then it is the shorter
.255f	f0 0c		beq $256d			beq 	_SCSameToEndShortest 		; one that is the smallest if they are different lengths.
.2561	ca		dex				dex 								; decrement chars to compare.
.2562	c8		iny				iny 								; move to next character
.2563	38		sec				sec 								; calculate s1[y]-s2[y]
.2564	b1 04		lda ($04),y			lda 	(temp0),y
.2566	f1 06		sbc ($06),y			sbc 	(temp1),y
.2568	d0 0a		bne $2574			bne 	_SCReturnResult 			; if different return sign of A
.256a	4c 5d 25	jmp $255d			jmp 	_SCCompareLoop
.256d					_SCSameToEndShortest
.256d	a0 00		ldy #$00			ldy 	#0 							; compare len(s1) - len(s2)
.256f	38		sec				sec
.2570	b1 04		lda ($04),y			lda 	(temp0),y
.2572	f1 06		sbc ($06),y			sbc 	(temp1),y
.2574					_SCReturnResult:
.2574	08		php				php 								; set return to zero preserving PSW.
.2575	a2 00		ldx #$00			ldx 	#0
.2577	28		plp				plp
.2578	f0 05		beq $257f			beq 	_SCExit 					; two values equal, then exit
.257a	ca		dex				dex 								; X = $FF
.257b	90 02		bcc $257f			bcc 	_SCExit 					; if 1st < 2nd then -1
.257d	a2 01		ldx #$01			ldx 	#1 							; X = $01 if greater
.257f					_SCExit:
.257f	68		pla				pla
.2580	a8		tay				tay
.2581	68		pla				pla
.2582	60		rts				rts
.2583					CopyStringPair:
.2583	b5 49		lda $49,x			lda 	esInt0+1,x
.2585	85 06		sta $06				sta 	temp1
.2587	b5 51		lda $51,x			lda 	esInt1+1,x
.2589	85 07		sta $07				sta 	temp1+1
.258b					CopyStringTop:
.258b	b5 48		lda $48,x			lda 	esInt0,x
.258d	85 04		sta $04				sta 	temp0
.258f	b5 50		lda $50,x			lda 	esInt1,x
.2591	85 05		sta $05				sta 	temp0+1
.2593	60		rts				rts

;******  Return to file: string/string.asm


;******  Processing file: string/concat.asm

.2594					StringConcat:
.2594	aa		tax				tax									; stack pos in X
.2595	98		tya				tya
.2596	48		pha				pha
.2597	20 83 25	jsr $2583			jsr 	CopyStringPair 				; temp0 and temp1 point to strings to concat.
.259a	38		sec				sec 								; calculate alloc strings. lengths added + 1 for size.
.259b	a0 00		ldy #$00			ldy 	#0
.259d	b1 04		lda ($04),y			lda 	(temp0),y
.259f	71 06		adc ($06),y			adc 	(temp1),y
.25a1	b0 1c		bcs $25bf			bcs 	_SCError 					; just too many characters here.
.25a3	c9 fc		cmp #$fc			cmp 	#MaxStringSize
.25a5	b0 18		bcs $25bf			bcs 	_SCError
.25a7	20 e3 25	jsr $25e3			jsr 	AllocateSoftString 			; allocate soft string memory, set pointer.
.25aa	20 da 25	jsr $25da			jsr 	CopySoftToStack 			; copy that to the stack.
.25ad	20 c4 25	jsr $25c4			jsr 	SCCopyTemp0 				; copy temp0
.25b0	a5 06		lda $06				lda 	temp1 						; copy temp1 to temp0
.25b2	85 04		sta $04				sta 	temp0
.25b4	a5 07		lda $07				lda 	temp1+1
.25b6	85 05		sta $05				sta 	temp0+1
.25b8	20 c4 25	jsr $25c4			jsr 	SCCopyTemp0 				; copy temp0 e.g. what was temp1.
.25bb	68		pla				pla
.25bc	a8		tay				tay
.25bd	8a		txa				txa 								; and A
.25be	60		rts				rts
.25bf					_SCError:
.25bf	a2 0d		ldx #$0d			ldx 	#ErrorID_StrLen
.25c1	20 36 22	jsr $2236		jsr	errorHandler
.25c4					SCCopyTemp0:
.25c4	a0 00		ldy #$00			ldy 	#0 							; put count in temp2
.25c6	b1 04		lda ($04),y			lda 	(temp0),y
.25c8	85 08		sta $08				sta 	temp2
.25ca					_SCCopyLoop:
.25ca	a5 08		lda $08				lda 	temp2 						; done the lot
.25cc	f0 0b		beq $25d9			beq 	_SCCopyExit
.25ce	c6 08		dec $08				dec 	temp2
.25d0	c8		iny				iny 								; get next char
.25d1	b1 04		lda ($04),y			lda 	(temp0),y
.25d3	20 09 26	jsr $2609			jsr 	WriteSoftString 			; write to soft string.
.25d6	4c ca 25	jmp $25ca			jmp 	_SCCopyLoop
.25d9					_SCCopyExit:
.25d9	60		rts				rts
.25da					CopySoftToStack:
.25da	a5 7a		lda $7a				lda 	SoftMemAlloc 				; copy the memory allocation pointer to the stack.
.25dc	95 48		sta $48,x			sta 	esInt0,x 					; type is already string.
.25de	a5 7b		lda $7b				lda 	SoftMemAlloc+1
.25e0	95 50		sta $50,x			sta 	esInt1,x
.25e2	60		rts				rts

;******  Return to file: string/string.asm


;******  Processing file: string/memory.asm

.007a					softMemAlloc:
>007a							.fill 	2  							; if MSB is zero needs resetting on allocation.
.25e3					AllocateSoftString:
.25e3	85 0c		sta $0c				sta 	tempShort 					; save count
.25e5	98		tya				tya
.25e6	48		pha				pha
.25e7	a5 7b		lda $7b				lda 	softMemAlloc+1 				; if the high byte is zero, it needs allocating.
.25e9	d0 09		bne $25f4			bne 	_ASSDone
.25eb	a5 0d		lda $0d				lda 	highMemory 					; reset the soft memory alloc pointer.
.25ed	85 7a		sta $7a				sta 	softMemAlloc 				; to speed up slightly, we only reset this when we first need it
.25ef	a4 0e		ldy $0e				ldy 	highMemory+1 				; but it needs to be reset before each command.
.25f1	88		dey				dey
.25f2	84 7b		sty $7b				sty 	softMemAlloc+1
.25f4					_ASSDone:
.25f4	38		sec				sec 								; allocate downwards enough memory
.25f5	a5 7a		lda $7a				lda 	softMemAlloc
.25f7	e5 0c		sbc $0c				sbc 	tempShort
.25f9	85 7a		sta $7a				sta 	softMemAlloc
.25fb	a5 7b		lda $7b				lda 	softMemAlloc+1
.25fd	e9 00		sbc #$00			sbc 	#0
.25ff	85 7b		sta $7b				sta 	softMemAlloc+1
.2601	a9 00		lda #$00			lda 	#0 							; empty that string, set the length = 0.
.2603	a8		tay				tay
.2604	91 7a		sta ($7a),y			sta 	(softMemAlloc),y
.2606	68		pla				pla
.2607	a8		tay				tay
.2608	60		rts				rts
.2609					WriteSoftString:
.2609	84 0c		sty $0c				sty 	tempShort 					; save Y
.260b	48		pha				pha
.260c	a0 00		ldy #$00			ldy 	#0 							; get and bump length
.260e	b1 7a		lda ($7a),y			lda 	(softMemAlloc),y
.2610	18		clc				clc
.2611	69 01		adc #$01			adc 	#1
.2613	91 7a		sta ($7a),y			sta 	(softMemAlloc),y
.2615	a8		tay				tay 								; pointer in Y
.2616	68		pla				pla 								; get char and write.
.2617	91 7a		sta ($7a),y			sta 	(softMemAlloc),y
.2619	a4 0c		ldy $0c				ldy 	tempShort 					; restore Y and exit.
.261b	60		rts				rts
.261c					StrClone:
.261c	aa		tax				tax 								; set up stack.
.261d	98		tya				tya
.261e	48		pha				pha
.261f	a0 00		ldy #$00			ldy 	#0 							; get length, add 1 for length
.2621	b1 04		lda ($04),y			lda 	(temp0),y
.2623	18		clc				clc
.2624	69 01		adc #$01			adc 	#1
.2626	20 e3 25	jsr $25e3			jsr 	AllocateSoftString 			; allocate soft memory
.2629	a5 7a		lda $7a				lda 	softMemAlloc 				; copy that address to TOS
.262b	95 48		sta $48,x			sta 	esInt0,x
.262d	a5 7b		lda $7b				lda 	softMemAlloc+1
.262f	95 50		sta $50,x			sta 	esInt1,x
.2631	a9 00		lda #$00			lda 	#0
.2633	95 58		sta $58,x			sta 	esInt2,x
.2635	95 60		sta $60,x			sta 	esInt3,x
.2637	a9 40		lda #$40			lda 	#$40 						; set type to string.
.2639	95 40		sta $40,x			sta 	esType,x
.263b	20 c4 25	jsr $25c4			jsr 	SCCopyTemp0 				; copy temp0 string to soft memory copy (concat.asm)
.263e	68		pla				pla
.263f	a8		tay				tay
.2640	8a		txa				txa
.2641	60		rts				rts

;******  Return to file: string/string.asm


;******  Processing file: string/setcase.asm

.2642					CaseString:
.2642	48		pha				pha 								; save A and copy to X
.2643	aa		tax				tax
.2644	98		tya				tya
.2645	48		pha				pha
.2646	20 3c 11	jsr $113c			jsr 	TOSToTemp0 					; target string -> temp0
.2649	a0 00		ldy #$00			ldy 	#0
.264b	b1 04		lda ($04),y			lda 	(temp0),y  					; get length,
.264d	18		clc				clc
.264e	69 01		adc #$01			adc 	#1 							; one more for length byte
.2650	20 e3 25	jsr $25e3			jsr 	AllocateSoftString 			; allocate soft string memory, set pointer.
.2653	20 da 25	jsr $25da			jsr 	CopySoftToStack 			; copy that to the stack.
.2656	a0 00		ldy #$00			ldy 	#0
.2658	b1 04		lda ($04),y			lda 	(temp0),y 					; count to copy in X
.265a	aa		tax				tax
.265b					_CSCopy:
.265b	e0 00		cpx #$00			cpx 	#0
.265d	f0 24		beq $2683			beq 	_CSExit
.265f	ca		dex				dex
.2660	c8		iny				iny
.2661	68		pla				pla 								; check direction
.2662	48		pha				pha
.2663	f0 0c		beq $2671			beq 	_CSUpper
.2665	b1 04		lda ($04),y			lda 	(temp0),y 					; lower$() code
.2667	c9 41		cmp #$41			cmp 	#"A"
.2669	90 12		bcc $267d			bcc 	_CSWrite
.266b	c9 5b		cmp #$5b			cmp 	#"Z"+1
.266d	b0 0e		bcs $267d			bcs 	_CSWrite
.266f	90 0a		bcc $267b			bcc 	_CSFlipWrite
.2671					_CSUpper:
.2671	b1 04		lda ($04),y			lda 	(temp0),y 					; upper$() code
.2673	c9 61		cmp #$61			cmp 	#"a"
.2675	90 06		bcc $267d			bcc 	_CSWrite
.2677	c9 7b		cmp #$7b			cmp 	#"z"+1
.2679	b0 02		bcs $267d			bcs 	_CSWrite
.267b					_CSFlipWrite:
.267b	49 20		eor #$20			eor 	#"A"^"a"
.267d					_CSWrite:
.267d	20 09 26	jsr $2609			jsr 	WriteSoftString
.2680	4c 5b 26	jmp $265b			jmp 	_CSCopy
.2683					_CSExit:
.2683	68		pla				pla
.2684	a8		tay				tay
.2685	68		pla				pla
.2686	60		rts				rts

;******  Return to file: string/string.asm


;******  Processing file: string/substring.asm

.2687					StringSubstring:
.2687	48		pha				pha
.2688	aa		tax				tax 								; access stack.
.2689	98		tya				tya
.268a	48		pha				pha
.268b	20 8b 25	jsr $258b			jsr 	CopyStringTop 				; point temp0 to the string.
.268e	a0 00		ldy #$00			ldy 	#0 							; get length.
.2690	b1 04		lda ($04),y			lda 	(temp0),Y
.2692	85 06		sta $06				sta 	temp1
.2694	b5 49		lda $49,x			lda 	esInt0+1,x 					; get the initial offset
.2696	c5 06		cmp $06				cmp 	temp1 						;
.2698	f0 02		beq $269c			beq 	_SSBOkay
.269a	b0 2a		bcs $26c6			bcs 	_SSBReturnNull
.269c					_SSBOkay:
.269c	a5 06		lda $06				lda 	temp1 						; get the total length +1
.269e	18		clc				clc
.269f	69 01		adc #$01			adc 	#1
.26a1	38		sec				sec
.26a2	f5 49		sbc $49,x			sbc 	esInt0+1,x 					; the anything >= this is bad.
.26a4	d5 4a		cmp $4a,x			cmp 	esInt0+2,x  				; check bad >= required
.26a6	90 02		bcc $26aa			bcc		_SSBTrunc
.26a8	b5 4a		lda $4a,x			lda 	esInt0+2,x
.26aa					_SSBTrunc:
.26aa	85 07		sta $07				sta 	temp1+1 					; characters to copy.
.26ac	18		clc				clc
.26ad	69 01		adc #$01			adc 	#1 							; add 1
.26af	20 e3 25	jsr $25e3			jsr 	AllocateSoftString 			; allocate soft string memory, set pointer.
.26b2	20 da 25	jsr $25da			jsr 	CopySoftToStack 			; copy that to the stack.
.26b5	b4 49		ldy $49,x			ldy 	esInt0+1,x 					; get initial position of char to copy
.26b7					_SSBCopyLoop:
.26b7	a5 07		lda $07				lda 	temp1+1 					; done them all
.26b9	f0 0e		beq $26c9			beq 	_SSBExit
.26bb	c6 07		dec $07				dec 	temp1+1
.26bd	b1 04		lda ($04),y			lda 	(temp0),y 					; get and write character
.26bf	20 09 26	jsr $2609			jsr 	WriteSoftString
.26c2	c8		iny				iny
.26c3	4c b7 26	jmp $26b7			jmp 	_SSBCopyLoop
.26c6					_SSBReturnNull:
.26c6	20 cd 26	jsr $26cd			jsr 	ReturnNull
.26c9					_SSBExit:
.26c9	68		pla				pla
.26ca	a8		tay				tay
.26cb	68		pla				pla
.26cc	60		rts				rts
.26cd					ReturnNull:
.26cd	a9 00		lda #$00			lda 	#0 							; clear null string
.26cf	8d cc 0a	sta $0acc			sta 	NullString
.26d2	a9 cc		lda #$cc			lda 	#NullString & $FF 			; set a pointer to it
.26d4	95 48		sta $48,x			sta 	esInt0,x
.26d6	a9 0a		lda #$0a			lda 	#NullString >> 8
.26d8	95 50		sta $50,x			sta 	esInt1,x
.26da	60		rts				rts

;******  Return to file: string/string.asm


;******  Processing file: string/write.asm

.0aff					srcStrLen:
>0aff							.fill 	1
.26db					StringWrite:
.26db	aa		tax				tax
.26dc	48		pha				pha
.26dd	98		tya				tya
.26de	48		pha				pha
.26df	20 06 27	jsr $2706			jsr 	CheckOverwriteCurrent
.26e2	b0 0d		bcs $26f1			bcs		_SWCopyCurrent
.26e4	20 44 27	jsr $2744			jsr 	RequiresConcretion
.26e7	90 0e		bcc $26f7			bcc 	_SWWriteReference
.26e9	20 a7 27	jsr $27a7			jsr 	CheckSpecialConcretion
.26ec	b0 09		bcs $26f7			bcs 	_SWWriteReference
.26ee	20 58 27	jsr $2758			jsr 	AllocateHardMemory
.26f1					_SWCopyCurrent:
.26f1	20 8b 27	jsr $278b			jsr 	CopyStringToHardMemory
.26f4	4c 02 27	jmp $2702			jmp 	_SWExit
.26f7					_SWWriteReference
.26f7	a0 00		ldy #$00			ldy 	#0
.26f9	a5 04		lda $04				lda 	temp0
.26fb	91 06		sta ($06),y			sta 	(temp1),y
.26fd	c8		iny				iny
.26fe	a5 05		lda $05				lda 	temp0+1
.2700	91 06		sta ($06),y			sta 	(temp1),y
.2702					_SWExit:
.2702	68		pla				pla
.2703	a8		tay				tay
.2704	68		pla				pla
.2705	60		rts				rts
.2706					CheckOverwriteCurrent:
.2706	a0 00		ldy #$00			ldy 	#0 						; get address of string being written to temp0
.2708	b5 51		lda $51,x			lda 	esInt1+1,x
.270a	85 05		sta $05				sta 	temp0+1
.270c	b5 49		lda $49,x			lda 	esInt0+1,x
.270e	85 04		sta $04				sta 	temp0
.2710	b1 04		lda ($04),y			lda 	(temp0),y 				; get length of string being copied.
.2712	8d ff 0a	sta $0aff			sta 	srcStrLen
.2715	b5 48		lda $48,x			lda 	esInt0,x 				; copy where the final address it being written to temp1.
.2717	85 06		sta $06				sta 	temp1 					; e.g. if it is ax$ then temp1 will point to the ax$
.2719	b5 50		lda $50,x			lda 	esInt1,x 				; data record + 5
.271b	85 07		sta $07				sta 	temp1+1
.271d	a0 01		ldy #$01			ldy 	#1 						; get the MSB of the address of string currently stored there.
.271f	b1 06		lda ($06),y			lda 	(temp1),y
.2721	c5 0e		cmp $0e				cmp 	highMemory+1 			; if < high memory then it cannot be something stored
.2723	90 1b		bcc $2740			bcc 	_COCFail 				; in hard memory.
.2725	a0 00		ldy #$00			ldy 	#0 						; copy target address - 1 into temp2
.2727	b1 06		lda ($06),y			lda 	(temp1),y
.2729	e9 01		sbc #$01			sbc 	#1
.272b	85 08		sta $08				sta 	temp2
.272d	c8		iny				iny
.272e	b1 06		lda ($06),y			lda 	(temp1),y
.2730	e9 00		sbc #$00			sbc 	#0
.2732	85 09		sta $09				sta 	temp2+1
.2734	a0 00		ldy #$00			ldy 	#0 						; how large is this physical chunk.
.2736	b1 08		lda ($08),y			lda 	(temp2),y
.2738	38		sec				sec  							; maximum character capacity.
.2739	e9 02		sbc #$02			sbc 	#2
.273b	cd ff 0a	cmp $0aff			cmp 	srcStrLen 				; if >= the required length
.273e	b0 02		bcs $2742			bcs 	_COCCanReuse
.2740					_COCFail:
.2740	18		clc				clc
.2741	60		rts				rts
.2742					_COCCanReuse:
.2742	38		sec				sec
.2743	60		rts				rts
.2744					RequiresConcretion:
.2744	a5 05		lda $05				lda 	temp0+1 				; get MSB of address of string to be written
.2746	c5 0e		cmp $0e				cmp 	highMemory+1 			; if >= high memory it is concreted
.2748	b0 0a		bcs $2754			bcs 	_RCSucceed 				; so it needs concreting again - duplication.
.274a	a5 7b		lda $7b				lda 	softMemAlloc+1 			; have we allocated any soft memory yet ?
.274c	f0 08		beq $2756			beq 	_RCFail 				; if not, this cannot be soft memory.
.274e	a5 05		lda $05				lda 	temp0+1 				; get MSB of address of string to be written
.2750	c5 7b		cmp $7b				cmp 	softMemAlloc+1 			; if >= soft mem alloc it is either soft
.2752	90 02		bcc $2756			bcc 	_RCFail 				; so concreting
.2754					_RCSucceed:
.2754	38		sec				sec
.2755	60		rts				rts
.2756					_RCFail:
.2756	18		clc				clc
.2757	60		rts				rts
.2758					AllocateHardMemory:
.2758	98		tya				tya
.2759	48		pha				pha
.275a	ad ff 0a	lda $0aff			lda 	srcStrLen 				; characters in string
.275d	69 0a		adc #$0a			adc 	#1+1+8 					; one for hard memory size, one for string size, extra for expansion
.275f	b0 04		bcs $2765			bcs 	_AHMSetMax 				; max out that amount.
.2761	c9 fe		cmp #$fe			cmp 	#MaxStringSize+2
.2763	90 02		bcc $2767			bcc 	_AHMIsOkay
.2765					_AHMSetMax:
.2765	a9 fe		lda #$fe			lda 	#MaxStringSize+2
.2767					_AHMIsOkay:
.2767	48		pha				pha
.2768	49 ff		eor #$ff			eor 	#$FF 					; complement and add to high Memory
.276a	38		sec				sec  							; and copy result to TOS as target address.
.276b	65 0d		adc $0d				adc 	highMemory
.276d	85 0d		sta $0d				sta 	highMemory
.276f	a5 0e		lda $0e				lda 	highMemory+1
.2771	69 ff		adc #$ff			adc 	#$FF
.2773	85 0e		sta $0e				sta 	highMemory+1
.2775	a0 00		ldy #$00			ldy 	#0 						; Y = 0
.2777	68		pla				pla 							; get the total size of the storage block
.2778	91 0d		sta ($0d),y			sta 	(highMemory),y
.277a	18		clc				clc
.277b	a5 0d		lda $0d				lda		highMemory 				; point the target address to the byte after this.
.277d	69 01		adc #$01			adc 	#1
.277f	91 06		sta ($06),y			sta 	(temp1),y
.2781	a5 0e		lda $0e				lda 	highMemory+1
.2783	69 00		adc #$00			adc 	#0
.2785	c8		iny				iny
.2786	91 06		sta ($06),y			sta 	(temp1),y
.2788	68		pla				pla
.2789	a8		tay				tay
.278a	60		rts				rts
.278b					CopyStringToHardMemory:
.278b	98		tya				tya
.278c	48		pha				pha
.278d	a0 00		ldy #$00			ldy 	#0 						; copy target address to temp2
.278f	b1 06		lda ($06),y			lda 	(temp1),y
.2791	85 08		sta $08				sta 	temp2
.2793	c8		iny				iny
.2794	b1 06		lda ($06),y			lda 	(temp1),y
.2796	85 09		sta $09				sta 	temp2+1
.2798	ac ff 0a	ldy $0aff			ldy 	srcStrLen 				; copy this + 1 characters, (length too) hence $FF compare
.279b					_CSTHMLoop:
.279b	b1 04		lda ($04),y			lda 	(temp0),y
.279d	91 08		sta ($08),y			sta 	(temp2),y
.279f	88		dey				dey
.27a0	c0 ff		cpy #$ff			cpy 	#$FF
.27a2	d0 f7		bne $279b			bne 	_CSTHMLoop
.27a4	68		pla				pla
.27a5	a8		tay				tay
.27a6	60		rts				rts
.27a7					CheckSpecialConcretion:
.27a7	ad ff 0a	lda $0aff			lda 	srcStrLen 				; check string is null.
.27aa	f0 02		beq $27ae			beq 	_CSCNullString
.27ac	18		clc				clc
.27ad	60		rts				rts
.27ae					_CSCNullString:
.27ae	a9 00		lda #$00			lda 	#0
.27b0	8d cc 0a	sta $0acc			sta 	NullString
.27b3	a9 cc		lda #$cc			lda 	#(NullString) & $FF
.27b5	85 04		sta $04				sta 	temp0
.27b7	a9 0a		lda #$0a			lda 	#(NullString) >> 8
.27b9	85 05		sta $05				sta 	1+(temp0)
.27bb	38		sec				sec
.27bc	60		rts				rts

;******  Return to file: string/string.asm

.27bd					stringHandler:
.27bd	7c c0 27	jmp ($27c0,x)			jmp 	(stringVectors,x)
.27c0					stringVectors:
>27c0	29 25					.word StringChrs           ; index 0
>27c2	1c 26					.word StrClone             ; index 2
>27c4	94 25					.word StringConcat         ; index 4
>27c6	4b 25					.word STRCompare           ; index 6
>27c8	42 26					.word CaseString           ; index 8
>27ca	87 26					.word StringSubstring      ; index 10
>27cc	db 26					.word StringWrite          ; index 12

;******  Return to file: basic.asm

.27ce					section_end_string:
.27ce					section_start_tokeniser:

;******  Processing file: tokeniser/tokeniser.asm

.27ce					tokeniserHandler:
.27ce	7c d1 27	jmp ($27d1,x)			jmp 	(tokeniserVectors,x)
.27d1					tokeniserVectors:

;******  Return to file: basic.asm

.27d1					section_end_tokeniser:
.27d1					section_start_variable:

;******  Processing file: variable/variable.asm


;******  Processing file: variable/access.asm

.0b00					varHash:
>0b00							.fill	1
.0b01					varType:
>0b01							.fill 	1
.0b02					varEnd:
>0b02							.fill 	1
.007c					hashList:
>007c							.fill 	2
.27d1					AccessVariable:
.27d1	aa		tax				tax 								; stack in X
.27d2	c8		iny				iny
.27d3	b1 02		lda ($02),y			lda 	(codePtr),y
.27d5	88		dey				dey
.27d6	c9 3a		cmp #$3a			cmp 	#TYPE_INT 					; is it one of the end markers ?
.27d8	d0 15		bne $27ef			bne 	_AVLong
.27da	b1 02		lda ($02),y			lda 	(codePtr),y 				; this is the 6 bit ASCII of A-Z 1-26
.27dc	38		sec				sec 	 							; make it 0-25
.27dd	e9 01		sbc #$01			sbc 	#1
.27df	0a		asl a				asl 	a 							; x 4 is LSB of address
.27e0	0a		asl a				asl 	a
.27e1	95 48		sta $48,x			sta 	esInt0,x
.27e3	a9 0a		lda #$0a			lda 	#SingleLetterVar >> 8 		; make it an address
.27e5	95 50		sta $50,x			sta 	esInt1,x
.27e7	a9 80		lda #$80			lda 	#$80 						; type is integer reference.
.27e9	95 40		sta $40,x			sta 	esType,x
.27eb	c8		iny				iny 								; skip over the variable reference in the code.
.27ec	c8		iny				iny
.27ed	8a		txa				txa 								; stack in A to return.
.27ee	60		rts				rts
.27ef					_AVLong:
.27ef	8a		txa				txa
.27f0	48		pha				pha
.27f1	20 38 28	jsr $2838			jsr 	AccessSetup 				; set up the basic stuff.
.27f4	20 2c 2a	jsr $2a2c			jsr 	FindVariable 				; does the variable exist already
.27f7	b0 0e		bcs $2807			bcs 	_AVFound
.27f9	ad 01 0b	lda $0b01			lda 	varType 					; is the variable type an array
.27fc	4a		lsr a				lsr 	a
.27fd	90 05		bcc $2804			bcc 	_AVCanCreate
.27ff	a2 15		ldx #$15			ldx 	#ErrorID_noauto
.2801	20 36 22	jsr $2236		jsr	errorHandler
.2804					_AVCanCreate:
.2804	20 eb 28	jsr $28eb			jsr 	CreateVariable 				; no, create it.
.2807					_AVFound:
.2807	68		pla				pla
.2808	aa		tax				tax
.2809	18		clc				clc 								; copy temp0 (variable record address)
.280a	a5 04		lda $04				lda 	temp0 						; +5 (to point to the data)
.280c	69 05		adc #$05			adc 	#5
.280e	95 48		sta $48,x			sta 	esInt0,x
.2810	a5 05		lda $05				lda 	temp0+1
.2812	69 00		adc #$00			adc 	#0
.2814	95 50		sta $50,x			sta 	esInt1,x
.2816	a9 00		lda #$00			lda 	#0
.2818	95 58		sta $58,x			sta 	esInt2,x
.281a	95 60		sta $60,x			sta 	esInt3,x
.281c	ac 01 0b	ldy $0b01			ldy 	varType 					; get the type ID from the type.
.281f	b9 f8 27	lda $27f8,y			lda 	_AVTypeTable-$3A,y
.2822	95 40		sta $40,x			sta 	esType,x
.2824	ac 02 0b	ldy $0b02			ldy 	varEnd 						; restore Y
.2827	ad 01 0b	lda $0b01			lda 	VarType 					; get variable type, put LSB into C
.282a	4a		lsr a				lsr 	a
.282b	90 03		bcc $2830			bcc 	_AVNotArray
.282d	20 75 28	jsr $2875			jsr 	AccessArray 				; array lookup. if LSB was set.
.2830					_AVNotArray:
.2830	8a		txa				txa 								; return stack in A and return
.2831	60		rts				rts
.2832					_AVTypeTable:
>2832	80 80						.byte 	$80,$80						; integer
>2834	c0 c0						.byte 	$C0,$C0 					; string
>2836	81 81						.byte 	$81,$81 					; float
.2838					AccessSetup:
.2838	a9 00		lda #$00			lda 	#0 							; zero the hash byte.
.283a	8d 00 0b	sta $0b00			sta 	varHash
.283d	98		tya				tya
.283e	48		pha				pha
.283f	b1 02		lda ($02),y	_ASLoop:lda 	(codePtr),y					; get next identifier character
.2841	c9 3a		cmp #$3a			cmp 	#$3A 						; is it 3A-3F which end all identifiers ?
.2843	b0 0b		bcs $2850			bcs 	_ASComplete
.2845	18		clc				clc 								; add to the hash. Might improve this.
.2846	6d 00 0b	adc $0b00			adc 	varHash
.2849	8d 00 0b	sta $0b00			sta 	varHash
.284c	c8		iny				iny 								; next character
.284d	4c 3f 28	jmp $283f			jmp 	_ASLoop
.2850					_ASComplete:
.2850	8d 01 0b	sta $0b01			sta 	varType 					; save variable type byte
.2853	c8		iny				iny
.2854	8c 02 0b	sty $0b02			sty 	varEnd 						; save the ending position.
.2857	38		sec				sec 								; convert type byte from $3A-$3F to 0..5
.2858	e9 3a		sbc #$3a			sbc 	#$3A
.285a	0a		asl a				asl 	a 							; multiply by hashTableSize (8 in this case)
.285b	0a		asl a				asl 	a
.285c	0a		asl a				asl 	a
.285d	0a		asl a				asl 	a 							; 2 bytes/word
.285e	85 04		sta $04				sta 	temp0 						; this is the offset to the start of the table.
.2860	ad 00 0b	lda $0b00			lda 	varHash 					; get hash
.2863	29 07		and #$07			and 	#(hashTableSize-1)			; force into range
.2865	0a		asl a				asl  	a 							; x 2 (for word) and CC
.2866	65 04		adc $04				adc 	temp0 						; now offset from the start of the hash table.
.2868	69 68		adc #$68			adc 	#hashTables & $FF 			; add to hash table base address
.286a	85 7c		sta $7c				sta 	hashList
.286c	a9 0a		lda #$0a			lda 	#hashTables >> 8
.286e	69 00		adc #$00			adc 	#0
.2870	85 7d		sta $7d				sta 	hashList+1
.2872	68		pla				pla
.2873	a8		tay				tay
.2874	60		rts				rts

;******  Return to file: variable/variable.asm


;******  Processing file: variable/accessarray.asm

.2875					AccessArray:
.2875	e8		inx				inx
.2876	8a		txa				txa
.2877	a2 04		ldx #$04		ldx	#4
.2879	20 e3 21	jsr $21e3		jsr	mainHandler
.287c	aa		tax				tax
.287d	ca		dex				dex
.287e	a2 00		ldx #$00		ldx	#0
.2880	20 e3 21	jsr $21e3		jsr	mainHandler
.2883	b5 61		lda $61,x			lda 	esInt3+1,x 					; check index value
.2885	15 59		ora $59,x			ora 	esInt2+1,x
.2887	d0 33		bne $28bc			bne 	_AABadIndex
.2889	98		tya				tya
.288a	48		pha				pha
.288b	b5 48		lda $48,x			lda 	esInt0,x 					; put array info ptr in temp0 - this points to the
.288d	85 04		sta $04				sta 	temp0 						; address (+0) max (+2) and size (+4)
.288f	b5 50		lda $50,x			lda 	esInt1,x
.2891	85 05		sta $05				sta 	temp0+1
.2893	a0 02		ldy #$02			ldy 	#2 							; check out of range, compare against max index.
.2895	b5 49		lda $49,x			lda 	esInt0+1,x
.2897	d1 04		cmp ($04),y			cmp 	(temp0),y
.2899	c8		iny				iny
.289a	b5 51		lda $51,x			lda 	esInt1+1,x
.289c	f1 04		sbc ($04),y			sbc 	(temp0),y
.289e	b0 1c		bcs $28bc			bcs 	_AABadIndex 				; if >= then fail.
.28a0	e8		inx				inx 								; point to index
.28a1	a0 04		ldy #$04			ldy 	#4 							; get the size byte.
.28a3	b1 04		lda ($04),y			lda 	(temp0),y
.28a5	20 c1 28	jsr $28c1			jsr 	MultiplyTOSByA 				; specialist multiplier.
.28a8	ca		dex				dex
.28a9	a0 00		ldy #$00			ldy 	#0 							; add this to the array base as the new address
.28ab	18		clc				clc
.28ac	b5 49		lda $49,x			lda 	esInt0+1,x
.28ae	71 04		adc ($04),y			adc 	(temp0),y
.28b0	95 48		sta $48,x			sta 	esInt0,x
.28b2	b5 51		lda $51,x			lda 	esInt1+1,x
.28b4	c8		iny				iny
.28b5	71 04		adc ($04),y			adc 	(temp0),y
.28b7	95 50		sta $50,x			sta 	esInt1,x
.28b9	68		pla				pla
.28ba	a8		tay				tay
.28bb	60		rts				rts
.28bc					_AABadIndex:
.28bc	a2 1b		ldx #$1b			ldx 	#ErrorID_ArrayIndex
.28be	20 36 22	jsr $2236		jsr	errorHandler
.28c1					MultiplyTOSByA:
.28c1	48		pha				pha
.28c2	b5 48		lda $48,x			lda 	esInt0,x 					; copy index to temp1
.28c4	85 06		sta $06				sta 	temp1
.28c6	b5 50		lda $50,x			lda 	esInt1,x
.28c8	85 07		sta $07				sta 	temp1+1
.28ca	68		pla				pla
.28cb	16 48		asl $48,x			asl 	esInt0,x 					; double it.
.28cd	36 50		rol $50,x			rol 	esInt1,x
.28cf	c9 02		cmp #$02			cmp 	#2 							; if x 2 then exit.
.28d1	f0 17		beq $28ea			beq 	_MTBAExit
.28d3	c9 06		cmp #$06			cmp 	#6 							; if x 6 then add temp1 to index
.28d5	d0 0f		bne $28e6			bne 	_MTBANotFloat
.28d7	48		pha				pha
.28d8	18		clc				clc 								; so this will make it x 3
.28d9	b5 48		lda $48,x			lda 	esInt0,x
.28db	65 06		adc $06				adc 	temp1
.28dd	95 48		sta $48,x			sta 	esInt0,x
.28df	b5 50		lda $50,x			lda 	esInt1,x
.28e1	65 07		adc $07				adc 	temp1+1
.28e3	95 50		sta $50,x			sta 	esInt1,x
.28e5	68		pla				pla
.28e6					_MTBANotFloat:
.28e6	16 48		asl $48,x			asl 	esInt0,x					; now it is x 4 or x 6
.28e8	36 50		rol $50,x			rol 	esInt1,x
.28ea					_MTBAExit:
.28ea	60		rts				rts

;******  Return to file: variable/variable.asm


;******  Processing file: variable/create.asm

.28eb					CreateVariable:
.28eb	98		tya				tya 								; push Y on the stack twice.
.28ec	48		pha				pha
.28ed	48		pha				pha
.28ee	ae 01 0b	ldx $0b01			ldx 	varType 					; get var type 0-5
.28f1	bd fc 28	lda $28fc,x			lda		_CVSize-$3A,x 				; the bytes for this new variable.
.28f4	48		pha				pha 								; save length
.28f5	a5 0f		lda $0f				lda 	lowMemory 					; set low Memory ptr to temp0
.28f7	85 04		sta $04				sta 	temp0 						; (address of the new variable)
.28f9	a5 10		lda $10				lda 	lowMemory+1
.28fb	85 05		sta $05				sta 	temp0+1
.28fd	68		pla				pla 								; get length
.28fe	20 73 10	jsr $1073			jsr 	AdvanceLowMemoryByte 		; shift alloc memory forward by the length.
.2901	ad 00 0b	lda $0b00			lda 	varHash 					; store hash at offset 4.
.2904	a0 04		ldy #$04			ldy 	#4
.2906	91 04		sta ($04),y			sta 	(temp0),y
.2908	68		pla				pla 								; offset, work out where the variable name is.
.2909	18		clc				clc
.290a	65 02		adc $02				adc 	codePtr
.290c	a0 02		ldy #$02			ldy 	#2 							; copy that into slots 2 + 3.
.290e	91 04		sta ($04),y			sta 	(temp0),y
.2910	a5 03		lda $03				lda 	codePtr+1
.2912	69 00		adc #$00			adc 	#0
.2914	c8		iny				iny
.2915	91 04		sta ($04),y			sta 	(temp0),y
.2917	a0 00		ldy #$00			ldy 	#0 							; copy current hash pointer in link
.2919	b1 7c		lda ($7c),y			lda 	(hashList),y
.291b	91 04		sta ($04),y			sta 	(temp0),y
.291d	c8		iny				iny
.291e	b1 7c		lda ($7c),y			lda 	(hashList),y
.2920	91 04		sta ($04),y			sta 	(temp0),y
.2922	a5 05		lda $05				lda 	temp0+1 					; set new link
.2924	91 7c		sta ($7c),y			sta 	(hashList),y
.2926	88		dey				dey
.2927	a5 04		lda $04				lda 	temp0
.2929	91 7c		sta ($7c),y			sta 	(hashList),y
.292b	ad 01 0b	lda $0b01			lda 	varType 					; type in A
.292e	a0 05		ldy #$05			ldy 	#5 							; offset in Y
.2930	20 3c 29	jsr $293c			jsr 	ZeroTemp0Y 					; zero (temp0),y with whatever type.
.2933	68		pla				pla
.2934	a8		tay				tay
.2935	60		rts				rts
>2936	09 0a				_CVSize:.byte 	VarHSize+VarISize,VarHSize+VarASize 					; <storage for integer>
>2938	07 0a						.byte 	VarHSize+VarSSize,VarHSize+VarASize 					; <storage for string>
>293a	0b 0a						.byte 	VarHSize+VarFSize,VarHSize+VarASize 					; <storage for float>
.293c					ZeroTemp0Y:
.293c	4a		lsr a				lsr 	a 							; bit 0 in carry
.293d	0a		asl a				asl 	a
.293e	b0 19		bcs $2959			bcs 	_ZTExit 					; we don't initialise arrays.
.2940	c9 3c		cmp #$3c			cmp 	#$3C 						; check string
.2942	f0 16		beq $295a			beq 	_ZTWriteNullString 			; write "" string
.2944	c9 3e		cmp #$3e			cmp 	#$3E 						; check float
.2946	f0 22		beq $296a			beq 	_ZTWriteFloat
.2948	98		tya				tya
.2949	48		pha				pha
.294a	a9 00		lda #$00			lda 	#0
.294c	91 04		sta ($04),y			sta 	(temp0),y
.294e	c8		iny				iny
.294f	91 04		sta ($04),y			sta 	(temp0),y
.2951	c8		iny				iny
.2952	91 04		sta ($04),y			sta 	(temp0),y
.2954	c8		iny				iny
.2955	91 04		sta ($04),y			sta 	(temp0),y
.2957	68		pla				pla
.2958	a8		tay				tay
.2959					_ZTExit:
.2959	60		rts				rts
.295a					_ZTWriteNullString:
.295a	a9 00		lda #$00			lda 	#0 							; put a reference to null string as the default value.
.295c	8d cc 0a	sta $0acc			sta 	NullString
.295f	a9 cc		lda #$cc			lda 	#NullString & $FF
.2961	91 04		sta ($04),y			sta 	(temp0),y
.2963	a9 0a		lda #$0a			lda 	#NullString >> 8
.2965	c8		iny				iny
.2966	91 04		sta ($04),y			sta 	(temp0),y
.2968	88		dey				dey
.2969	60		rts				rts
.296a					_ZTWriteFloat:
.296a	8a		txa				txa
.296b	48		pha				pha
.296c	a2 1e		ldx #$1e		ldx	#30
.296e	20 21 25	jsr $2521		jsr	floatingpointHandler
.2971	68		pla				pla
.2972	aa		tax				tax
.2973	60		rts				rts

;******  Return to file: variable/variable.asm


;******  Processing file: variable/createarray.asm

.2974					CreateArray:
.2974	20 38 28	jsr $2838			jsr 	AccessSetup 				; set up the basic stuff.
.2977	ad 01 0b	lda $0b01			lda 	varType 					; is the variable type an array
.297a	4a		lsr a				lsr 	a
.297b	90 3f		bcc $29bc			bcc 	_CANotArray 				; no, cause an error.
.297d	20 2c 2a	jsr $2a2c			jsr 	FindVariable 				; does the variable exist already
.2980	b0 35		bcs $29b7			bcs 	_CAFound 					; cannot redefine it.
.2982	20 eb 28	jsr $28eb			jsr 	CreateVariable 				; create the variable entry.
.2985	ac 02 0b	ldy $0b02			ldy 	varEnd 						; point Y to the end of the variable entry.
.2988	a5 04		lda $04				lda 	temp0 						; push address of new variable entry on the stack
.298a	48		pha				pha
.298b	a5 05		lda $05				lda 	temp0+1
.298d	48		pha				pha
.298e	ad 01 0b	lda $0b01			lda 	varType 					; push variable type on the stack.
.2991	48		pha				pha
.2992	a9 00		lda #$00			lda 	#0 							; work out the array dimension on TOS.
.2994	a2 04		ldx #$04		ldx	#4
.2996	20 e3 21	jsr $21e3		jsr	mainHandler
.2999	a2 00		ldx #$00		ldx	#0
.299b	20 e3 21	jsr $21e3		jsr	mainHandler
.299e	68		pla				pla 		 						; restore type and position.
.299f	8d 01 0b	sta $0b01			sta 	varType
.29a2	68		pla				pla
.29a3	85 05		sta $05				sta 	temp0+1
.29a5	68		pla				pla
.29a6	85 04		sta $04				sta 	temp0
.29a8	a5 50		lda $50				lda 	esInt1 						; limit array max to 4096.
.29aa	29 e0		and #$e0			and 	#$E0
.29ac	05 58		ora $58				ora 	esInt2
.29ae	05 60		ora $60				ora 	esInt3
.29b0	f0 0f		beq $29c1			beq 	_CASizeOk
.29b2					_CASize:
.29b2	a2 08		ldx #$08			ldx 	#ErrorID_BadValue
.29b4	20 36 22	jsr $2236		jsr	errorHandler
.29b7					_CAFound:
.29b7	a2 19		ldx #$19			ldx 	#ErrorID_DupArray
.29b9	20 36 22	jsr $2236		jsr	errorHandler
.29bc					_CANotArray:
.29bc	a2 1a		ldx #$1a			ldx 	#ErrorID_NotArray
.29be	20 36 22	jsr $2236		jsr	errorHandler
.29c1					_CASizeOk:
.29c1	e6 48		inc $48				inc 	esInt0 						; bump it by one, as we index from 0
.29c3	d0 02		bne $29c7			bne 	_CANoCarry 					; e.g. DIM A(10) ... A(0) - A(10)
.29c5	e6 49		inc $49				inc 	esInt0+1
.29c7					_CANoCarry:
.29c7	98		tya				tya
.29c8	48		pha				pha
.29c9	a0 05		ldy #$05			ldy 	#5
.29cb	a5 0f		lda $0f				lda 	lowMemory 					; copy low memory address in +5,+6
.29cd	91 04		sta ($04),y			sta 	(temp0),y 					; this is where it will come from
.29cf	c8		iny				iny
.29d0	a5 10		lda $10				lda 	lowMemory+1
.29d2	91 04		sta ($04),y			sta 	(temp0),y
.29d4	c8		iny				iny
.29d5	a5 48		lda $48				lda 	esInt0 						; copy maximum index value to +7,+8
.29d7	91 04		sta ($04),y			sta 	(temp0),y
.29d9	c8		iny				iny
.29da	a5 50		lda $50				lda 	esInt1
.29dc	91 04		sta ($04),y			sta 	(temp0),y
.29de	c8		iny				iny
.29df	ae 01 0b	ldx $0b01			ldx 	varType 					; get the length per element
.29e2	bd ea 29	lda $29ea,x			lda 	_CAActualSize-$3A-1,x
.29e5	91 04		sta ($04),y			sta 	(temp0),y
.29e7	aa		tax				tax 								; save size in X
.29e8	a5 0f		lda $0f				lda 	lowMemory 					; set temp0 to low memory.
.29ea	85 04		sta $04				sta 	temp0
.29ec	a5 10		lda $10				lda 	lowMemory+1
.29ee	85 05		sta $05				sta 	temp0+1
.29f0	a9 00		lda #$00			lda 	#0 							; temp1 is the counter.
.29f2	85 06		sta $06				sta 	temp1
.29f4	85 07		sta $07				sta 	temp1+1
.29f6					_CAInitialiseArray:
.29f6	a0 00		ldy #$00			ldy 	#0 							; write a null record at temp0
.29f8	ad 01 0b	lda $0b01			lda 	varType 					; base type of array in A.
.29fb	29 fe		and #$fe			and 	#$FE
.29fd	20 3c 29	jsr $293c			jsr 	ZeroTemp0Y
.2a00	8a		txa				txa 								; add X to temp0, also updating lowMemory
.2a01	18		clc				clc
.2a02	65 04		adc $04				adc 	temp0
.2a04	85 04		sta $04				sta 	temp0
.2a06	85 0f		sta $0f				sta 	lowMemory
.2a08	a5 05		lda $05				lda 	temp0+1
.2a0a	69 00		adc #$00			adc 	#0
.2a0c	85 05		sta $05				sta 	temp0+1
.2a0e	85 10		sta $10				sta 	lowMemory+1
.2a10	e6 06		inc $06				inc 	temp1 						; bump the counter.
.2a12	d0 02		bne $2a16			bne 	_CAIANoCarry
.2a14	e6 07		inc $07				inc 	temp1+1
.2a16					_CAIANoCarry:
.2a16	a5 48		lda $48				lda 	esInt0 						; counter reached max index
.2a18	c5 06		cmp $06				cmp 	temp1
.2a1a	d0 da		bne $29f6			bne 	_CAInitialiseArray
.2a1c	a5 50		lda $50				lda 	esInt1
.2a1e	c5 07		cmp $07				cmp 	temp1+1
.2a20	d0 d4		bne $29f6			bne 	_CAInitialiseArray
.2a22	68		pla				pla
.2a23	a8		tay				tay
.2a24	60		rts				rts
.2a25					_CAActualSize:
>2a25	04 00						.byte 	VarISize,0
>2a27	02 00						.byte 	VarSSize,0
>2a29	06 00						.byte 	VarFSize,0
>2a2b	db						.byte 	$DB

;******  Return to file: variable/variable.asm


;******  Processing file: variable/find.asm

.2a2c					FindVariable:
.2a2c	98		tya				tya
.2a2d	48		pha				pha
.2a2e	98		tya				tya 								; point temp2 to the actual name.
.2a2f	18		clc				clc
.2a30	65 02		adc $02				adc 	codePtr
.2a32	85 08		sta $08				sta 	temp2
.2a34	a5 03		lda $03				lda 	codePtr+1
.2a36	69 00		adc #$00			adc 	#0
.2a38	85 09		sta $09				sta 	temp2+1
.2a3a	a0 00		ldy #$00			ldy 	#0
.2a3c	a5 7c		lda $7c				lda 	hashList 					; copy hashlist to temp0
.2a3e	85 04		sta $04				sta 	temp0
.2a40	a5 7d		lda $7d				lda 	hashList+1
.2a42	85 05		sta $05				sta 	temp0+1
.2a44	a0 01		ldy #$01	_FVNext:ldy 	#1 							; get MSB
.2a46	b1 04		lda ($04),y			lda 	(temp0),y
.2a48	f0 2c		beq $2a76			beq 	_FVFail
.2a4a	aa		tax				tax
.2a4b	88		dey				dey		 							; get LSB
.2a4c	b1 04		lda ($04),y			lda 	(temp0),y
.2a4e	85 04		sta $04				sta 	temp0 						; update pointer.
.2a50	86 05		stx $05				stx 	temp0+1
.2a52	a0 04		ldy #$04			ldy 	#4 							; check hashes match
.2a54	b1 04		lda ($04),y			lda 	(temp0),y
.2a56	cd 00 0b	cmp $0b00			cmp 	varHash
.2a59	d0 e9		bne $2a44			bne 	_FVNext 					; if not, no point in checking the name.
.2a5b	88		dey				dey 								; copy name pointer to temp1.
.2a5c	b1 04		lda ($04),y			lda 	(temp0),y
.2a5e	85 07		sta $07				sta 	temp1+1
.2a60	88		dey				dey
.2a61	b1 04		lda ($04),y			lda 	(temp0),y
.2a63	85 06		sta $06				sta 	temp1
.2a65	a0 00		ldy #$00			ldy 	#0
.2a67					_FVCheck:
.2a67	b1 06		lda ($06),y			lda 	(temp1),y 					; compare names
.2a69	d1 08		cmp ($08),y			cmp 	(temp2),y
.2a6b	d0 d7		bne $2a44			bne 	_FVNext		 				; fail if different.
.2a6d	c8		iny				iny
.2a6e	c9 3a		cmp #$3a			cmp 	#$3A 						; until reached the end marker.
.2a70	90 f5		bcc $2a67			bcc 	_FVCheck
.2a72	68		pla				pla
.2a73	a8		tay				tay
.2a74	38		sec				sec
.2a75	60		rts				rts
.2a76					_FVFail:
.2a76	68		pla				pla
.2a77	a8		tay				tay
.2a78	18		clc				clc
.2a79	60		rts				rts

;******  Return to file: variable/variable.asm


;******  Processing file: variable/reset.asm

.2a7a					HashTableReset:
.2a7a	a2 60		ldx #$60			ldx 	#6*2*hashTableSize
.2a7c	a9 00		lda #$00			lda 	#0
.2a7e					_HTRClear:
.2a7e	9d 67 0a	sta $0a67,x			sta 	hashTables-1,x
.2a81	ca		dex				dex
.2a82	d0 fa		bne $2a7e			bne 	_HTRClear
.2a84	60		rts				rts

;******  Return to file: variable/variable.asm

.2a85					variableHandler:
.2a85	7c 88 2a	jmp ($2a88,x)			jmp 	(variableVectors,x)
.2a88					variableVectors:
>2a88	d1 27					.word AccessVariable       ; index 0
>2a8a	74 29					.word CreateArray          ; index 2
>2a8c	7a 2a					.word HashTableReset       ; index 4

;******  Return to file: basic.asm

.2a8e					section_end_variable:

;******  End of listing

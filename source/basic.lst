
; 64tass Turbo Assembler Macro V1.55.2200 listing file
; 64tass -q -c -L basic.lst -l basic.lbl -Wall -o basic.prg ..\source\basic.asm
; Tue Feb 23 15:52:30 2021

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: ..\source\basic.asm


;******  Processing file: ..\source\main/01common.inc

=8					StackSize = 8

;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\main/02macros.inc


;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\main/03data.inc

>0002					codePtr:.fill 	2							; (codePtr),y points to code.
>0004					temp0: 	.fill 	2							; working variables.
>0006					temp1: 	.fill 	2
>0008					temp2: 	.fill 	2
.000a					tempShort:
>000a							.fill 	1
>0040					esType:	.fill 	StackSize
>0048					esInt0:	.fill 	StackSize
>0050					esInt1:	.fill 	StackSize
>0058					esInt2:	.fill 	StackSize
>0060					esInt3:	.fill 	StackSize
>0068					esExp:	.fill 	StackSize
=$48					esMant0 = esInt0
=$50					esMant1 = esInt1
=$58					esMant2 = esInt2
=$60					esMant3 = esInt3

;******  Processing file: ..\source\main/../generated/tokenconst.inc

=$80					TOK_EOL=$80
=$81					TOK_SHIFT1=$81
=$82					TOK_SHIFT2=$82
=$83					TOK_SHIFT3=$83
=$84					TOK_FPC=$84
=$85					TOK_STR=$85
=$86					TOK_BINARYST=$86
=$9d					TOK_STRUCTST=$9d
=$a2					TOK_UNARYST=$a2
=$c0					TOK_TOKENS=$c0
=$86					TKW_AND                      = $86 ; and
=$87					TKW_OR                       = $87 ; or
=$88					TKW_XOR                      = $88 ; xor
=$89					TKW_GREATEREQUAL             = $89 ; >=
=$8a					TKW_LESSEQUAL                = $8a ; <=
=$8b					TKW_GREATER                  = $8b ; >
=$8c					TKW_LESS                     = $8c ; <
=$8d					TKW_EQUAL                    = $8d ; =
=$8e					TKW_LESSGREATER              = $8e ; <>
=$8f					TKW_PLUS                     = $8f ; +
=$90					TKW_MINUS                    = $90 ; -
=$91					TKW_GREATERGREATER           = $91 ; >>
=$92					TKW_LESSLESS                 = $92 ; <<
=$93					TKW_STAR                     = $93 ; *
=$94					TKW_SLASH                    = $94 ; /
=$95					TKW_MOD                      = $95 ; mod
=$96					TKW_HAT                      = $96 ; ^
=$97					TKW_PLING                    = $97 ; !
=$98					TKW_QMARK                    = $98 ; ?
=$99					TKW_REPEAT                   = $99 ; repeat
=$9a					TKW_WHILE                    = $9a ; while
=$9b					TKW_FOR                      = $9b ; for
=$9c					TKW_IF                       = $9c ; if
=$9d					TKW_UNTIL                    = $9d ; until
=$9e					TKW_WEND                     = $9e ; wend
=$9f					TKW_NEXT                     = $9f ; next
=$a0					TKW_THEN                     = $a0 ; then
=$a1					TKW_ENDIF                    = $a1 ; endif
=$a2					TKW_WAVY                     = $a2 ; ~
=$a3					TKW_LPAREN                   = $a3 ; (
=$a4					TKW_AMP                      = $a4 ; &
=$a5					TKW_AT                       = $a5 ; @
=$a6					TKW_LENLPAREN                = $a6 ; len(
=$a7					TKW_SGNLPAREN                = $a7 ; sgn(
=$a8					TKW_ABSLPAREN                = $a8 ; abs(
=$a9					TKW_RANDOMLPAREN             = $a9 ; random(
=$aa					TKW_PAGE                     = $aa ; page
=$ab					TKW_TRUE                     = $ab ; true
=$ac					TKW_FALSE                    = $ac ; false
=$ad					TKW_MINLPAREN                = $ad ; min(
=$ae					TKW_MAXLPAREN                = $ae ; max(
=$af					TKW_SYSLPAREN                = $af ; sys(
=$b0					TKW_TIMERLPAREN              = $b0 ; timer(
=$b1					TKW_EVENTLPAREN              = $b1 ; event(
=$b2					TKW_GETLPAREN                = $b2 ; get(
=$b3					TKW_INKEYLPAREN              = $b3 ; inkey(
=$b4					TKW_ALLOCLPAREN              = $b4 ; alloc(
=$b5					TKW_CHRDOLLARLPAREN          = $b5 ; chr$(
=$b6					TKW_LEFTDOLLARLPAREN         = $b6 ; left$(
=$b7					TKW_MIDDOLLARLPAREN          = $b7 ; mid$(
=$b8					TKW_RIGHTDOLLARLPAREN        = $b8 ; right$(
=$b9					TKW_STRDOLLARLPAREN          = $b9 ; str$(
=$ba					TKW_VALLPAREN                = $ba ; val(
=$bb					TKW_PEEKLPAREN               = $bb ; peek(
=$bc					TKW_DEEKLPAREN               = $bc ; deek(
=$bd					TKW_LEEKLPAREN               = $bd ; leek(
=$be					TKW_INTLPAREN                = $be ; int(
=$bf					TKW_FLOATLPAREN              = $bf ; float(
=$c0					TKW_RPAREN                   = $c0 ; )
=$c1					TKW_COLON                    = $c1 ; :
=$c2					TKW_COMMA                    = $c2 ; ,
=$c3					TKW_SEMICOLON                = $c3 ; ;
=$c4					TKW_RSQPAREN                 = $c4 ; ]
=$c5					TKW_TO                       = $c5 ; to
=$c6					TKW_STEP                     = $c6 ; step
=$c7					TKW_PROC                     = $c7 ; proc
=$c8					TKW_ENDPROC                  = $c8 ; endproc
=$c9					TKW_LOCAL                    = $c9 ; local
=$ca					TKW_REM                      = $ca ; rem
=$cb					TKW_LET                      = $cb ; let
=$cc					TKW_QUOTE                    = $cc ; '
=$cd					TKW_LSQPAREN                 = $cd ; [
=$ce					TKW_INPUT                    = $ce ; input
=$cf					TKW_ELSE                     = $cf ; else
=$d0					TKW_VDU                      = $d0 ; vdu
=$d1					TKW_READ                     = $d1 ; read
=$d2					TKW_DATA                     = $d2 ; data
=$d3					TKW_RESTORE                  = $d3 ; restore
=$d4					TKW_PRINT                    = $d4 ; print
=$d5					TKW_GOTO                     = $d5 ; goto
=$d6					TKW_GOSUB                    = $d6 ; gosub
=$d7					TKW_RETURN                   = $d7 ; return
=$d8					TKW_ASSERT                   = $d8 ; assert
=$d9					TKW_STOP                     = $d9 ; stop
=$da					TKW_END                      = $da ; end
=$db					TKW_DIM                      = $db ; dim
=$dc					TKW_POKE                     = $dc ; poke
=$dd					TKW_DOKE                     = $dd ; doke
=$de					TKW_LOKE                     = $de ; loke
=$86					TKW_CLEAR                    = $86 ; clear
=$87					TKW_LOAD                     = $87 ; load
=$88					TKW_SAVE                     = $88 ; save
=$89					TKW_LIST                     = $89 ; list
=$8a					TKW_NEW                      = $8a ; new
=$8b					TKW_RUN                      = $8b ; run
=$8c					TKW_CODE                     = $8c ; code
=$8d					TKW_OPTION                   = $8d ; option
=$86					TKW_VPOKE                    = $86 ; vpoke
=$86					TKW_VPEEKLPAREN              = $86 ; vpeek(

;******  Return to file: ..\source\main/03data.inc


;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\main/imath/intmacros.inc


;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\main/main.inc


;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\assembler/assembler.inc


;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\device/device.inc


;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\error/error.inc


;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\error/errorhandler.inc


;******  Processing file: ..\source\error/../generated/errorid.inc

=1					ErrorID_Syntax = 1 ; Syntax Error
=2					ErrorID_DivZero = 2 ; Divide By Zero
=3					ErrorID_Stop = 3 ; Stop
=4					ErrorID_BadType = 4 ; BadType

;******  Return to file: ..\source\error/errorhandler.inc


;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\floatingpoint/floatingpoint.inc


;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\interaction/interaction.inc


;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\string/string.inc


;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\tokeniser/tokeniser.inc


;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\variable/variable.inc


;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\main/main.asm


;******  Processing file: ..\source\main/00start.asm

.1000					Start:
.1000	a9 19		lda #$19			lda 	#(TestCode) & $FF
.1002	85 02		sta $02				sta 	codePtr
.1004	a9 10		lda #$10			lda 	#(TestCode) >> 8
.1006	85 03		sta $03				sta 	1+(codePtr)
.1008	a0 00		ldy #$00			ldy 	#0
.100a	a9 00		lda #$00			lda 	#0
.100c	a2 00		ldx #$00			ldx 	#0
.100e	20 e0 12	jsr $12e0			jsr 	EvaluateLevel
>1011	db						.byte 	$DB
.1012	4c 12 10	jmp $1012	halt:	jmp 	halt
.1015					Unimplemented:
>1015	db						.byte 	$DB
.1016	4c 15 10	jmp $1015			jmp 	Unimplemented

;******  Processing file: ..\source\main/../generated/testcode.inc

.1019					TestCode:
>1019	7f 7f 98 41 80				.byte 127,127,152,65,128

;******  Return to file: ..\source\main/00start.asm


;******  Processing file: ..\source\main/../generated/tokenvectors0.inc

.101e					Group0Vectors:
>101e	15 10					.word	Unimplemented            ; $80 [[eol]]
>1020	15 10					.word	Unimplemented            ; $81 [[sh1]]
>1022	15 10					.word	Unimplemented            ; $82 [[sh2]]
>1024	15 10					.word	Unimplemented            ; $83 [[sh3]]
>1026	15 10					.word	Unimplemented            ; $84 [[fpc]]
>1028	15 10					.word	Unimplemented            ; $85 [[str]]
>102a	a4 11					.word	AndHandler               ; $86 and
>102c	91 11					.word	OrHandler                ; $87 or
>102e	7e 11					.word	XorHandler               ; $88 xor
>1030	bb 12					.word	CompareGreaterEq         ; $89 >=
>1032	c5 12					.word	CompareLessEq            ; $8a <=
>1034	a7 12					.word	CompareGreater           ; $8b >
>1036	9d 12					.word	CompareLess              ; $8c <
>1038	93 12					.word	CompareEquals            ; $8d =
>103a	b1 12					.word	CompareNotEquals         ; $8e <>
>103c	0f 11					.word	AddHandler               ; $8f +
>103e	32 11					.word	SubHandler               ; $90 -
>1040	ca 11					.word	ShrHandler               ; $91 >>
>1042	b7 11					.word	ShlHandler               ; $92 <<
>1044	45 11					.word	MulHandler               ; $93 *
>1046	58 11					.word	DivHandler               ; $94 /
>1048	6b 11					.word	ModHandler               ; $95 mod
>104a	03 12					.word	PowerHandler             ; $96 ^
>104c	dd 11					.word	WordRefHandler           ; $97 !
>104e	f0 11					.word	ByteRefHandler           ; $98 ?
>1050	15 10					.word	Unimplemented            ; $99 repeat
>1052	15 10					.word	Unimplemented            ; $9a while
>1054	15 10					.word	Unimplemented            ; $9b for
>1056	15 10					.word	Unimplemented            ; $9c if
>1058	15 10					.word	Unimplemented            ; $9d until
>105a	15 10					.word	Unimplemented            ; $9e wend
>105c	15 10					.word	Unimplemented            ; $9f next
>105e	15 10					.word	Unimplemented            ; $a0 then
>1060	15 10					.word	Unimplemented            ; $a1 endif
>1062	15 10					.word	Unimplemented            ; $a2 ~
>1064	15 10					.word	Unimplemented            ; $a3 (
>1066	15 10					.word	Unimplemented            ; $a4 &
>1068	15 10					.word	Unimplemented            ; $a5 @
>106a	15 10					.word	Unimplemented            ; $a6 len(
>106c	15 10					.word	Unimplemented            ; $a7 sgn(
>106e	15 10					.word	Unimplemented            ; $a8 abs(
>1070	15 10					.word	Unimplemented            ; $a9 random(
>1072	15 10					.word	Unimplemented            ; $aa page
>1074	15 10					.word	Unimplemented            ; $ab true
>1076	15 10					.word	Unimplemented            ; $ac false
>1078	15 10					.word	Unimplemented            ; $ad min(
>107a	15 10					.word	Unimplemented            ; $ae max(
>107c	15 10					.word	Unimplemented            ; $af sys(
>107e	15 10					.word	Unimplemented            ; $b0 timer(
>1080	15 10					.word	Unimplemented            ; $b1 event(
>1082	15 10					.word	Unimplemented            ; $b2 get(
>1084	15 10					.word	Unimplemented            ; $b3 inkey(
>1086	15 10					.word	Unimplemented            ; $b4 alloc(
>1088	15 10					.word	Unimplemented            ; $b5 chr$(
>108a	15 10					.word	Unimplemented            ; $b6 left$(
>108c	15 10					.word	Unimplemented            ; $b7 mid$(
>108e	15 10					.word	Unimplemented            ; $b8 right$(
>1090	15 10					.word	Unimplemented            ; $b9 str$(
>1092	15 10					.word	Unimplemented            ; $ba val(
>1094	15 10					.word	Unimplemented            ; $bb peek(
>1096	15 10					.word	Unimplemented            ; $bc deek(
>1098	15 10					.word	Unimplemented            ; $bd leek(
>109a	15 10					.word	Unimplemented            ; $be int(
>109c	15 10					.word	Unimplemented            ; $bf float(
>109e	15 10					.word	Unimplemented            ; $c0 )
>10a0	15 10					.word	Unimplemented            ; $c1 :
>10a2	15 10					.word	Unimplemented            ; $c2 ,
>10a4	15 10					.word	Unimplemented            ; $c3 ;
>10a6	15 10					.word	Unimplemented            ; $c4 ]
>10a8	15 10					.word	Unimplemented            ; $c5 to
>10aa	15 10					.word	Unimplemented            ; $c6 step
>10ac	15 10					.word	Unimplemented            ; $c7 proc
>10ae	15 10					.word	Unimplemented            ; $c8 endproc
>10b0	15 10					.word	Unimplemented            ; $c9 local
>10b2	15 10					.word	Unimplemented            ; $ca rem
>10b4	15 10					.word	Unimplemented            ; $cb let
>10b6	15 10					.word	Unimplemented            ; $cc '
>10b8	15 10					.word	Unimplemented            ; $cd [
>10ba	15 10					.word	Unimplemented            ; $ce input
>10bc	15 10					.word	Unimplemented            ; $cf else
>10be	15 10					.word	Unimplemented            ; $d0 vdu
>10c0	15 10					.word	Unimplemented            ; $d1 read
>10c2	15 10					.word	Unimplemented            ; $d2 data
>10c4	15 10					.word	Unimplemented            ; $d3 restore
>10c6	15 10					.word	Unimplemented            ; $d4 print
>10c8	15 10					.word	Unimplemented            ; $d5 goto
>10ca	15 10					.word	Unimplemented            ; $d6 gosub
>10cc	15 10					.word	Unimplemented            ; $d7 return
>10ce	15 10					.word	Unimplemented            ; $d8 assert
>10d0	15 10					.word	Unimplemented            ; $d9 stop
>10d2	15 10					.word	Unimplemented            ; $da end
>10d4	15 10					.word	Unimplemented            ; $db dim
>10d6	15 10					.word	Unimplemented            ; $dc poke
>10d8	15 10					.word	Unimplemented            ; $dd doke
>10da	15 10					.word	Unimplemented            ; $de loke

;******  Return to file: ..\source\main/00start.asm


;******  Return to file: ..\source\main/main.asm


;******  Processing file: ..\source\main/evaluate/binary.asm

.10e3					BinaryProcess:
.10e3	b5 40		lda $40,x			lda 	esType,x 					; or type bytes together and check bit 6.
.10e5	15 41		ora $41,x			ora 	esType+1,x
.10e7	0a		asl a				asl 	a
.10e8	30 0e		bmi $10f8			bmi 	_BPStringType 				; if one is set, then string type.
.10ea	18		clc				clc 								; return CC for integer
.10eb	29 02		and #$02			and 	#$02 						; $02 because of ASL A.
.10ed	f0 08		beq $10f7			beq 	_BPExit 					; if both integer then return with CC.
.10ef	20 fd 10	jsr $10fd			jsr 	BPMakeBothFloat 			; make both float
.10f2	a9 01		lda #$01			lda 	#$01 						; set result type to float
.10f4	95 40		sta $40,x			sta 	esType,x
.10f6	38		sec				sec 								; and return with carry set.
.10f7					_BPExit:
.10f7	60		rts				rts
.10f8					_BPStringType:
.10f8	a2 04		ldx #$04			ldx 	#ErrorID_BadType
.10fa	20 dc 10	jsr $10dc			jsr 	ErrorHandler
.10fd					BPMakeBothFloat:
.10fd	e8		inx				inx
.10fe	20 02 11	jsr $1102			jsr 	BPMakeFloat 				; one is a float, so we do both as floats.
.1101	ca		dex				dex
.1102					BPMakeFloat:
.1102	b5 40		lda $40,x			lda 	esType,x 					; get type bit.
.1104	4a		lsr a				lsr 	a
.1105	b0 07		bcs $110e			bcs 	_BPIsFloat
.1107	8a		txa				txa
.1108	a2 12		ldx #$12		ldx	#18
.110a	20 dc 16	jsr $16dc		jsr	floatingpointHandler
.110d	aa		tax				tax
.110e					_BPIsFloat:
.110e	60		rts				rts
.110f					AddHandler:
.110f	20 d5 12	jsr $12d5			jsr 	DereferenceTwo 				; dereference top two on stack.
.1112	b5 40		lda $40,x			lda 	esType,x 					; check two strings.
.1114	35 41		and $41,x			and 	esType+1,x
.1116	29 40		and #$40			and 	#$40 						; if both have bit 6 set ...
.1118	d0 10		bne $112a			bne 	_AHStringConcat				; concatenate strings.
.111a	20 e3 10	jsr $10e3			jsr 	BinaryProcess 				; check to see if either is float
.111d	b0 03		bcs $1122			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.111f	4c 38 15	jmp $1538			jmp 	MInt32Add 							; else do it as integer.
.1122					_IsFPOperation:
.1122	8a		txa				txa 								; call the relevant fp routine
.1123	a2 00		ldx #$00		ldx	#0
.1125	20 dc 16	jsr $16dc		jsr	floatingpointHandler
.1128	aa		tax				tax
.1129	60		rts				rts
.112a					_AHStringConcat:
.112a	8a		txa				txa
.112b	a2 00		ldx #$00		ldx	#0
.112d	20 fd 16	jsr $16fd		jsr	stringHandler
.1130	aa		tax				tax
.1131	60		rts				rts
.1132					SubHandler:
.1132	20 d5 12	jsr $12d5			jsr 	DereferenceTwo
.1135	20 e3 10	jsr $10e3			jsr 	BinaryProcess 				; check to see if either is float
.1138	b0 03		bcs $113d			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.113a	4c 52 15	jmp $1552			jmp 	MInt32Sub 							; else do it as integer.
.113d					_IsFPOperation:
.113d	8a		txa				txa 								; call the relevant fp routine
.113e	a2 0a		ldx #$0a		ldx	#10
.1140	20 dc 16	jsr $16dc		jsr	floatingpointHandler
.1143	aa		tax				tax
.1144	60		rts				rts
.1145					MulHandler:
.1145	20 d5 12	jsr $12d5			jsr 	DereferenceTwo
.1148	20 e3 10	jsr $10e3			jsr 	BinaryProcess 				; check to see if either is float
.114b	b0 03		bcs $1150			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.114d	4c 6c 15	jmp $156c			jmp 	MInt32Multiply 							; else do it as integer.
.1150					_IsFPOperation:
.1150	8a		txa				txa 								; call the relevant fp routine
.1151	a2 08		ldx #$08		ldx	#8
.1153	20 dc 16	jsr $16dc		jsr	floatingpointHandler
.1156	aa		tax				tax
.1157	60		rts				rts
.1158					DivHandler:
.1158	20 d5 12	jsr $12d5			jsr 	DereferenceTwo
.115b	20 e3 10	jsr $10e3			jsr 	BinaryProcess 				; check to see if either is float
.115e	b0 03		bcs $1163			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.1160	4c 46 14	jmp $1446			jmp 	MInt32SDivide 							; else do it as integer.
.1163					_IsFPOperation:
.1163	8a		txa				txa 								; call the relevant fp routine
.1164	a2 04		ldx #$04		ldx	#4
.1166	20 dc 16	jsr $16dc		jsr	floatingpointHandler
.1169	aa		tax				tax
.116a	60		rts				rts
.116b					ModHandler:
.116b	20 d5 12	jsr $12d5			jsr 	DereferenceTwo
.116e	20 e3 10	jsr $10e3			jsr 	BinaryProcess 				; check to see if either is float
.1171	b0 03		bcs $1176			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.1173	4c c4 14	jmp $14c4			jmp 	MInt32Modulus 							; else do it as integer.
.1176					_IsFPOperation:
.1176	8a		txa				txa 								; call the relevant fp routine
.1177	a2 06		ldx #$06		ldx	#6
.1179	20 dc 16	jsr $16dc		jsr	floatingpointHandler
.117c	aa		tax				tax
.117d	60		rts				rts
.117e					XorHandler:
.117e	20 d5 12	jsr $12d5			jsr 	DereferenceTwo
.1181	20 e3 10	jsr $10e3			jsr 	BinaryProcess 				; check to see if either is float
.1184	b0 03		bcs $1189			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.1186	4c f8 13	jmp $13f8			jmp 	MInt32Xor 							; else do it as integer.
.1189					_IsFPOperation:
.1189	8a		txa				txa 								; call the relevant fp routine
.118a	a2 06		ldx #$06		ldx	#6
.118c	20 dc 16	jsr $16dc		jsr	floatingpointHandler
.118f	aa		tax				tax
.1190	60		rts				rts
.1191					OrHandler:
.1191	20 d5 12	jsr $12d5			jsr 	DereferenceTwo
.1194	20 e3 10	jsr $10e3			jsr 	BinaryProcess 				; check to see if either is float
.1197	b0 03		bcs $119c			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.1199	4c df 13	jmp $13df			jmp 	MInt32Or 							; else do it as integer.
.119c					_IsFPOperation:
.119c	8a		txa				txa 								; call the relevant fp routine
.119d	a2 06		ldx #$06		ldx	#6
.119f	20 dc 16	jsr $16dc		jsr	floatingpointHandler
.11a2	aa		tax				tax
.11a3	60		rts				rts
.11a4					AndHandler:
.11a4	20 d5 12	jsr $12d5			jsr 	DereferenceTwo
.11a7	20 e3 10	jsr $10e3			jsr 	BinaryProcess 				; check to see if either is float
.11aa	b0 03		bcs $11af			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.11ac	4c c6 13	jmp $13c6			jmp 	MInt32And 							; else do it as integer.
.11af					_IsFPOperation:
.11af	8a		txa				txa 								; call the relevant fp routine
.11b0	a2 06		ldx #$06		ldx	#6
.11b2	20 dc 16	jsr $16dc		jsr	floatingpointHandler
.11b5	aa		tax				tax
.11b6	60		rts				rts
.11b7					ShlHandler:
.11b7	20 d5 12	jsr $12d5			jsr 	DereferenceTwo
.11ba	20 e3 10	jsr $10e3			jsr 	BinaryProcess 				; check to see if either is float
.11bd	b0 03		bcs $11c2			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.11bf	4c 38 12	jmp $1238			jmp 	Mint32ShiftLeftX 							; else do it as integer.
.11c2					_IsFPOperation:
.11c2	8a		txa				txa 								; call the relevant fp routine
.11c3	a2 06		ldx #$06		ldx	#6
.11c5	20 dc 16	jsr $16dc		jsr	floatingpointHandler
.11c8	aa		tax				tax
.11c9	60		rts				rts
.11ca					ShrHandler:
.11ca	20 d5 12	jsr $12d5			jsr 	DereferenceTwo
.11cd	20 e3 10	jsr $10e3			jsr 	BinaryProcess 				; check to see if either is float
.11d0	b0 03		bcs $11d5			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.11d2	4c 3b 12	jmp $123b			jmp 	MInt32ShiftRightX 							; else do it as integer.
.11d5					_IsFPOperation:
.11d5	8a		txa				txa 								; call the relevant fp routine
.11d6	a2 06		ldx #$06		ldx	#6
.11d8	20 dc 16	jsr $16dc		jsr	floatingpointHandler
.11db	aa		tax				tax
.11dc	60		rts				rts
.11dd					WordRefHandler:
.11dd	20 d5 12	jsr $12d5			jsr 	DereferenceTwo
.11e0	20 e3 10	jsr $10e3			jsr 	BinaryProcess 				; check to see if either is float
.11e3	b0 03		bcs $11e8			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.11e5	4c 2a 12	jmp $122a			jmp 	MInt32WordIndirect 							; else do it as integer.
.11e8					_IsFPOperation:
.11e8	8a		txa				txa 								; call the relevant fp routine
.11e9	a2 06		ldx #$06		ldx	#6
.11eb	20 dc 16	jsr $16dc		jsr	floatingpointHandler
.11ee	aa		tax				tax
.11ef	60		rts				rts
.11f0					ByteRefHandler:
.11f0	20 d5 12	jsr $12d5			jsr 	DereferenceTwo
.11f3	20 e3 10	jsr $10e3			jsr 	BinaryProcess 				; check to see if either is float
.11f6	b0 03		bcs $11fb			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.11f8	4c 2e 12	jmp $122e			jmp 	MInt32ByteIndirect 							; else do it as integer.
.11fb					_IsFPOperation:
.11fb	8a		txa				txa 								; call the relevant fp routine
.11fc	a2 06		ldx #$06		ldx	#6
.11fe	20 dc 16	jsr $16dc		jsr	floatingpointHandler
.1201	aa		tax				tax
.1202	60		rts				rts
.1203					PowerHandler:
.1203	20 d5 12	jsr $12d5			jsr 	DereferenceTwo
.1206	20 e3 10	jsr $10e3			jsr 	BinaryProcess 				; check to see if either is float
.1209	b0 03		bcs $120e			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.120b	4c 16 12	jmp $1216			jmp 	PowerInteger 							; else do it as integer.
.120e					_IsFPOperation:
.120e	8a		txa				txa 								; call the relevant fp routine
.120f	a2 0e		ldx #$0e		ldx	#14
.1211	20 dc 16	jsr $16dc		jsr	floatingpointHandler
.1214	aa		tax				tax
.1215	60		rts				rts
.1216					PowerInteger:
.1216	20 fd 10	jsr $10fd			jsr 	BPMakeBothFloat				; make them float.
.1219	8a		txa				txa
.121a	a2 0e		ldx #$0e		ldx	#14
.121c	20 dc 16	jsr $16dc		jsr	floatingpointHandler
.121f	a2 0c		ldx #$0c		ldx	#12
.1221	20 dc 16	jsr $16dc		jsr	floatingpointHandler
.1224	aa		tax				tax
.1225	a9 00		lda #$00			lda 	#0 							; make type integer
.1227	95 40		sta $40,x			sta 	esType,x
.1229	60		rts				rts
.122a					Mint32WordIndirect:
.122a	a9 80		lda #$80			lda 	#$80 				 		; word reference type
.122c	d0 02		bne $1230			bne 	Min32Indirect
.122e					Mint32ByteIndirect:
.122e	a9 82		lda #$82			lda 	#$82 						; byte reference type
.1230					Min32Indirect:
.1230	48		pha				pha 								; save the indirection
.1231	20 38 15	jsr $1538			jsr 	MInt32Add 					; add a!b a?b
.1234	68		pla				pla 								; and set the type to reference.
.1235	95 40		sta $40,x			sta 	esType,x
.1237	60		rts				rts
.1238					Mint32ShiftLeftX:
.1238	18		clc				clc
.1239	90 01		bcc $123c			bcc 	Mint32Shift
.123b					Mint32ShiftRightX:
.123b	38		sec				sec
.123c					Mint32Shift:
.123c	08		php				php 								; save carry flag on stack.
.123d	b5 51		lda $51,x			lda 	esInt1+1,x 					; if shift >= 32 then it is zero.
.123f	15 59		ora $59,x			ora 	esInt2+1,x
.1241	15 61		ora $61,x			ora 	esInt3+1,x
.1243	d0 1e		bne $1263			bne 	_MShiftZero
.1245	b5 49		lda $49,x			lda 	esInt0+1,x
.1247	c9 20		cmp #$20			cmp 	#32
.1249	b0 18		bcs $1263			bcs 	_MShiftZero
.124b					_MShiftLoop:
.124b	b5 49		lda $49,x			lda 	esInt0+1,x 					; check count is zero
.124d	f0 12		beq $1261			beq 	_MShiftExit
.124f	d6 49		dec $49,x			dec 	esInt0+1,x
.1251	28		plp				plp 								; restore and save carry
.1252	08		php				php
.1253	90 06		bcc $125b			bcc 	_MShiftLeft
.1255	20 64 16	jsr $1664			jsr 	Mint32ShiftRight
.1258	4c 4b 12	jmp $124b			jmp 	_MShiftLoop
.125b					_MShiftLeft:
.125b	20 5b 16	jsr $165b			jsr 	Mint32ShiftLeft
.125e	4c 4b 12	jmp $124b			jmp 	_MShiftLoop
.1261					_MShiftExit:
.1261	28		plp				plp	 								; throw saved carry and exit
.1262	60		rts				rts
.1263					_MShiftZero:
.1263	4c 46 16	jmp $1646			jmp 	MInt32False 				; return 0.

;******  Return to file: ..\source\main/main.asm


;******  Processing file: ..\source\main/evaluate/compare.asm

.1266					PerformComparison:
.1266	b5 40		lda $40,x			lda 	esType,x 					; check for two strings.
.1268	35 41		and $41,x			and 	esType+1,x
.126a	0a		asl a				asl 	a
.126b	30 19		bmi $1286			bmi 	_PCIsString
.126d	b5 40		lda $40,x			lda 	esType,x 					; check either is floating point.
.126f	15 41		ora $41,x			ora 	esType+1,x
.1271	0a		asl a				asl 	a 							; shift bit 6 (string) to bit 7
.1272	30 1a		bmi $128e			bmi 	_PCError
.1274	29 02		and #$02			and 	#$02 						; because of ASL, check type in bit 0
.1276	f0 0b		beq $1283			beq 	_PCIsInteger 				; if not two integers
.1278	20 fd 10	jsr $10fd			jsr 	BPMakeBothFloat 			; make both float
.127b	8a		txa				txa
.127c	a2 02		ldx #$02		ldx	#2
.127e	20 dc 16	jsr $16dc		jsr	floatingpointHandler
.1281	aa		tax				tax
.1282	60		rts				rts
.1283					_PCIsInteger:
.1283	4c 11 14	jmp $1411			jmp 	MInt32Compare
.1286					_PCIsString:
.1286	8a		txa				txa
.1287	a2 02		ldx #$02		ldx	#2
.1289	20 fd 16	jsr $16fd		jsr	stringHandler
.128c	aa		tax				tax
.128d	60		rts				rts
.128e					_PCError:
.128e	a2 04		ldx #$04			ldx 	#ErrorID_BadType
.1290	20 dc 10	jsr $10dc			jsr 	ErrorHandler
.1293					CompareEquals:
.1293	20 66 12	jsr $1266			jsr 	PerformComparison
.1296	c9 00		cmp #$00			cmp 	#$00
.1298	f0 35		beq $12cf			beq  	CompareTrue
.129a	4c d2 12	jmp $12d2			jmp 	CompareFalse
.129d					CompareLess:
.129d	20 66 12	jsr $1266			jsr 	PerformComparison
.12a0	c9 ff		cmp #$ff			cmp 	#$FF
.12a2	f0 2b		beq $12cf			beq  	CompareTrue
.12a4	4c d2 12	jmp $12d2			jmp 	CompareFalse
.12a7					CompareGreater:
.12a7	20 66 12	jsr $1266			jsr 	PerformComparison
.12aa	c9 01		cmp #$01			cmp 	#$01
.12ac	f0 21		beq $12cf			beq  	CompareTrue
.12ae	4c d2 12	jmp $12d2			jmp 	CompareFalse
.12b1					CompareNotEquals:
.12b1	20 66 12	jsr $1266			jsr 	PerformComparison
.12b4	c9 00		cmp #$00			cmp 	#$00
.12b6	d0 17		bne $12cf			bne  	CompareTrue
.12b8	4c d2 12	jmp $12d2			jmp 	CompareFalse
.12bb					CompareGreaterEq:
.12bb	20 66 12	jsr $1266			jsr 	PerformComparison
.12be	c9 ff		cmp #$ff			cmp 	#$FF
.12c0	d0 0d		bne $12cf			bne  	CompareTrue
.12c2	4c d2 12	jmp $12d2			jmp 	CompareFalse
.12c5					CompareLessEq:
.12c5	20 66 12	jsr $1266			jsr 	PerformComparison
.12c8	c9 01		cmp #$01			cmp 	#$01
.12ca	d0 03		bne $12cf			bne  	CompareTrue
.12cc	4c d2 12	jmp $12d2			jmp 	CompareFalse
.12cf					CompareTrue:
.12cf	4c 42 16	jmp $1642			jmp 	MInt32True
.12d2					CompareFalse:
.12d2	4c 46 16	jmp $1646			jmp 	MInt32False

;******  Return to file: ..\source\main/main.asm


;******  Processing file: ..\source\main/evaluate/dereference.asm

.12d5					DereferenceTwo:
.12d5	e8		inx				inx
.12d6	20 da 12	jsr $12da			jsr 	DereferenceOne
.12d9	ca		dex				dex
.12da					DereferenceOne:
.12da	b5 40		lda $40,x			lda 	esType,x
.12dc	10 01		bpl $12df			bpl 	_DRNotReference 			; is it a reference ?
>12de	db						.byte 	$DB
.12df					_DRNotReference
.12df	60		rts				rts

;******  Return to file: ..\source\main/main.asm


;******  Processing file: ..\source\main/evaluate/evaluate.asm

.12e0					EvaluateLevel:
.12e0	48		pha				pha 								; save precedence level.
.12e1	a9 00		lda #$00			lda 	#0 							; zero the current stack level.
.12e3	95 48		sta $48,x			sta 	esInt0,x
.12e5	95 50		sta $50,x			sta 	esInt1,x
.12e7	95 58		sta $58,x			sta 	esInt2,x
.12e9	95 60		sta $60,x			sta 	esInt3,x
.12eb	95 40		sta $40,x			sta 	esType,x 					; zero the type (integer value)
.12ed	b1 02		lda ($02),y			lda 	(codePtr),y	 				; look at first token/character
.12ef	30 21		bmi $1312			bmi 	_ELIsToken 					; if -ve could be string, float, or unary function.
.12f1	0a		asl a				asl 	a 							; if 00-3F then will now be PL and it's a variable.
.12f2	30 0a		bmi $12fe			bmi 	_ELIsConstant 				; 40-7F will be -ve and that's an integer constant.
.12f4	8a		txa				txa 								; stack level in X
.12f5	a2 00		ldx #$00		ldx	#0
.12f7	20 0a 17	jsr $170a		jsr	variableHandler
.12fa	aa		tax				tax
.12fb	4c 3b 13	jmp $133b			jmp		_ELHasTerm
.12fe					_ELIsConstant:
.12fe	4a		lsr a				lsr 	a 							; get the value back
.12ff	29 3f		and #$3f			and 	#$3F 						; force into range 0-63
.1301	95 48		sta $48,x			sta 	esInt0,x 					; and put in LSB.
.1303					_ELCheckNext:
.1303	c8		iny				iny 								; look at next
.1304	b1 02		lda ($02),y			lda 	(codePtr),y
.1306	49 40		eor #$40			eor 	#$40 						; shift around so 40-7F => 00-3F
.1308	c9 40		cmp #$40			cmp 	#$40 						; out of range ?
.130a	b0 2f		bcs $133b			bcs 	_ELHasTerm 					; done getting the constant.
.130c	20 7c 13	jsr $137c			jsr 	ELShiftByteIn 				; shift byte into position.
.130f	4c 03 13	jmp $1303			jmp 	_ELCheckNext
.1312					_ELIsToken:
.1312	c9 85		cmp #$85			cmp 	#TOK_STR 					; handle strings.
.1314	f0 0f		beq $1325			beq 	_ELIsString
.1316	c9 84		cmp #$84			cmp 	#TOK_FPC 					; if no, then check unary.
.1318	d0 5f		bne $1379			bne 	_ELCheckUnary
.131a	8a		txa				txa 								; put X into A
.131b	c8		iny				iny 								; skip over the float marker
.131c	a2 10		ldx #$10		ldx	#16
.131e	20 dc 16	jsr $16dc		jsr	floatingpointHandler
.1321	aa		tax				tax 								; restore X
.1322	4c 3b 13	jmp $133b			jmp 	_ELHasTerm
.1325					_ELIsString:
.1325	98		tya				tya 								; address of string is codePtr+y+1
.1326	38		sec				sec
.1327	65 02		adc $02				adc 	codePtr
.1329	95 48		sta $48,x			sta 	esInt0,x
.132b	a5 03		lda $03				lda 	codePtr+1
.132d	69 00		adc #$00			adc 	#0
.132f	95 50		sta $50,x			sta 	esInt1,x
.1331	a9 40		lda #$40			lda 	#$40 						; set type to string value
.1333	95 40		sta $40,x			sta 	esType,x
.1335	c8		iny				iny 								; skip over string.
.1336	98		tya				tya
.1337	38		sec				sec									; +1 for the length itself.
.1338	71 02		adc ($02),y			adc 	(codePtr),y
.133a	a8		tay				tay 								; and fall through to term loop code.
.133b					_ELHasTerm:
.133b	b1 02		lda ($02),y			lda 	(codePtr),y
.133d	c9 86		cmp #$86			cmp 	#TOK_BINARYST 				; check in the correct range for binary tokens.
.133f	90 04		bcc $1345			bcc 	_ELPopExit
.1341	c9 9d		cmp #$9d			cmp 	#TOK_STRUCTST
.1343	90 02		bcc $1347			bcc 	_ELHasBinaryTerm
.1345					_ELPopExit:
.1345	68		pla				pla
.1346					_ELExit:
.1346	60		rts				rts
.1347					_ELHasBinaryTerm:
.1347	84 0a		sty $0a				sty 	tempShort 					; save position
.1349	a8		tay				tay 								; use token as an index and get the precedence.
.134a	b9 24 13	lda $1324,y			lda 	ELBinaryOperatorInfo-TOK_BINARYST,y
.134d	a4 0a		ldy $0a				ldy 	tempShort 					; restore Y
.134f	85 0a		sta $0a				sta 	tempShort 					; save precedence in memory.
.1351	68		pla				pla 								; restore current level.
.1352	c5 0a		cmp $0a				cmp 	tempShort 					; if current >= operator then exit
.1354	b0 f0		bcs $1346			bcs 	_ELExit
.1356	48		pha				pha 								; save current level back on the stack.
.1357	b1 02		lda ($02),y			lda 	(codePtr),y 				; save the binary operator on the stack and skip it.
.1359	48		pha				pha
.135a	c8		iny				iny
.135b	e8		inx				inx 								; calculate the RHS at the operator precedence.
.135c	a5 0a		lda $0a				lda 	tempShort
.135e	20 e0 12	jsr $12e0			jsr 	EvaluateLevel
.1361	ca		dex				dex
.1362	68		pla				pla 								; get the operator back out.
.1363	86 0a		stx $0a				stx 	tempShort 					; upload the vectors. Would be nice to use jmp (aaaa,x)
.1365	0a		asl a				asl 	a 							; but not practical. May use push/rts later.
.1366	aa		tax				tax
.1367	bd 1e 10	lda $101e,x			lda 	Group0Vectors,x
.136a	85 04		sta $04				sta 	temp0
.136c	bd 1f 10	lda $101f,x			lda 	Group0Vectors+1,x
.136f	85 05		sta $05				sta 	temp0+1
.1371	a6 0a		ldx $0a				ldx 	tempShort
.1373	20 79 13	jsr $1379			jsr 	_ELCallTemp0
.1376	4c 3b 13	jmp $133b			jmp 	_ELHasTerm 					; and loop back round.
.1379					_ELCheckUnary:
.1379					_ELCallTemp0:
.1379	6c 04 00	jmp ($0004)			jmp 	(temp0)
.137c					ELShiftByteIn:
.137c	48		pha				pha 								; save bits to shift in.
.137d	b5 60		lda $60,x			lda 	esInt3,x 					; save top most byte
.137f	48		pha				pha
.1380	b5 58		lda $58,x			lda 	esInt2,x 					; shift everything left 8 bits
.1382	95 60		sta $60,x			sta 	esInt3,x
.1384	b5 50		lda $50,x			lda 	esInt1,x
.1386	95 58		sta $58,x			sta 	esInt2,x
.1388	b5 48		lda $48,x			lda 	esInt0,x
.138a	95 50		sta $50,x			sta 	esInt1,x
.138c	a9 00		lda #$00			lda 	#0
.138e	95 48		sta $48,x			sta 	esInt0,x
.1390	68		pla				pla 								; now A:TOS is a 5 byte register, shift right twice.
.1391	29 03		and #$03			and 	#3 							; only want lower 2 bits
.1393	09 04		ora #$04			ora 	#4  						; set bit 2 - when 1 we are done
.1395					_ELShiftLoop:
.1395	4a		lsr a				lsr 	a
.1396	76 60		ror $60,x			ror 	esInt3,x
.1398	76 58		ror $58,x			ror 	esInt2,x
.139a	76 50		ror $50,x			ror 	esInt1,x
.139c	76 48		ror $48,x			ror 	esInt0,x
.139e	c9 01		cmp #$01			cmp 	#1
.13a0	d0 f3		bne $1395			bne 	_ELShiftLoop
.13a2	68		pla				pla 								; get original 6 bit value and OR in.
.13a3	29 3f		and #$3f			and 	#$3F
.13a5	15 48		ora $48,x			ora 	esInt0,x
.13a7	95 48		sta $48,x			sta 	esInt0,x
.13a9	60		rts				rts
.13aa					ELBinaryOperatorInfo:

;******  Processing file: ..\source\main/evaluate/../../generated/binarystructinfo.inc

>13aa	01					.byte	$01			; $86 and
>13ab	01					.byte	$01			; $87 or
>13ac	01					.byte	$01			; $88 xor
>13ad	02					.byte	$02			; $89 >=
>13ae	02					.byte	$02			; $8a <=
>13af	02					.byte	$02			; $8b >
>13b0	02					.byte	$02			; $8c <
>13b1	02					.byte	$02			; $8d =
>13b2	02					.byte	$02			; $8e <>
>13b3	03					.byte	$03			; $8f +
>13b4	03					.byte	$03			; $90 -
>13b5	04					.byte	$04			; $91 >>
>13b6	04					.byte	$04			; $92 <<
>13b7	04					.byte	$04			; $93 *
>13b8	04					.byte	$04			; $94 /
>13b9	04					.byte	$04			; $95 mod
>13ba	05					.byte	$05			; $96 ^
>13bb	06					.byte	$06			; $97 !
>13bc	06					.byte	$06			; $98 ?
>13bd	82					.byte	$82			; $99 repeat
>13be	82					.byte	$82			; $9a while
>13bf	82					.byte	$82			; $9b for
>13c0	82					.byte	$82			; $9c if
>13c1	80					.byte	$80			; $9d until
>13c2	80					.byte	$80			; $9e wend
>13c3	80					.byte	$80			; $9f next
>13c4	80					.byte	$80			; $a0 then
>13c5	80					.byte	$80			; $a1 endif

;******  Return to file: ..\source\main/evaluate/evaluate.asm


;******  Return to file: ..\source\main/main.asm


;******  Processing file: ..\source\main/imath/int32binary.asm

.13c6					MInt32And:
.13c6	b5 48		lda $48,x			lda 	esInt0,x
.13c8	35 49		and $49,x			and 	esInt0+1,x
.13ca	95 48		sta $48,x			sta 	esInt0,x
.13cc	b5 50		lda $50,x			lda 	esInt1,x
.13ce	35 51		and $51,x			and 	esInt1+1,x
.13d0	95 50		sta $50,x			sta 	esInt1,x
.13d2	b5 58		lda $58,x			lda 	esInt2,x
.13d4	35 59		and $59,x			and 	esInt2+1,x
.13d6	95 58		sta $58,x			sta 	esInt2,x
.13d8	b5 60		lda $60,x			lda 	esInt3,x
.13da	35 61		and $61,x			and 	esInt3+1,x
.13dc	95 60		sta $60,x			sta 	esInt3,x
.13de	60		rts				rts
.13df					MInt32Or:
.13df	b5 48		lda $48,x			lda 	esInt0,x
.13e1	15 49		ora $49,x			ora 	esInt0+1,x
.13e3	95 48		sta $48,x			sta 	esInt0,x
.13e5	b5 50		lda $50,x			lda 	esInt1,x
.13e7	15 51		ora $51,x			ora 	esInt1+1,x
.13e9	95 50		sta $50,x			sta 	esInt1,x
.13eb	b5 58		lda $58,x			lda 	esInt2,x
.13ed	15 59		ora $59,x			ora 	esInt2+1,x
.13ef	95 58		sta $58,x			sta 	esInt2,x
.13f1	b5 60		lda $60,x			lda 	esInt3,x
.13f3	15 61		ora $61,x			ora 	esInt3+1,x
.13f5	95 60		sta $60,x			sta 	esInt3,x
.13f7	60		rts				rts
.13f8					MInt32Xor:
.13f8	b5 48		lda $48,x			lda 	esInt0,x
.13fa	55 49		eor $49,x			eor 	esInt0+1,x
.13fc	95 48		sta $48,x			sta 	esInt0,x
.13fe	b5 50		lda $50,x			lda 	esInt1,x
.1400	55 51		eor $51,x			eor 	esInt1+1,x
.1402	95 50		sta $50,x			sta 	esInt1,x
.1404	b5 58		lda $58,x			lda 	esInt2,x
.1406	55 59		eor $59,x			eor 	esInt2+1,x
.1408	95 58		sta $58,x			sta 	esInt2,x
.140a	b5 60		lda $60,x			lda 	esInt3,x
.140c	55 61		eor $61,x			eor 	esInt3+1,x
.140e	95 60		sta $60,x			sta 	esInt3,x
.1410	60		rts				rts

;******  Return to file: ..\source\main/main.asm


;******  Processing file: ..\source\main/imath/int32compare.asm

.1411					MInt32Compare:
.1411	b5 48		lda $48,x			lda 	esInt0,x 					; equality check.
.1413	d5 49		cmp $49,x			cmp 	esInt0+1,x
.1415	d0 13		bne $142a			bne 	MInt32Compare2
.1417	b5 50		lda $50,x			lda 	esInt1,x
.1419	d5 51		cmp $51,x			cmp 	esInt1+1,x
.141b	d0 0d		bne $142a			bne 	MInt32Compare2
.141d	b5 58		lda $58,x			lda 	esInt2,x
.141f	d5 59		cmp $59,x			cmp 	esInt2+1,x
.1421	d0 07		bne $142a			bne 	MInt32Compare2
.1423	b5 60		lda $60,x			lda 	esInt3,x
.1425	55 61		eor $61,x			eor 	esInt3+1,x 					; will return 0 if the same.
.1427	d0 01		bne $142a			bne 	MInt32Compare2
.1429	60		rts				rts
.142a					MInt32Compare2:
.142a	b5 48		lda $48,x			lda		esInt0,x 					; unsigned 32 bit comparison.
.142c	d5 49		cmp $49,x			cmp 	esInt0+1,x
.142e	b5 50		lda $50,x			lda		esInt1,x
.1430	f5 51		sbc $51,x			sbc 	esInt1+1,x
.1432	b5 58		lda $58,x			lda		esInt2,x
.1434	f5 59		sbc $59,x			sbc 	esInt2+1,x
.1436	b5 60		lda $60,x			lda		esInt3,x
.1438	f5 61		sbc $61,x			sbc 	esInt3+1,x
.143a	50 02		bvc $143e			bvc 	_I32LNoOverflow 			; make it signed 32 bi comparison
.143c	49 80		eor #$80			eor 	#$80
.143e					_I32LNoOverflow
.143e	30 03		bmi $1443			bmi 	MInt32CLess					; if -ve then return $FF
.1440	a9 01		lda #$01			lda 	#$01						; else return $01
.1442	60		rts				rts
.1443					MInt32CLess:
.1443	a9 ff		lda #$ff			lda 	#$FF
.1445	60		rts				rts

;******  Return to file: ..\source\main/main.asm


;******  Processing file: ..\source\main/imath/int32divide.asm

.1446					MInt32SDivide:
.1446	98		tya				tya  								; save Y, which is the count of negations
.1447	48		pha				pha
.1448	a0 00		ldy #$00			ldy 	#0 							; zero count
.144a	20 62 14	jsr $1462			jsr 	_MInt32SRemSign 			; unsign TOS
.144d	e8		inx				inx 								; unsign TOS+1
.144e	20 62 14	jsr $1462			jsr 	_MInt32SRemSign
.1451	ca		dex				dex
.1452	98		tya				tya 								; save sign count on stack
.1453	48		pha				pha
.1454	20 6b 14	jsr $146b			jsr 	MInt32UDivide 				; unsigned division
.1457	68		pla				pla 								; get sign count back
.1458	29 01		and #$01			and 	#1 							; if it is odd, then negate result
.145a	f0 03		beq $145f			beq 	_I32SNoNeg
.145c	20 00 16	jsr $1600			jsr 	MInt32Negate
.145f					_I32SNoNeg:
.145f	68		pla				pla 								; restoe Y and exit
.1460	a8		tay				tay
.1461	60		rts				rts
.1462					_MInt32SRemSign:
.1462	b5 60		lda $60,x			lda 	esInt3,x 					; is it -ve
.1464	10 04		bpl $146a			bpl 	_MInt32SRSExit
.1466	c8		iny				iny 								; increment the sign count
.1467	20 00 16	jsr $1600			jsr 	MInt32Negate 				; negate the value.
.146a					_MInt32SRSExit:
.146a	60		rts				rts
.146b					MInt32UDivide:
.146b	b5 49		lda $49,x			lda 	esInt0+1,x 					; check for division by zero
.146d	15 51		ora $51,x			ora 	esInt1+1,x
.146f	15 52		ora $52,x			ora 	esInt1+2,x
.1471	15 53		ora $53,x			ora 	esInt1+3,x
.1473	f0 4a		beq $14bf			beq 	_MInt32DZero
.1475	e8		inx				inx 								; clear A
.1476	e8		inx				inx
.1477	20 46 16	jsr $1646			jsr 	MInt32False
.147a	ca		dex				dex
.147b	ca		dex				dex
.147c	98		tya				tya 								; save Y on the stack
.147d	48		pha				pha
.147e	a0 20		ldy #$20			ldy 	#32 						; number of division passes
.1480					_MInt32UDLoop:
.1480	16 48		asl $48,x			asl 	esInt0,x					; shift QA left. First Q
.1482	36 50		rol $50,x			rol 	esInt1,x
.1484	36 58		rol $58,x			rol 	esInt2,x
.1486	36 60		rol $60,x			rol 	esInt3,x
.1488	36 4a		rol $4a,x			rol 	esInt0+2,x 					; then A.
.148a	36 52		rol $52,x			rol 	esInt1+2,x
.148c	36 5a		rol $5a,x			rol 	esInt2+2,x
.148e	36 62		rol $62,x			rol 	esInt3+2,x
.1490	38		sec				sec 								; calculate A-M saving result on the stack
.1491	b5 4a		lda $4a,x			lda 	esInt0+2,x
.1493	f5 49		sbc $49,x			sbc 	esInt0+1,x
.1495	48		pha				pha
.1496	b5 52		lda $52,x			lda 	esInt1+2,x
.1498	f5 51		sbc $51,x			sbc 	esInt1+1,x
.149a	48		pha				pha
.149b	b5 5a		lda $5a,x			lda 	esInt2+2,x
.149d	f5 59		sbc $59,x			sbc 	esInt2+1,x
.149f	48		pha				pha
.14a0	b5 62		lda $62,x			lda 	esInt3+2,x
.14a2	f5 61		sbc $61,x			sbc 	esInt3+1,x
.14a4	90 10		bcc $14b6			bcc		_MInt32NoSubtract 			; if A < M (e.g. carry clear) then reject this.
.14a6	95 62		sta $62,x			sta 	esInt3+2,x 					; write result back to A
.14a8	68		pla				pla
.14a9	95 5a		sta $5a,x			sta 	esInt2+2,x
.14ab	68		pla				pla
.14ac	95 52		sta $52,x			sta 	esInt1+2,x
.14ae	68		pla				pla
.14af	95 4a		sta $4a,x			sta 	esInt0+2,x
.14b1	f6 48		inc $48,x			inc 	esInt0,x 					; sets bit 0 of Q - it was shifted left previously.
.14b3	4c b9 14	jmp $14b9			jmp 	_MInt32Next 					; do the next iteration
.14b6					_MInt32NoSubtract:
.14b6	68		pla				pla
.14b7	68		pla				pla
.14b8	68		pla				pla
.14b9					_MInt32Next:
.14b9	88		dey				dey 								; do this 32 times.
.14ba	d0 c4		bne $1480			bne 	_MInt32UDLoop
.14bc	68		pla				pla 								; restore Y and exit
.14bd	a8		tay				tay
.14be	60		rts				rts
.14bf					_MInt32DZero:
.14bf	a2 02		ldx #$02			ldx 	#ErrorID_DivZero
.14c1	20 dc 10	jsr $10dc			jsr 	ErrorHandler
.14c4					MInt32Modulus:
.14c4	20 6b 14	jsr $146b			jsr 	MInt32UDivide 				; do the division.
.14c7	b5 62		lda $62,x			lda 	esInt3+2,x 					; copy 2nd on stack (the remainder) to the top.
.14c9	95 60		sta $60,x			sta 	esInt3,x
.14cb	b5 5a		lda $5a,x			lda 	esInt2+2,x
.14cd	95 58		sta $58,x			sta 	esInt2,x
.14cf	b5 52		lda $52,x			lda 	esInt1+2,x
.14d1	95 50		sta $50,x			sta 	esInt1,x
.14d3	b5 4a		lda $4a,x			lda 	esInt0+2,x
.14d5	95 48		sta $48,x			sta 	esInt0,x
.14d7	60		rts				rts

;******  Return to file: ..\source\main/main.asm


;******  Processing file: ..\source\main/imath/int32fromstr.asm

.14d8					MInt32FromString:
.14d8	85 0a		sta $0a				sta 	tempShort 					; save base
.14da	98		tya				tya
.14db	48		pha				pha
.14dc	a0 00		ldy #$00			ldy 	#0 							; set index into string being read
.14de	b1 04		lda ($04),y			lda 	(temp0),y 					; look at first character
.14e0	c9 2d		cmp #$2d			cmp 	#"-"						; is it a - character
.14e2	d0 01		bne $14e5			bne 	_I32FSNotNegative
.14e4	c8		iny				iny 								; if so consume it.
.14e5					_I32FSNotNegative:
.14e5	a5 0a		lda $0a				lda 	tempShort 					; get the base back.
.14e7	c0 00		cpy #$00			cpy 	#0 							; if we read a -ve (e.g. Y != 0)
.14e9	f0 02		beq $14ed			beq 	_I32FSNN2
.14eb	09 80		ora #$80			ora 	#$80						; set bit 7, this indicates a negated result.
.14ed					_I32FSNN2:
.14ed	48		pha				pha 								; save base + final sign on stack.
.14ee	20 46 16	jsr $1646			jsr 	MInt32False 					; zero the return value.
.14f1					I32FSMainLoop:
.14f1	68		pla				pla 								; get the base back into tempshort
.14f2	48		pha				pha
.14f3	29 7f		and #$7f			and 	#$7F
.14f5	85 0a		sta $0a				sta 	tempShort
.14f7	b1 04		lda ($04),y			lda 	(temp0),y 					; look at next character.
.14f9	c9 61		cmp #$61			cmp 	#"a" 						; fix up case.
.14fb	90 02		bcc $14ff			bcc 	_I32FSNotLC
.14fd	e9 20		sbc #$20			sbc 	#32
.14ff					_I32FSNotLC:
.14ff	38		sec				sec 								; subtract 48 (ASCII "0")
.1500	e9 30		sbc #$30			sbc 	#"0"
.1502	90 26		bcc $152a			bcc 	_I32FSDone 					; nothing more to do.
.1504	c9 0a		cmp #$0a			cmp 	#9+1 						; if it is 0-9 validate vs base.
.1506	90 06		bcc $150e			bcc 	_I32FSValidate
.1508	c9 11		cmp #$11			cmp 	#17 						; is it between 58 and 64 ? if so bad.
.150a	90 1e		bcc $152a			bcc 	_I32FSDone
.150c	e9 07		sbc #$07			sbc 	#7 							; adjust into range so now character is 0->nnn
.150e					_I32FSValidate:
.150e	c5 0a		cmp $0a				cmp 	tempShort 					; compare against the base.
.1510	b0 18		bcs $152a			bcs 	_I32FSDone 					; sorry, too large for this base.
.1512	48		pha				pha 								; save the new digit value.
.1513	e8		inx				inx 								; put base into next slot.
.1514	a5 0a		lda $0a				lda 	tempShort
.1516	20 55 16	jsr $1655			jsr 	MInt32Set8Bit
.1519	ca		dex				dex
.151a	20 6c 15	jsr $156c			jsr 	MInt32Multiply 				; multiply current by the base
.151d	e8		inx				inx
.151e	68		pla				pla  								; put additive into next slot
.151f	20 55 16	jsr $1655			jsr 	MInt32Set8Bit
.1522	ca		dex				dex
.1523	20 38 15	jsr $1538			jsr 	MInt32Add 					; and add it
.1526	c8		iny				iny 								; look at next character
.1527	4c f1 14	jmp $14f1			jmp 	I32FSMainLoop 				; and go round again.
.152a					_I32FSDone:
.152a	68		pla				pla 								; get base/final sign back
.152b	10 04		bpl $1531			bpl 	_I32FSNN3
.152d	88		dey				dey 								; one fewer character to allow for the - prefix.
.152e	20 00 16	jsr $1600			jsr 	MInt32Negate 				; negate the result.
.1531					_I32FSNN3:
.1531	84 0a		sty $0a				sty 	tempShort 					; save the count of characters read
.1533	68		pla				pla
.1534	a8		tay				tay
.1535	a5 0a		lda $0a				lda 	tempShort 					; get the count of characters read into A and exit
.1537	60		rts				rts

;******  Return to file: ..\source\main/main.asm


;******  Processing file: ..\source\main/imath/int32math.asm

.1538					MInt32Add:
.1538	18		clc				clc
.1539	b5 48		lda $48,x			lda 	esInt0,x
.153b	75 49		adc $49,x			adc 	esInt0+1,x
.153d	95 48		sta $48,x			sta 	esInt0,x
.153f	b5 50		lda $50,x			lda 	esInt1,x
.1541	75 51		adc $51,x			adc 	esInt1+1,x
.1543	95 50		sta $50,x			sta 	esInt1,x
.1545	b5 58		lda $58,x			lda 	esInt2,x
.1547	75 59		adc $59,x			adc 	esInt2+1,x
.1549	95 58		sta $58,x			sta 	esInt2,x
.154b	b5 60		lda $60,x			lda 	esInt3,x
.154d	75 61		adc $61,x			adc 	esInt3+1,x
.154f	95 60		sta $60,x			sta 	esInt3,x
.1551	60		rts				rts
.1552					MInt32Sub:
.1552	38		sec				sec
.1553	b5 48		lda $48,x			lda 	esInt0,x
.1555	f5 49		sbc $49,x			sbc 	esInt0+1,x
.1557	95 48		sta $48,x			sta 	esInt0,x
.1559	b5 50		lda $50,x			lda 	esInt1,x
.155b	f5 51		sbc $51,x			sbc 	esInt1+1,x
.155d	95 50		sta $50,x			sta 	esInt1,x
.155f	b5 58		lda $58,x			lda 	esInt2,x
.1561	f5 59		sbc $59,x			sbc 	esInt2+1,x
.1563	95 58		sta $58,x			sta 	esInt2,x
.1565	b5 60		lda $60,x			lda 	esInt3,x
.1567	f5 61		sbc $61,x			sbc 	esInt3+1,x
.1569	95 60		sta $60,x			sta 	esInt3,x
.156b	60		rts				rts

;******  Return to file: ..\source\main/main.asm


;******  Processing file: ..\source\main/imath/int32multiply.asm

.156c					MInt32Multiply:
.156c	e8		inx				inx 								; copy 2nd -> 3rd
.156d	20 92 15	jsr $1592			jsr 	MInt32CopyUp
.1570	ca		dex				dex
.1571	20 92 15	jsr $1592			jsr 	MInt32CopyUp 				; copy 1st -> 2nd
.1574	20 46 16	jsr $1646			jsr 	MInt32False 					; zero 1st.
.1577					_I32Loop:
.1577	b5 4a		lda $4a,x			lda 	esInt0+2,x 					; get low bit of 3rd
.1579	29 01		and #$01			and 	#1
.157b	f0 03		beq $1580			beq 	_I32NoAdd 					; if set
.157d	20 38 15	jsr $1538			jsr 	MInt32Add 					; add 2nd to 1st.
.1580					_I32NoAdd:
.1580	e8		inx				inx 								; shift 2nd left
.1581	20 5b 16	jsr $165b			jsr 	MInt32ShiftLeft
.1584	e8		inx				inx  								; shift 3rd right
.1585	20 64 16	jsr $1664			jsr 	MInt32ShiftRight
.1588	20 6d 16	jsr $166d			jsr 	MInt32Zero 					; check if zero.
.158b	08		php				php 								; save status bits
.158c	ca		dex				dex 	 							; point back to 1st
.158d	ca		dex				dex
.158e	28		plp				plp 								; get status bits
.158f	d0 e6		bne $1577			bne 	_I32Loop 					; if non-zero keep going.
.1591	60		rts				rts
.1592					MInt32CopyUp:
.1592	b5 48		lda $48,x			lda 	esInt0,x
.1594	95 49		sta $49,x			sta 	esInt0+1,x
.1596	b5 50		lda $50,x			lda 	esInt1,x
.1598	95 51		sta $51,x			sta 	esInt1+1,x
.159a	b5 58		lda $58,x			lda 	esInt2,x
.159c	95 59		sta $59,x			sta 	esInt2+1,x
.159e	b5 60		lda $60,x			lda 	esInt3,x
.15a0	95 61		sta $61,x			sta 	esInt3+1,x
.15a2	60		rts				rts

;******  Return to file: ..\source\main/main.asm


;******  Processing file: ..\source\main/imath/int32tostr.asm

>0800					MCharCount:	.fill 	1						; count of converted characters
.15a3					MInt32ToString:
.15a3	48		pha				pha 								; save base
.15a4	85 0a		sta $0a				sta 	tempShort 					; save target base.
.15a6	a9 00		lda #$00			lda 	#0
.15a8	8d 00 08	sta $0800			sta 	MCharCount 					; clear character count.
.15ab	98		tya				tya
.15ac	48		pha				pha
.15ad	a5 0a		lda $0a				lda 	tempShort 					; check if we are signed conversion
.15af	10 10		bpl $15c1			bpl 	_I32TSUnsigned
.15b1	48		pha				pha 								; save base on stack.
.15b2	b5 60		lda $60,x			lda 	esInt3,x 					; is it actually negative
.15b4	10 08		bpl $15be			bpl 	_I32TSNoFlip
.15b6	a9 2d		lda #$2d			lda 	#"-" 						; write a '-' prefix out.
.15b8	20 ed 15	jsr $15ed			jsr 	MI32WriteCharacter
.15bb	20 00 16	jsr $1600			jsr 	MInt32Negate 				; negate the value.
.15be					_I32TSNoFlip:
.15be	68		pla				pla 								; get the base back
.15bf	29 7f		and #$7f			and 	#$7F 						; clear the sign flag so it's just a base now.
.15c1					_I32TSUnsigned:
.15c1	20 c8 15	jsr $15c8			jsr 	MI32DivideWrite 				; recursive code to output string.
.15c4	68		pla				pla
.15c5	a8		tay				tay
.15c6	68		pla				pla
.15c7	60		rts				rts
.15c8					MI32DivideWrite:
.15c8	48		pha				pha 								; save the divisor/base
.15c9	e8		inx				inx 								; write in the dividing position.
.15ca	20 55 16	jsr $1655			jsr 	MInt32Set8Bit
.15cd	ca		dex				dex
.15ce	20 6b 14	jsr $146b			jsr 	MInt32UDivide 				; divide number by base.
.15d1	68		pla				pla 								; get the base into Y
.15d2	a8		tay				tay
.15d3	b5 4a		lda $4a,x			lda 	esInt0+2,x 					; get the remainder and push on the stack.
.15d5	48		pha				pha
.15d6	20 6d 16	jsr $166d			jsr 	MInt32Zero 					; is the result zero ?
.15d9	f0 04		beq $15df			beq 	_I32NoRecurse 				; if so, don't recurse.
.15db	98		tya				tya 								; put base into A
.15dc	20 c8 15	jsr $15c8			jsr 	MI32DivideWrite 				; and jsr the dividor recursively.
.15df					_I32NoRecurse:
.15df	68		pla				pla 								; get the remainder back
.15e0	c9 0a		cmp #$0a			cmp 	#10  						; handle hexadecimals.
.15e2	90 02		bcc $15e6			bcc 	_I32NotHex
.15e4	69 06		adc #$06			adc 	#7-1
.15e6					_I32NotHex:
.15e6	18		clc				clc 								; make it ASCII
.15e7	69 30		adc #$30			adc 	#48
.15e9	20 ed 15	jsr $15ed			jsr 	MI32WriteCharacter 			; write the character out
.15ec	60		rts				rts 								; and exit.
.15ed					MI32WriteCharacter:
.15ed	ac 00 08	ldy $0800			ldy 	MCharCount 					; get position
.15f0	91 04		sta ($04),y			sta 	(temp0),y 					; write out with trailing 0
.15f2	c8		iny				iny
.15f3	a9 00		lda #$00			lda 	#0
.15f5	91 04		sta ($04),y			sta 	(temp0),y
.15f7	ee 00 08	inc $0800			inc 	MCharCount 					; bump count
.15fa	60		rts				rts

;******  Return to file: ..\source\main/main.asm


;******  Processing file: ..\source\main/imath/int32unary.asm

>0801					MSeed32:	.fill 	4							; random number seed.
.15fb					MInt32Absolute:
.15fb	b5 60		lda $60,x			lda 	esInt3,x 					; use negate code if -ve.
.15fd	30 01		bmi $1600			bmi 	MInt32Negate
.15ff	60		rts				rts
.1600					MInt32Negate:
.1600	38		sec				sec
.1601	a9 00		lda #$00			lda 	#0
.1603	f5 48		sbc $48,x			sbc 	esInt0,x
.1605	95 48		sta $48,x			sta 	esInt0,x
.1607	a9 00		lda #$00			lda 	#0
.1609	f5 50		sbc $50,x			sbc 	esInt1,x
.160b	95 50		sta $50,x			sta 	esInt1,x
.160d	a9 00		lda #$00			lda 	#0
.160f	f5 58		sbc $58,x			sbc 	esInt2,x
.1611	95 58		sta $58,x			sta 	esInt2,x
.1613	a9 00		lda #$00			lda 	#0
.1615	f5 60		sbc $60,x			sbc 	esInt3,x
.1617	95 60		sta $60,x			sta 	esInt3,x
.1619	60		rts				rts
.161a					MInt32Not:
.161a	b5 48		lda $48,x			lda 	esInt0,x
.161c	49 ff		eor #$ff			eor 	#$FF
.161e	95 48		sta $48,x			sta 	esInt0,x
.1620	b5 50		lda $50,x			lda 	esInt1,x
.1622	49 ff		eor #$ff			eor 	#$FF
.1624	95 50		sta $50,x			sta 	esInt1,x
.1626	b5 58		lda $58,x			lda 	esInt2,x
.1628	49 ff		eor #$ff			eor 	#$FF
.162a	95 58		sta $58,x			sta 	esInt2,x
.162c	b5 60		lda $60,x			lda 	esInt3,x
.162e	49 ff		eor #$ff			eor 	#$FF
.1630	95 60		sta $60,x			sta 	esInt3,x
.1632	60		rts				rts
.1633					MInt32Sign:
.1633	b5 60		lda $60,x			lda 	esInt3,x					; look at MSB
.1635	30 0b		bmi $1642			bmi 	MInt32True 					; if set return -1 (true)
.1637	20 6d 16	jsr $166d			jsr 	MInt32Zero 					; is it zero ?
.163a	f0 0a		beq $1646			beq 	MInt32False 					; if zero return 0 (false)
.163c	20 46 16	jsr $1646			jsr 	MInt32False 					; > 0 return 1
.163f	f6 48		inc $48,x			inc 	esInt0,x
.1641	60		rts				rts
.1642					MInt32True:
.1642	a9 ff		lda #$ff			lda 	#$FF 						; set to $FFFFFFFF
.1644	d0 02		bne $1648			bne 	MInt32WriteAll
.1646					MInt32False:
.1646	a9 00		lda #$00			lda 	#0
.1648					MInt32WriteAll:
.1648	95 48		sta $48,x			sta 	esInt0,x
.164a					MInt32Write123:
.164a	95 50		sta $50,x			sta 	esInt1,x
.164c	95 58		sta $58,x			sta 	esInt2,x
.164e	95 60		sta $60,x			sta 	esInt3,x
.1650	a9 00		lda #$00			lda 	#$00						; and make it an integer
.1652	95 40		sta $40,x			sta 	esType,x
.1654	60		rts				rts
.1655					MInt32Set8Bit:
.1655	95 48		sta $48,x			sta 	esInt0,x
.1657	a9 00		lda #$00			lda 	#0
.1659	f0 ef		beq $164a			beq		MInt32Write123
.165b					MInt32ShiftLeft:
.165b	16 48		asl $48,x			asl 	esInt0,x
.165d	36 50		rol $50,x			rol	 	esInt1,x
.165f	36 58		rol $58,x			rol	 	esInt2,x
.1661	36 60		rol $60,x			rol	 	esInt3,x
.1663	60		rts				rts
.1664					MInt32ShiftRight:
.1664	56 60		lsr $60,x			lsr 	esInt3,x
.1666	76 58		ror $58,x			ror 	esInt2,x
.1668	76 50		ror $50,x			ror 	esInt1,x
.166a	76 48		ror $48,x			ror 	esInt0,x
.166c	60		rts				rts
.166d					MInt32Zero:
.166d	b5 48		lda $48,x			lda 	esInt0,x
.166f	15 50		ora $50,x			ora 	esInt1,x
.1671	15 58		ora $58,x			ora 	esInt2,x
.1673	15 60		ora $60,x			ora 	esInt3,x
.1675	60		rts				rts
.1676					MInt32Random:
.1676	98		tya				tya
.1677	48		pha				pha
.1678	a0 07		ldy #$07			ldy 	#7
.167a	ad 01 08	lda $0801			lda 	MSeed32+0
.167d	d0 03		bne $1682			bne 	_Random1
.167f	a8		tay				tay
.1680	a9 aa		lda #$aa			lda		#$AA
.1682					_Random1:
.1682	0a		asl a				asl 	a
.1683	2e 02 08	rol $0802			rol 	MSeed32+1
.1686	2e 03 08	rol $0803			rol 	MSeed32+2
.1689	2e 04 08	rol $0804			rol 	MSeed32+3
.168c	90 02		bcc $1690			bcc 	_Random2
.168e	49 c5		eor #$c5			eor 	#$C5
.1690					_Random2:
.1690	88		dey				dey
.1691	d0 ef		bne $1682			bne 	_Random1
.1693	8d 01 08	sta $0801			sta 	MSeed32+0
.1696	95 48		sta $48,x			sta 	esInt0,x
.1698	ad 02 08	lda $0802			lda 	MSeed32+1
.169b	95 50		sta $50,x			sta 	esInt1,x
.169d	ad 03 08	lda $0803			lda 	MSeed32+2
.16a0	95 58		sta $58,x			sta 	esInt2,x
.16a2	ad 04 08	lda $0804			lda 	MSeed32+3
.16a5	95 60		sta $60,x			sta 	esInt3,x
.16a7	68		pla				pla
.16a8	a8		tay				tay
.16a9	60		rts				rts

;******  Return to file: ..\source\main/main.asm

.16aa					mainHandler:
.16aa	7c ad 16	jmp ($16ad,x)			jmp 	(mainVectors,x)
.16ad					mainVectors:

;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\assembler/assembler.asm

.16ad					assemblerHandler:
.16ad	7c b0 16	jmp ($16b0,x)			jmp 	(assemblerVectors,x)
.16b0					assemblerVectors:

;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\device/device.asm

.16b0					deviceHandler:
.16b0	7c b3 16	jmp ($16b3,x)			jmp 	(deviceVectors,x)
.16b3					deviceVectors:

;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\error/error.asm


;******  Processing file: ..\source\error/errorhandler.asm

.10dc					ErrorHandler:
.10dc	a9 ee		lda #$ee			lda 	#$EE
.10de	a8		tay				tay
>10df	db						.byte 	$DB
.10e0	4c e0 10	jmp $10e0	_EHHalt:jmp 	_EHHalt

;******  Return to file: ..\source\error/error.asm


;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\floatingpoint/floatingpoint.asm


;******  Processing file: ..\source\floatingpoint/addsub.asm

.16b3					FPAdd:
>16b3	db						.byte 	$DB
.16b4	4c b3 16	jmp $16b3			jmp 	FPAdd
.16b7					FPSubtract:
>16b7	db						.byte 	$DB
.16b8	4c b7 16	jmp $16b7			jmp 	FPSubtract

;******  Return to file: ..\source\floatingpoint/floatingpoint.asm


;******  Processing file: ..\source\floatingpoint/compare.asm

.16bb					FLTCompare:
>16bb	db						.byte 	$DB
.16bc	4c bb 16	jmp $16bb			jmp 	FLTCompare

;******  Return to file: ..\source\floatingpoint/floatingpoint.asm


;******  Processing file: ..\source\floatingpoint/convert.asm

.16bf					FPItoF:
>16bf	db						.byte 	$DB
.16c0	4c bf 16	jmp $16bf			jmp 	FPItoF
.16c3					FPFtoI:
>16c3	db						.byte 	$DB
.16c4	4c c3 16	jmp $16c3			jmp 	FPFtoI

;******  Return to file: ..\source\floatingpoint/floatingpoint.asm


;******  Processing file: ..\source\floatingpoint/importexport.asm

.16c7					FPImport:
>16c7	db						.byte 	$DB
.16c8	4c c7 16	jmp $16c7			jmp 	FPImport

;******  Return to file: ..\source\floatingpoint/floatingpoint.asm


;******  Processing file: ..\source\floatingpoint/muldiv.asm

.16cb					FPMultiply:
>16cb	db						.byte 	$DB
.16cc	4c cb 16	jmp $16cb			jmp 	FPMultiply
.16cf					FPDivide:
>16cf	db						.byte 	$DB
.16d0	4c cf 16	jmp $16cf			jmp 	FPDivide
.16d3					FPImpossible:
.16d3	a2 04		ldx #$04			ldx 	#ErrorID_BadType
.16d5	20 dc 10	jsr $10dc			jsr 	ErrorHandler
.16d8					FPPower:
>16d8	db						.byte 	$DB
.16d9	4c d8 16	jmp $16d8			jmp 	FPPower

;******  Return to file: ..\source\floatingpoint/floatingpoint.asm

.16dc					floatingpointHandler:
.16dc	7c df 16	jmp ($16df,x)			jmp 	(floatingpointVectors,x)
.16df					floatingpointVectors:
>16df	b3 16					.word FPAdd                ; index 0
>16e1	bb 16					.word FLTCompare           ; index 2
>16e3	cf 16					.word FPDivide             ; index 4
>16e5	d3 16					.word FPImpossible         ; index 6
>16e7	cb 16					.word FPMultiply           ; index 8
>16e9	b7 16					.word FPSubtract           ; index 10
>16eb	c3 16					.word FPFtoI               ; index 12
>16ed	d8 16					.word FPPower              ; index 14
>16ef	c7 16					.word FPImport             ; index 16
>16f1	bf 16					.word FPItoF               ; index 18

;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\interaction/interaction.asm

.16f3					interactionHandler:
.16f3	7c f6 16	jmp ($16f6,x)			jmp 	(interactionVectors,x)
.16f6					interactionVectors:

;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\string/string.asm


;******  Processing file: ..\source\string/compare.asm

.16f6					STRCompare:
>16f6	db						.byte 	$DB
.16f7	4c f6 16	jmp $16f6			jmp 	STRCompare

;******  Return to file: ..\source\string/string.asm


;******  Processing file: ..\source\string/concat.asm

.16fa					StringConcat:
>16fa	db						.byte 	$DB
.16fb	80 fd		bra $16fa			bra 	StringConcat

;******  Return to file: ..\source\string/string.asm

.16fd					stringHandler:
.16fd	7c 00 17	jmp ($1700,x)			jmp 	(stringVectors,x)
.1700					stringVectors:
>1700	fa 16					.word StringConcat         ; index 0
>1702	f6 16					.word STRCompare           ; index 2

;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\tokeniser/tokeniser.asm

.1704					tokeniserHandler:
.1704	7c 07 17	jmp ($1707,x)			jmp 	(tokeniserVectors,x)
.1707					tokeniserVectors:

;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\variable/variable.asm


;******  Processing file: ..\source\variable/access.asm

.1707					AccessVariable:
>1707	db						.byte 	$DB
.1708	80 fd		bra $1707			bra 	AccessVariable

;******  Return to file: ..\source\variable/variable.asm

.170a					variableHandler:
.170a	7c 0d 17	jmp ($170d,x)			jmp 	(variableVectors,x)
.170d					variableVectors:
>170d	07 17					.word AccessVariable       ; index 0

;******  Return to file: ..\source\basic.asm


;******  End of listing


; 64tass Turbo Assembler Macro V1.55.2200 listing file
; 64tass -q -c -L basic.lst -l basic.lbl -Wall -o basic.prg ../source/basic.asm
; Sun Feb 21 20:34:02 2021

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: ../source/basic.asm


;******  Processing file: ../source/main/01common.inc

=8					StackSize = 8

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/main/02macros.inc


;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/main/03data.inc

>0002					temp0: 	.fill 	2
>0004					temp1: 	.fill 	2
>0006					temp2: 	.fill 	2
.0008					tempShort:
>0008							.fill 	1
>0800					esType:	.fill 	StackSize
>0808					esInt0:	.fill 	StackSize
>0810					esInt1:	.fill 	StackSize
>0818					esInt2:	.fill 	StackSize
>0820					esInt3:	.fill 	StackSize
>0828					esExp:	.fill 	StackSize
=$808					esMant0 = esInt0
=$810					esMant1 = esInt1
=$818					esMant2 = esInt2
=$820					esMant3 = esInt3

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/main/imath/intmacros.inc


;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/main/main.inc


;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/assembler/assembler.inc


;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/device/device.inc


;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/error/error.inc


;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/error/errorhandler.inc


;******  Processing file: ../source/error/../generated/errorid.inc

=1					ErrorID_Syntax = 1 ; Syntax Error
=2					ErrorID_DivZero = 2 ; Divide By Zero
=3					ErrorID_Stop = 3 ; Stop
=4					ErrorID_BadType = 4 ; BadType

;******  Return to file: ../source/error/errorhandler.inc


;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/floatingpoint/floatingpoint.inc


;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/interaction/interaction.inc


;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/string/string.inc


;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/tokeniser/tokeniser.inc


;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/variables/variables.inc


;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/main/main.asm


;******  Processing file: ../source/main/00start.asm

.1000					Start:
>1000	db						.byte 	$DB
.1001	a2 01		ldx #$01			ldx 	#ErrorID_Syntax
.1003	20 09 10	jsr $1009			jsr 	ErrorHandler
.1006	4c 00 10	jmp $1000			jmp 	Start
.1010					test0:
.1010					test1:

;******  Return to file: ../source/main/main.asm


;******  Processing file: ../source/main/imath/int32binary.asm

.1010					MInt32And:
.1010	bd 08 08	lda $0808,x			lda 	esInt0,x
.1013	3d 09 08	and $0809,x			and 	esInt0+1,x
.1016	9d 08 08	sta $0808,x			sta 	esInt0,x
.1019	bd 10 08	lda $0810,x			lda 	esInt1,x
.101c	3d 11 08	and $0811,x			and 	esInt1+1,x
.101f	9d 10 08	sta $0810,x			sta 	esInt1,x
.1022	bd 18 08	lda $0818,x			lda 	esInt2,x
.1025	3d 19 08	and $0819,x			and 	esInt2+1,x
.1028	9d 18 08	sta $0818,x			sta 	esInt2,x
.102b	bd 20 08	lda $0820,x			lda 	esInt3,x
.102e	3d 21 08	and $0821,x			and 	esInt3+1,x
.1031	9d 20 08	sta $0820,x			sta 	esInt3,x
.1034	60		rts				rts
.1035					MInt32Or:
.1035	bd 08 08	lda $0808,x			lda 	esInt0,x
.1038	1d 09 08	ora $0809,x			ora 	esInt0+1,x
.103b	9d 08 08	sta $0808,x			sta 	esInt0,x
.103e	bd 10 08	lda $0810,x			lda 	esInt1,x
.1041	1d 11 08	ora $0811,x			ora 	esInt1+1,x
.1044	9d 10 08	sta $0810,x			sta 	esInt1,x
.1047	bd 18 08	lda $0818,x			lda 	esInt2,x
.104a	1d 19 08	ora $0819,x			ora 	esInt2+1,x
.104d	9d 18 08	sta $0818,x			sta 	esInt2,x
.1050	bd 20 08	lda $0820,x			lda 	esInt3,x
.1053	1d 21 08	ora $0821,x			ora 	esInt3+1,x
.1056	9d 20 08	sta $0820,x			sta 	esInt3,x
.1059	60		rts				rts
.105a					MInt32Xor:
.105a	bd 08 08	lda $0808,x			lda 	esInt0,x
.105d	5d 09 08	eor $0809,x			eor 	esInt0+1,x
.1060	9d 08 08	sta $0808,x			sta 	esInt0,x
.1063	bd 10 08	lda $0810,x			lda 	esInt1,x
.1066	5d 11 08	eor $0811,x			eor 	esInt1+1,x
.1069	9d 10 08	sta $0810,x			sta 	esInt1,x
.106c	bd 18 08	lda $0818,x			lda 	esInt2,x
.106f	5d 19 08	eor $0819,x			eor 	esInt2+1,x
.1072	9d 18 08	sta $0818,x			sta 	esInt2,x
.1075	bd 20 08	lda $0820,x			lda 	esInt3,x
.1078	5d 21 08	eor $0821,x			eor 	esInt3+1,x
.107b	9d 20 08	sta $0820,x			sta 	esInt3,x
.107e	60		rts				rts

;******  Return to file: ../source/main/main.asm


;******  Processing file: ../source/main/imath/int32compare.asm

.107f					MInt32Equal:
.107f	bd 08 08	lda $0808,x			lda 	esInt0,x
.1082	dd 09 08	cmp $0809,x			cmp 	esInt0+1,x
.1085	d0 39		bne $10c0			bne 	MInt32CFail
.1087	bd 10 08	lda $0810,x			lda 	esInt1,x
.108a	dd 11 08	cmp $0811,x			cmp 	esInt1+1,x
.108d	d0 31		bne $10c0			bne 	MInt32CFail
.108f	bd 18 08	lda $0818,x			lda 	esInt2,x
.1092	dd 19 08	cmp $0819,x			cmp 	esInt2+1,x
.1095	d0 29		bne $10c0			bne 	MInt32CFail
.1097	bd 20 08	lda $0820,x			lda 	esInt3,x
.109a	dd 21 08	cmp $0821,x			cmp 	esInt3+1,x
.109d	d0 21		bne $10c0			bne 	MInt32CFail
.109f					MInt32CSucceed:
.109f	38		sec				sec
.10a0	60		rts				rts
.10a1					MInt32Less:
.10a1	38		sec				sec
.10a2	bd 08 08	lda $0808,x			lda		esInt0,x
.10a5	fd 09 08	sbc $0809,x			sbc 	esInt0+1,x
.10a8	bd 10 08	lda $0810,x			lda		esInt1,x
.10ab	fd 11 08	sbc $0811,x			sbc 	esInt1+1,x
.10ae	bd 18 08	lda $0818,x			lda		esInt2,x
.10b1	fd 19 08	sbc $0819,x			sbc 	esInt2+1,x
.10b4	bd 20 08	lda $0820,x			lda		esInt3,x
.10b7	fd 21 08	sbc $0821,x			sbc 	esInt3+1,x
.10ba	50 02		bvc $10be			bvc 	_I32LNoOverflow
.10bc	49 80		eor #$80			eor 	#$80
.10be					_I32LNoOverflow
.10be	30 df		bmi $109f			bmi 	MInt32CSucceed
.10c0					MInt32CFail:
.10c0	18		clc				clc
.10c1	60		rts				rts

;******  Return to file: ../source/main/main.asm


;******  Processing file: ../source/main/imath/int32divide.asm

.10c2					MInt32SDivide:
.10c2	98		tya				tya  								; save Y, which is the count of negations
.10c3	48		pha				pha
.10c4	a0 00		ldy #$00			ldy 	#0 							; zero count
.10c6	20 de 10	jsr $10de			jsr 	_MInt32SRemSign 			; unsign TOS
.10c9	e8		inx				inx 								; unsign TOS+1
.10ca	20 de 10	jsr $10de			jsr 	_MInt32SRemSign
.10cd	ca		dex				dex
.10ce	98		tya				tya 								; save sign count on stack
.10cf	48		pha				pha
.10d0	20 e8 10	jsr $10e8			jsr 	MInt32UDivide 				; unsigned division
.10d3	68		pla				pla 								; get sign count back
.10d4	29 01		and #$01			and 	#1 							; if it is odd, then negate result
.10d6	f0 03		beq $10db			beq 	_I32SNoNeg
.10d8	20 c2 12	jsr $12c2			jsr 	MInt32Negate
.10db					_I32SNoNeg:
.10db	68		pla				pla 								; restoe Y and exit
.10dc	a8		tay				tay
.10dd	60		rts				rts
.10de					_MInt32SRemSign:
.10de	bd 20 08	lda $0820,x			lda 	esInt3,x 					; is it -ve
.10e1	10 04		bpl $10e7			bpl 	_MInt32SRSExit
.10e3	c8		iny				iny 								; increment the sign count
.10e4	20 c2 12	jsr $12c2			jsr 	MInt32Negate 				; negate the value.
.10e7					_MInt32SRSExit:
.10e7	60		rts				rts
.10e8					MInt32UDivide:
.10e8	bd 09 08	lda $0809,x			lda 	esInt0+1,x 					; check for division by zero
.10eb	1d 11 08	ora $0811,x			ora 	esInt1+1,x
.10ee	1d 12 08	ora $0812,x			ora 	esInt1+2,x
.10f1	1d 13 08	ora $0813,x			ora 	esInt1+3,x
.10f4	f0 5f		beq $1155			beq 	_MInt32DZero
.10f6	e8		inx				inx 								; clear A
.10f7	e8		inx				inx
.10f8	20 1a 13	jsr $131a			jsr 	MInt32False
.10fb	ca		dex				dex
.10fc	ca		dex				dex
.10fd	98		tya				tya 								; save Y on the stack
.10fe	48		pha				pha
.10ff	a0 20		ldy #$20			ldy 	#32 						; number of division passes
.1101					_MInt32UDLoop:
.1101	1e 08 08	asl $0808,x			asl 	esInt0,x					; shift QA left. First Q
.1104	3e 10 08	rol $0810,x			rol 	esInt1,x
.1107	3e 18 08	rol $0818,x			rol 	esInt2,x
.110a	3e 20 08	rol $0820,x			rol 	esInt3,x
.110d	3e 0a 08	rol $080a,x			rol 	esInt0+2,x 					; then A.
.1110	3e 12 08	rol $0812,x			rol 	esInt1+2,x
.1113	3e 1a 08	rol $081a,x			rol 	esInt2+2,x
.1116	3e 22 08	rol $0822,x			rol 	esInt3+2,x
.1119	38		sec				sec 								; calculate A-M saving result on the stack
.111a	bd 0a 08	lda $080a,x			lda 	esInt0+2,x
.111d	fd 09 08	sbc $0809,x			sbc 	esInt0+1,x
.1120	48		pha				pha
.1121	bd 12 08	lda $0812,x			lda 	esInt1+2,x
.1124	fd 11 08	sbc $0811,x			sbc 	esInt1+1,x
.1127	48		pha				pha
.1128	bd 1a 08	lda $081a,x			lda 	esInt2+2,x
.112b	fd 19 08	sbc $0819,x			sbc 	esInt2+1,x
.112e	48		pha				pha
.112f	bd 22 08	lda $0822,x			lda 	esInt3+2,x
.1132	fd 21 08	sbc $0821,x			sbc 	esInt3+1,x
.1135	90 15		bcc $114c			bcc		_MInt32NoSubtract 			; if A < M (e.g. carry clear) then reject this.
.1137	9d 22 08	sta $0822,x			sta 	esInt3+2,x 					; write result back to A
.113a	68		pla				pla
.113b	9d 1a 08	sta $081a,x			sta 	esInt2+2,x
.113e	68		pla				pla
.113f	9d 12 08	sta $0812,x			sta 	esInt1+2,x
.1142	68		pla				pla
.1143	9d 0a 08	sta $080a,x			sta 	esInt0+2,x
.1146	fe 08 08	inc $0808,x			inc 	esInt0,x 					; sets bit 0 of Q - it was shifted left previously.
.1149	4c 4f 11	jmp $114f			jmp 	_MInt32Next 					; do the next iteration
.114c					_MInt32NoSubtract:
.114c	68		pla				pla
.114d	68		pla				pla
.114e	68		pla				pla
.114f					_MInt32Next:
.114f	88		dey				dey 								; do this 32 times.
.1150	d0 af		bne $1101			bne 	_MInt32UDLoop
.1152	68		pla				pla 								; restore Y and exit
.1153	a8		tay				tay
.1154	60		rts				rts
.1155					_MInt32DZero:
.1155	a2 02		ldx #$02			ldx 	#ErrorID_DivZero
.1157	20 09 10	jsr $1009			jsr 	ErrorHandler
.115a					MInt32Modulus:
.115a	20 e8 10	jsr $10e8			jsr 	MInt32UDivide 				; do the division.
.115d	bd 22 08	lda $0822,x			lda 	esInt3+2,x 					; copy 2nd on stack (the remainder) to the top.
.1160	9d 20 08	sta $0820,x			sta 	esInt3,x
.1163	bd 1a 08	lda $081a,x			lda 	esInt2+2,x
.1166	9d 18 08	sta $0818,x			sta 	esInt2,x
.1169	bd 12 08	lda $0812,x			lda 	esInt1+2,x
.116c	9d 10 08	sta $0810,x			sta 	esInt1,x
.116f	bd 0a 08	lda $080a,x			lda 	esInt0+2,x
.1172	9d 08 08	sta $0808,x			sta 	esInt0,x
.1175	60		rts				rts

;******  Return to file: ../source/main/main.asm


;******  Processing file: ../source/main/imath/int32fromstr.asm

.1176					MInt32FromString:
.1176	85 08		sta $08				sta 	tempShort 					; save base
.1178	98		tya				tya
.1179	48		pha				pha
.117a	a0 00		ldy #$00			ldy 	#0 							; set index into string being read
.117c	b1 02		lda ($02),y			lda 	(temp0),y 					; look at first character
.117e	c9 2d		cmp #$2d			cmp 	#"-"						; is it a - character
.1180	d0 01		bne $1183			bne 	_I32FSNotNegative
.1182	c8		iny				iny 								; if so consume it.
.1183					_I32FSNotNegative:
.1183	a5 08		lda $08				lda 	tempShort 					; get the base back.
.1185	c0 00		cpy #$00			cpy 	#0 							; if we read a -ve (e.g. Y != 0)
.1187	f0 02		beq $118b			beq 	_I32FSNN2
.1189	09 80		ora #$80			ora 	#$80						; set bit 7, this indicates a negated result.
.118b					_I32FSNN2:
.118b	48		pha				pha 								; save base + final sign on stack.
.118c	20 1a 13	jsr $131a			jsr 	MInt32False 					; zero the return value.
.118f					I32FSMainLoop:
.118f	68		pla				pla 								; get the base back into tempshort
.1190	48		pha				pha
.1191	29 7f		and #$7f			and 	#$7F
.1193	85 08		sta $08				sta 	tempShort
.1195	b1 02		lda ($02),y			lda 	(temp0),y 					; look at next character.
.1197	c9 61		cmp #$61			cmp 	#"a" 						; fix up case.
.1199	90 02		bcc $119d			bcc 	_I32FSNotLC
.119b	e9 20		sbc #$20			sbc 	#32
.119d					_I32FSNotLC:
.119d	38		sec				sec 								; subtract 48 (ASCII "0")
.119e	e9 30		sbc #$30			sbc 	#"0"
.11a0	90 26		bcc $11c8			bcc 	_I32FSDone 					; nothing more to do.
.11a2	c9 0a		cmp #$0a			cmp 	#9+1 						; if it is 0-9 validate vs base.
.11a4	90 06		bcc $11ac			bcc 	_I32FSValidate
.11a6	c9 11		cmp #$11			cmp 	#17 						; is it between 58 and 64 ? if so bad.
.11a8	90 1e		bcc $11c8			bcc 	_I32FSDone
.11aa	e9 07		sbc #$07			sbc 	#7 							; adjust into range so now character is 0->nnn
.11ac					_I32FSValidate:
.11ac	c5 08		cmp $08				cmp 	tempShort 					; compare against the base.
.11ae	b0 18		bcs $11c8			bcs 	_I32FSDone 					; sorry, too large for this base.
.11b0	48		pha				pha 								; save the new digit value.
.11b1	e8		inx				inx 								; put base into next slot.
.11b2	a5 08		lda $08				lda 	tempShort
.11b4	20 2e 13	jsr $132e			jsr 	MInt32Set8Bit
.11b7	ca		dex				dex
.11b8	20 22 12	jsr $1222			jsr 	MInt32Multiply 				; multiply current by the base
.11bb	e8		inx				inx
.11bc	68		pla				pla  								; put additive into next slot
.11bd	20 2e 13	jsr $132e			jsr 	MInt32Set8Bit
.11c0	ca		dex				dex
.11c1	20 d6 11	jsr $11d6			jsr 	MInt32Add 					; and add it
.11c4	c8		iny				iny 								; look at next character
.11c5	4c 8f 11	jmp $118f			jmp 	I32FSMainLoop 				; and go round again.
.11c8					_I32FSDone:
.11c8	68		pla				pla 								; get base/final sign back
.11c9	10 04		bpl $11cf			bpl 	_I32FSNN3
.11cb	88		dey				dey 								; one fewer character to allow for the - prefix.
.11cc	20 c2 12	jsr $12c2			jsr 	MInt32Negate 				; negate the result.
.11cf					_I32FSNN3:
.11cf	84 08		sty $08				sty 	tempShort 					; save the count of characters read
.11d1	68		pla				pla
.11d2	a8		tay				tay
.11d3	a5 08		lda $08				lda 	tempShort 					; get the count of characters read into A and exit
.11d5	60		rts				rts

;******  Return to file: ../source/main/main.asm


;******  Processing file: ../source/main/imath/int32math.asm

.11d6					MInt32Add:
.11d6	18		clc				clc
.11d7	bd 08 08	lda $0808,x			lda 	esInt0,x
.11da	7d 09 08	adc $0809,x			adc 	esInt0+1,x
.11dd	9d 08 08	sta $0808,x			sta 	esInt0,x
.11e0	bd 10 08	lda $0810,x			lda 	esInt1,x
.11e3	7d 11 08	adc $0811,x			adc 	esInt1+1,x
.11e6	9d 10 08	sta $0810,x			sta 	esInt1,x
.11e9	bd 18 08	lda $0818,x			lda 	esInt2,x
.11ec	7d 19 08	adc $0819,x			adc 	esInt2+1,x
.11ef	9d 18 08	sta $0818,x			sta 	esInt2,x
.11f2	bd 20 08	lda $0820,x			lda 	esInt3,x
.11f5	7d 21 08	adc $0821,x			adc 	esInt3+1,x
.11f8	9d 20 08	sta $0820,x			sta 	esInt3,x
.11fb	60		rts				rts
.11fc					MInt32Sub:
.11fc	38		sec				sec
.11fd	bd 08 08	lda $0808,x			lda 	esInt0,x
.1200	fd 09 08	sbc $0809,x			sbc 	esInt0+1,x
.1203	9d 08 08	sta $0808,x			sta 	esInt0,x
.1206	bd 10 08	lda $0810,x			lda 	esInt1,x
.1209	fd 11 08	sbc $0811,x			sbc 	esInt1+1,x
.120c	9d 10 08	sta $0810,x			sta 	esInt1,x
.120f	bd 18 08	lda $0818,x			lda 	esInt2,x
.1212	fd 19 08	sbc $0819,x			sbc 	esInt2+1,x
.1215	9d 18 08	sta $0818,x			sta 	esInt2,x
.1218	bd 20 08	lda $0820,x			lda 	esInt3,x
.121b	fd 21 08	sbc $0821,x			sbc 	esInt3+1,x
.121e	9d 20 08	sta $0820,x			sta 	esInt3,x
.1221	60		rts				rts

;******  Return to file: ../source/main/main.asm


;******  Processing file: ../source/main/imath/int32multiply.asm

.1222					MInt32Multiply:
.1222	e8		inx				inx 								; copy 2nd -> 3rd
.1223	20 49 12	jsr $1249			jsr 	MInt32CopyUp
.1226	ca		dex				dex
.1227	20 49 12	jsr $1249			jsr 	MInt32CopyUp 				; copy 1st -> 2nd
.122a	20 1a 13	jsr $131a			jsr 	MInt32False 					; zero 1st.
.122d					_I32Loop:
.122d	bd 0a 08	lda $080a,x			lda 	esInt0+2,x 					; get low bit of 3rd
.1230	29 01		and #$01			and 	#1
.1232	f0 03		beq $1237			beq 	_I32NoAdd 					; if set
.1234	20 d6 11	jsr $11d6			jsr 	MInt32Add 					; add 2nd to 1st.
.1237					_I32NoAdd:
.1237	e8		inx				inx 								; shift 2nd left
.1238	20 35 13	jsr $1335			jsr 	MInt32ShiftLeft
.123b	e8		inx				inx  								; shift 3rd right
.123c	20 42 13	jsr $1342			jsr 	MInt32ShiftRight
.123f	20 4f 13	jsr $134f			jsr 	MInt32Zero 					; check if zero.
.1242	08		php				php 								; save status bits
.1243	ca		dex				dex 	 							; point back to 1st
.1244	ca		dex				dex
.1245	28		plp				plp 								; get status bits
.1246	d0 e5		bne $122d			bne 	_I32Loop 					; if non-zero keep going.
.1248	60		rts				rts
.1249					MInt32CopyUp:
.1249	bd 08 08	lda $0808,x			lda 	esInt0,x
.124c	9d 09 08	sta $0809,x			sta 	esInt0+1,x
.124f	bd 10 08	lda $0810,x			lda 	esInt1,x
.1252	9d 11 08	sta $0811,x			sta 	esInt1+1,x
.1255	bd 18 08	lda $0818,x			lda 	esInt2,x
.1258	9d 19 08	sta $0819,x			sta 	esInt2+1,x
.125b	bd 20 08	lda $0820,x			lda 	esInt3,x
.125e	9d 21 08	sta $0821,x			sta 	esInt3+1,x
.1261	60		rts				rts

;******  Return to file: ../source/main/main.asm


;******  Processing file: ../source/main/imath/int32tostr.asm

>0830					MCharCount:	.fill 	1						; count of converted characters
.1262					MInt32ToString:
.1262	48		pha				pha 								; save base
.1263	85 08		sta $08				sta 	tempShort 					; save target base.
.1265	a9 00		lda #$00			lda 	#0
.1267	8d 30 08	sta $0830			sta 	MCharCount 					; clear character count.
.126a	98		tya				tya
.126b	48		pha				pha
.126c	a5 08		lda $08				lda 	tempShort 					; check if we are signed conversion
.126e	10 11		bpl $1281			bpl 	_I32TSUnsigned
.1270	48		pha				pha 								; save base on stack.
.1271	bd 20 08	lda $0820,x			lda 	esInt3,x 					; is it actually negative
.1274	10 08		bpl $127e			bpl 	_I32TSNoFlip
.1276	a9 2d		lda #$2d			lda 	#"-" 						; write a '-' prefix out.
.1278	20 ae 12	jsr $12ae			jsr 	MI32WriteCharacter
.127b	20 c2 12	jsr $12c2			jsr 	MInt32Negate 				; negate the value.
.127e					_I32TSNoFlip:
.127e	68		pla				pla 								; get the base back
.127f	29 7f		and #$7f			and 	#$7F 						; clear the sign flag so it's just a base now.
.1281					_I32TSUnsigned:
.1281	20 88 12	jsr $1288			jsr 	MI32DivideWrite 				; recursive code to output string.
.1284	68		pla				pla
.1285	a8		tay				tay
.1286	68		pla				pla
.1287	60		rts				rts
.1288					MI32DivideWrite:
.1288	48		pha				pha 								; save the divisor/base
.1289	e8		inx				inx 								; write in the dividing position.
.128a	20 2e 13	jsr $132e			jsr 	MInt32Set8Bit
.128d	ca		dex				dex
.128e	20 e8 10	jsr $10e8			jsr 	MInt32UDivide 				; divide number by base.
.1291	68		pla				pla 								; get the base into Y
.1292	a8		tay				tay
.1293	bd 0a 08	lda $080a,x			lda 	esInt0+2,x 					; get the remainder and push on the stack.
.1296	48		pha				pha
.1297	20 4f 13	jsr $134f			jsr 	MInt32Zero 					; is the result zero ?
.129a	f0 04		beq $12a0			beq 	_I32NoRecurse 				; if so, don't recurse.
.129c	98		tya				tya 								; put base into A
.129d	20 88 12	jsr $1288			jsr 	MI32DivideWrite 				; and jsr the dividor recursively.
.12a0					_I32NoRecurse:
.12a0	68		pla				pla 								; get the remainder back
.12a1	c9 0a		cmp #$0a			cmp 	#10  						; handle hexadecimals.
.12a3	90 02		bcc $12a7			bcc 	_I32NotHex
.12a5	69 06		adc #$06			adc 	#7-1
.12a7					_I32NotHex:
.12a7	18		clc				clc 								; make it ASCII
.12a8	69 30		adc #$30			adc 	#48
.12aa	20 ae 12	jsr $12ae			jsr 	MI32WriteCharacter 			; write the character out
.12ad	60		rts				rts 								; and exit.
.12ae					MI32WriteCharacter:
.12ae	ac 30 08	ldy $0830			ldy 	MCharCount 					; get position
.12b1	91 02		sta ($02),y			sta 	(temp0),y 					; write out with trailing 0
.12b3	c8		iny				iny
.12b4	a9 00		lda #$00			lda 	#0
.12b6	91 02		sta ($02),y			sta 	(temp0),y
.12b8	ee 30 08	inc $0830			inc 	MCharCount 					; bump count
.12bb	60		rts				rts

;******  Return to file: ../source/main/main.asm


;******  Processing file: ../source/main/imath/int32unary.asm

>0831					MSeed32:	.fill 	4							; random number seed.
.12bc					MInt32Absolute:
.12bc	bd 20 08	lda $0820,x			lda 	esInt3,x 					; use negate code if -ve.
.12bf	30 01		bmi $12c2			bmi 	MInt32Negate
.12c1	60		rts				rts
.12c2					MInt32Negate:
.12c2	38		sec				sec
.12c3	a9 00		lda #$00			lda 	#0
.12c5	fd 08 08	sbc $0808,x			sbc 	esInt0,x
.12c8	9d 08 08	sta $0808,x			sta 	esInt0,x
.12cb	a9 00		lda #$00			lda 	#0
.12cd	fd 10 08	sbc $0810,x			sbc 	esInt1,x
.12d0	9d 10 08	sta $0810,x			sta 	esInt1,x
.12d3	a9 00		lda #$00			lda 	#0
.12d5	fd 18 08	sbc $0818,x			sbc 	esInt2,x
.12d8	9d 18 08	sta $0818,x			sta 	esInt2,x
.12db	a9 00		lda #$00			lda 	#0
.12dd	fd 20 08	sbc $0820,x			sbc 	esInt3,x
.12e0	9d 20 08	sta $0820,x			sta 	esInt3,x
.12e3	60		rts				rts
.12e4					MInt32Not:
.12e4	bd 08 08	lda $0808,x			lda 	esInt0,x
.12e7	49 ff		eor #$ff			eor 	#$FF
.12e9	9d 08 08	sta $0808,x			sta 	esInt0,x
.12ec	bd 10 08	lda $0810,x			lda 	esInt1,x
.12ef	49 ff		eor #$ff			eor 	#$FF
.12f1	9d 10 08	sta $0810,x			sta 	esInt1,x
.12f4	bd 18 08	lda $0818,x			lda 	esInt2,x
.12f7	49 ff		eor #$ff			eor 	#$FF
.12f9	9d 18 08	sta $0818,x			sta 	esInt2,x
.12fc	bd 20 08	lda $0820,x			lda 	esInt3,x
.12ff	49 ff		eor #$ff			eor 	#$FF
.1301	9d 20 08	sta $0820,x			sta 	esInt3,x
.1304	60		rts				rts
.1305					MInt32Sign:
.1305	bd 20 08	lda $0820,x			lda 	esInt3,x					; look at MSB
.1308	30 0c		bmi $1316			bmi 	MInt32True 					; if set return -1 (true)
.130a	20 4f 13	jsr $134f			jsr 	MInt32Zero 					; is it zero ?
.130d	f0 0b		beq $131a			beq 	MInt32False 					; if zero return 0 (false)
.130f	20 1a 13	jsr $131a			jsr 	MInt32False 					; > 0 return 1
.1312	fe 08 08	inc $0808,x			inc 	esInt0,x
.1315	60		rts				rts
.1316					MInt32True:
.1316	a9 ff		lda #$ff			lda 	#$FF 						; set to $FFFFFFFF
.1318	d0 02		bne $131c			bne 	MInt32WriteAll
.131a					MInt32False:
.131a	a9 00		lda #$00			lda 	#0
.131c					MInt32WriteAll:
.131c	9d 08 08	sta $0808,x			sta 	esInt0,x
.131f					MInt32Write123:
.131f	9d 10 08	sta $0810,x			sta 	esInt1,x
.1322	9d 18 08	sta $0818,x			sta 	esInt2,x
.1325	9d 20 08	sta $0820,x			sta 	esInt3,x
.1328	a9 00		lda #$00			lda 	#$00						; and make it an integer
.132a	9d 00 08	sta $0800,x			sta 	esType,x
.132d	60		rts				rts
.132e					MInt32Set8Bit:
.132e	9d 08 08	sta $0808,x			sta 	esInt0,x
.1331	a9 00		lda #$00			lda 	#0
.1333	f0 ea		beq $131f			beq		MInt32Write123
.1335					MInt32ShiftLeft:
.1335	1e 08 08	asl $0808,x			asl 	esInt0,x
.1338	3e 10 08	rol $0810,x			rol	 	esInt1,x
.133b	3e 18 08	rol $0818,x			rol	 	esInt2,x
.133e	3e 20 08	rol $0820,x			rol	 	esInt3,x
.1341	60		rts				rts
.1342					MInt32ShiftRight:
.1342	5e 20 08	lsr $0820,x			lsr 	esInt3,x
.1345	7e 18 08	ror $0818,x			ror 	esInt2,x
.1348	7e 10 08	ror $0810,x			ror 	esInt1,x
.134b	7e 08 08	ror $0808,x			ror 	esInt0,x
.134e	60		rts				rts
.134f					MInt32Zero:
.134f	bd 08 08	lda $0808,x			lda 	esInt0,x
.1352	1d 10 08	ora $0810,x			ora 	esInt1,x
.1355	1d 18 08	ora $0818,x			ora 	esInt2,x
.1358	1d 20 08	ora $0820,x			ora 	esInt3,x
.135b	60		rts				rts
.135c					MInt32Random:
.135c	98		tya				tya
.135d	48		pha				pha
.135e	a0 07		ldy #$07			ldy 	#7
.1360	ad 31 08	lda $0831			lda 	MSeed32+0
.1363	d0 03		bne $1368			bne 	_Random1
.1365	a8		tay				tay
.1366	a9 aa		lda #$aa			lda		#$AA
.1368					_Random1:
.1368	0a		asl a				asl 	a
.1369	2e 32 08	rol $0832			rol 	MSeed32+1
.136c	2e 33 08	rol $0833			rol 	MSeed32+2
.136f	2e 34 08	rol $0834			rol 	MSeed32+3
.1372	90 02		bcc $1376			bcc 	_Random2
.1374	49 c5		eor #$c5			eor 	#$C5
.1376					_Random2:
.1376	88		dey				dey
.1377	d0 ef		bne $1368			bne 	_Random1
.1379	8d 31 08	sta $0831			sta 	MSeed32+0
.137c	9d 08 08	sta $0808,x			sta 	esInt0,x
.137f	ad 32 08	lda $0832			lda 	MSeed32+1
.1382	9d 10 08	sta $0810,x			sta 	esInt1,x
.1385	ad 33 08	lda $0833			lda 	MSeed32+2
.1388	9d 18 08	sta $0818,x			sta 	esInt2,x
.138b	ad 34 08	lda $0834			lda 	MSeed32+3
.138e	9d 20 08	sta $0820,x			sta 	esInt3,x
.1391	68		pla				pla
.1392	a8		tay				tay
.1393	60		rts				rts

;******  Return to file: ../source/main/main.asm

.1394					mainHandler:
.1394	7c 97 13	jmp ($1397,x)			jmp 	(mainVectors,x)
.1397					mainVectors:
>1397	10 10					.word test0                ; index 0
>1399	10 10					.word test1                ; index 2

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/assembler/assembler.asm

.139b					assemblerHandler:
.139b	7c 9e 13	jmp ($139e,x)			jmp 	(assemblerVectors,x)
.139e					assemblerVectors:

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/device/device.asm

.139e					deviceHandler:
.139e	7c a1 13	jmp ($13a1,x)			jmp 	(deviceVectors,x)
.13a1					deviceVectors:

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/error/error.asm


;******  Processing file: ../source/error/errorhandler.asm

.1009					ErrorHandler:
.1009	a9 ee		lda #$ee			lda 	#$EE
.100b	a8		tay				tay
>100c	db						.byte 	$DB
.100d	4c 0d 10	jmp $100d	_EHHalt:jmp 	_EHHalt

;******  Return to file: ../source/error/error.asm


;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/floatingpoint/floatingpoint.asm

.13a1					floatingpointHandler:
.13a1	7c a4 13	jmp ($13a4,x)			jmp 	(floatingpointVectors,x)
.13a4					floatingpointVectors:

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/interaction/interaction.asm

.13a4					interactionHandler:
.13a4	7c a7 13	jmp ($13a7,x)			jmp 	(interactionVectors,x)
.13a7					interactionVectors:

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/string/string.asm

.13a7					stringHandler:
.13a7	7c aa 13	jmp ($13aa,x)			jmp 	(stringVectors,x)
.13aa					stringVectors:

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/tokeniser/tokeniser.asm

.13aa					tokeniserHandler:
.13aa	7c ad 13	jmp ($13ad,x)			jmp 	(tokeniserVectors,x)
.13ad					tokeniserVectors:

;******  Return to file: ../source/basic.asm


;******  Processing file: ../source/variables/variables.asm

.13ad					variablesHandler:
.13ad	7c b0 13	jmp ($13b0,x)			jmp 	(variablesVectors,x)
.13b0					variablesVectors:

;******  Return to file: ../source/basic.asm


;******  End of listing

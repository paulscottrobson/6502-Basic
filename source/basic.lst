
; 64tass Turbo Assembler Macro V1.55.2200 listing file
; 64tass -Wall -q -c -L basic.lst -l basic.lbl -Wall -o basic.prg ..\source\basic.asm
; Fri Feb 26 14:22:35 2021

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: ..\source\basic.asm


;******  Processing file: ..\source\main/01common.inc

=8					StackSize = 8

;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\main/02macros.inc


;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\main/03data.inc

>0002					codePtr:.fill 	2							; (codePtr),y points to code.
>0004					temp0: 	.fill 	2							; working variables.
>0006					temp1: 	.fill 	2
>0008					temp2: 	.fill 	2
.000a					tempShort:
>000a							.fill 	1
>0040					esType:	.fill 	StackSize  					; type byte (see above)
>0048					esInt0:	.fill 	StackSize 					; integer or mantissa
>0050					esInt1:	.fill 	StackSize
>0058					esInt2:	.fill 	StackSize
>0060					esInt3:	.fill 	StackSize
>0068					esExp:	.fill 	StackSize 					; exponent
>0070					esSign: .fill 	StackSize 					; sign byte for floating point only
=$48					esMant0 = esInt0 							; synonyms.
=$50					esMant1 = esInt1
=$58					esMant2 = esInt2
=$60					esMant3 = esInt3
>0800							.align	256
.0800					SingleLetterVar:
>0800					 		.fill 	26*4 						; storage for variable A-Z.
.0868					basePage:
>0868							.fill 	2

;******  Processing file: ..\source\main/../generated/tokenconst.inc

=$80					TOK_EOL=$80
=$81					TOK_SHIFT1=$81
=$82					TOK_SHIFT2=$82
=$83					TOK_SHIFT3=$83
=$84					TOK_FPC=$84
=$85					TOK_STR=$85
=$86					TOK_BINARYST=$86
=$9d					TOK_STRUCTST=$9d
=$a2					TOK_UNARYST=$a2
=$c1					TOK_TOKENS=$c1
=$86					TKW_AND                      = $86 ; and
=$87					TKW_OR                       = $87 ; or
=$88					TKW_XOR                      = $88 ; xor
=$89					TKW_GREATEREQUAL             = $89 ; >=
=$8a					TKW_LESSEQUAL                = $8a ; <=
=$8b					TKW_GREATER                  = $8b ; >
=$8c					TKW_LESS                     = $8c ; <
=$8d					TKW_EQUAL                    = $8d ; =
=$8e					TKW_LESSGREATER              = $8e ; <>
=$8f					TKW_PLUS                     = $8f ; +
=$90					TKW_MINUS                    = $90 ; -
=$91					TKW_GREATERGREATER           = $91 ; >>
=$92					TKW_LESSLESS                 = $92 ; <<
=$93					TKW_STAR                     = $93 ; *
=$94					TKW_SLASH                    = $94 ; /
=$95					TKW_MOD                      = $95 ; mod
=$96					TKW_HAT                      = $96 ; ^
=$97					TKW_PLING                    = $97 ; !
=$98					TKW_QMARK                    = $98 ; ?
=$99					TKW_REPEAT                   = $99 ; repeat
=$9a					TKW_WHILE                    = $9a ; while
=$9b					TKW_FOR                      = $9b ; for
=$9c					TKW_IF                       = $9c ; if
=$9d					TKW_UNTIL                    = $9d ; until
=$9e					TKW_WEND                     = $9e ; wend
=$9f					TKW_NEXT                     = $9f ; next
=$a0					TKW_THEN                     = $a0 ; then
=$a1					TKW_ENDIF                    = $a1 ; endif
=$a2					TKW_LPAREN                   = $a2 ; (
=$a3					TKW_LENLPAREN                = $a3 ; len(
=$a4					TKW_SGNLPAREN                = $a4 ; sgn(
=$a5					TKW_ABSLPAREN                = $a5 ; abs(
=$a6					TKW_RANDOMLPAREN             = $a6 ; random(
=$a7					TKW_PAGE                     = $a7 ; page
=$a8					TKW_TRUE                     = $a8 ; true
=$a9					TKW_FALSE                    = $a9 ; false
=$aa					TKW_MINLPAREN                = $aa ; min(
=$ab					TKW_MAXLPAREN                = $ab ; max(
=$ac					TKW_SYSLPAREN                = $ac ; sys(
=$ad					TKW_TIMERLPAREN              = $ad ; timer(
=$ae					TKW_EVENTLPAREN              = $ae ; event(
=$af					TKW_GETLPAREN                = $af ; get(
=$b0					TKW_INKEYLPAREN              = $b0 ; inkey(
=$b1					TKW_ALLOCLPAREN              = $b1 ; alloc(
=$b2					TKW_CHRDOLLARLPAREN          = $b2 ; chr$(
=$b3					TKW_LEFTDOLLARLPAREN         = $b3 ; left$(
=$b4					TKW_MIDDOLLARLPAREN          = $b4 ; mid$(
=$b5					TKW_RIGHTDOLLARLPAREN        = $b5 ; right$(
=$b6					TKW_STRDOLLARLPAREN          = $b6 ; str$(
=$b7					TKW_VALLPAREN                = $b7 ; val(
=$b8					TKW_PEEKLPAREN               = $b8 ; peek(
=$b9					TKW_DEEKLPAREN               = $b9 ; deek(
=$ba					TKW_LEEKLPAREN               = $ba ; leek(
=$bb					TKW_ASCLPAREN                = $bb ; asc(
=$bc					TKW_INTLPAREN                = $bc ; int(
=$bd					TKW_FLOATLPAREN              = $bd ; float(
=$be					TKW_AT                       = $be ; @
=$bf					TKW_WAVY                     = $bf ; ~
=$c0					TKW_AMP                      = $c0 ; &
=$c1					TKW_RPAREN                   = $c1 ; )
=$c2					TKW_COLON                    = $c2 ; :
=$c3					TKW_COMMA                    = $c3 ; ,
=$c4					TKW_SEMICOLON                = $c4 ; ;
=$c5					TKW_RSQPAREN                 = $c5 ; ]
=$c6					TKW_TO                       = $c6 ; to
=$c7					TKW_STEP                     = $c7 ; step
=$c8					TKW_PROC                     = $c8 ; proc
=$c9					TKW_ENDPROC                  = $c9 ; endproc
=$ca					TKW_LOCAL                    = $ca ; local
=$cb					TKW_REM                      = $cb ; rem
=$cc					TKW_LET                      = $cc ; let
=$cd					TKW_QUOTE                    = $cd ; '
=$ce					TKW_LSQPAREN                 = $ce ; [
=$cf					TKW_INPUT                    = $cf ; input
=$d0					TKW_ELSE                     = $d0 ; else
=$d1					TKW_VDU                      = $d1 ; vdu
=$d2					TKW_READ                     = $d2 ; read
=$d3					TKW_DATA                     = $d3 ; data
=$d4					TKW_RESTORE                  = $d4 ; restore
=$d5					TKW_PRINT                    = $d5 ; print
=$d6					TKW_GOTO                     = $d6 ; goto
=$d7					TKW_GOSUB                    = $d7 ; gosub
=$d8					TKW_RETURN                   = $d8 ; return
=$d9					TKW_ASSERT                   = $d9 ; assert
=$da					TKW_STOP                     = $da ; stop
=$db					TKW_END                      = $db ; end
=$dc					TKW_DIM                      = $dc ; dim
=$dd					TKW_POKE                     = $dd ; poke
=$de					TKW_DOKE                     = $de ; doke
=$df					TKW_LOKE                     = $df ; loke
=$86					TKW_CLEAR                    = $86 ; clear
=$87					TKW_LOAD                     = $87 ; load
=$88					TKW_SAVE                     = $88 ; save
=$89					TKW_LIST                     = $89 ; list
=$8a					TKW_NEW                      = $8a ; new
=$8b					TKW_RUN                      = $8b ; run
=$8c					TKW_CODE                     = $8c ; code
=$8d					TKW_OPTION                   = $8d ; option
=$86					TKW_VPOKE                    = $86 ; vpoke
=$86					TKW_VPEEKLPAREN              = $86 ; vpeek(

;******  Return to file: ..\source\main/03data.inc

=$3a					TYPE_INT =		($3A) 						; type bytes that end identifier.
=$3b					TYPE_INTARRAY =	($3B)
=$3c					TYPE_STR =		($3C)
=$3d					TYPE_STRARRAY =	($3D)
=$3e					TYPE_FLOAT =	($3E)
=$3f					TYPE_FLOATARRAY=($3F)

;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\main/imath/intmacros.inc


;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\main/main.inc


;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\assembler/assembler.inc


;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\device/device.inc


;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\error/error.inc


;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\error/errorhandler.inc


;******  Processing file: ..\source\error/../generated/errorid.inc

=1					ErrorID_Syntax = 1 ; Syntax Error
=2					ErrorID_NoModule = 2 ; Module disabled
=3					ErrorID_Assert = 3 ; Assert
=4					ErrorID_DivZero = 4 ; Divide By Zero
=5					ErrorID_Stop = 5 ; Stop
=6					ErrorID_BadType = 6 ; Type Mismatch
=7					ErrorID_BadValue = 7 ; Illegal Value
=8					ErrorID_MissingRP = 8 ; Missing right bracket
=9					ErrorID_MissingComma = 9 ; Missing comma

;******  Return to file: ..\source\error/errorhandler.inc


;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\floatingpoint/floatingpoint.inc


;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\interaction/interaction.inc


;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\string/string.inc


;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\tokeniser/tokeniser.inc


;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\variable/variable.inc


;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\main/main.asm


;******  Processing file: ..\source\main/00start.asm

.1000	a2 ff		ldx #$ff	Start:	ldx 	#$FF
.1002	9a		txs				txs
.1003	a9 00		lda #$00			lda 	#(testBaseAddress) & $FF
.1005	8d 68 08	sta $0868			sta 	basePage
.1008	a9 50		lda #$50			lda 	#(testBaseAddress) >> 8
.100a	8d 69 08	sta $0869			sta 	1+(basePage)
.100d	4c 1e 10	jmp $101e			jmp 	Command_Run
.195f					ReturnPos:
.5000					testBaseAddress:

;******  Processing file: ..\source\main/../generated/testcode.inc

>5000	06 64 00 d9 68 80 06 6e			.byte 6,100,0,217,104,128,6,110,0,217,103,128,6,120,0,217,102,128,6,130,0,217,101,128,6,140,0,217,100,128,6,150,0,217,99,128,6,160,0,217,98,128,6,170,0,217,97,128,6,180,0,217,96,128,6,190,0,217,95,128,6,200,0,217,94,128,6,210,0,217,93,128,6,220,0,217,92,128,6,230,0,217,91,128,6,240,0,217,90,128,6,250,0,217,89,128,6,4,1,217,88,128,6,14,1,217,87,128,6,24,1,217,86,128,6,34,1,217,85,128,6,44,1,217,84,128,6,54,1,217,83,128,6,64,1,217,82,128,6,74,1,217,81,128,6,84,1,217,80,128,6,94,1,217,79,128,6,104,1,217,78,128,6,114,1,217,77,128,6,124,1,217,76,128,6,134,1,217,75,128,6,144,1,217,74,128,6,154,1,217,73,128,6,164,1,217,72,128,6,174,1,217,71,128,6,184,1,217,70,128,6,194,1,217,69,128,6,204,1,217,68,128,6,214,1,217,67,128,6,224,1,217,66,128,6,234,1,217,65,128,6,244,1,217,64,128,7,254,1,217,144,65,128,7,8,2,217,144,66,128,7,18,2,217,144,67,128,7,28,2,217,144,68,128,7,38,2,217,144,69,128,7,48,2,217,144,70,128,7,58,2,217,144,71,128,7,68,2,217,144,72,128,7,78,2,217,144,73,128,7,88,2,217,144,74,128,7,98,2,217,144,75,128,7,108,2,217,144,76,128,7,118,2,217,144,77,128,7,128,2,217,144,78,128,7,138,2,217,144,79,128,7,148,2,217,144,80,128,7,158,2,217,144,81,128,7,168,2,217,144,82,128,7,178,2,217,144,83,128,7,188,2,217,144,84,128,7,198,2,217,144,85,128,7,208,2,217,144,86,128,7,218,2,217,144,87,128,7,228,2,217,144,88,128,7,238,2,217,144,89,128,7,248,2,217,144,90,128,7,2,3,217,144,91,128,7,12,3,217,144,92,128,7,22,3,217,144,93,128,7,32,3,217,144,94,128,7,42,3,217,144,95,128,7,52,3,217,144,96,128,7,62,3,217,144,97,128,7,72,3,217,144,98,128,7,82,3,217,144,99,128,7,92,3,217,144,100,128,7,102,3,217,144,101,128,7,112,3,217,144,102,128,7,122,3,217,144,103,128,7,132,3,217,144,104,128,7,142,3,217,144,105,128,7,152,3,217,144,106,128,7,162,3,217,144,107,128,7,172,3,217,144,108,128,7,182,3,217,144,109,128,7,192,3,217,144,110,128,7,202,3,217,144,111,128,7,212,3,217,144,112,128,7,222,3,217,144,113,128,7,232,3,217,144,114,128,7,242,3,217,144,115,128,7,252,3,217,144,116,128,7,6,4,217,144,117,128,7,16,4,217,144,118,128,7,26,4,217,144,119,128,7,36,4,217,144,120,128,7,46,4,217,144,121,128,7,56,4,217,144,122,128,7,66,4,217,144,123,128,5,76,4,219,128,0
>5008	00 d9 67 80 06 78 00 d9 66 80 06 82 00 d9 65 80
>5018	06 8c 00 d9 64 80 06 96 00 d9 63 80 06 a0 00 d9
>5028	62 80 06 aa 00 d9 61 80 06 b4 00 d9 60 80 06 be
>5038	00 d9 5f 80 06 c8 00 d9 5e 80 06 d2 00 d9 5d 80
>5048	06 dc 00 d9 5c 80 06 e6 00 d9 5b 80 06 f0 00 d9
>5058	5a 80 06 fa 00 d9 59 80 06 04 01 d9 58 80 06 0e
>5068	01 d9 57 80 06 18 01 d9 56 80 06 22 01 d9 55 80
>5078	06 2c 01 d9 54 80 06 36 01 d9 53 80 06 40 01 d9
>5088	52 80 06 4a 01 d9 51 80 06 54 01 d9 50 80 06 5e
>5098	01 d9 4f 80 06 68 01 d9 4e 80 06 72 01 d9 4d 80
>50a8	06 7c 01 d9 4c 80 06 86 01 d9 4b 80 06 90 01 d9
>50b8	4a 80 06 9a 01 d9 49 80 06 a4 01 d9 48 80 06 ae
>50c8	01 d9 47 80 06 b8 01 d9 46 80 06 c2 01 d9 45 80
>50d8	06 cc 01 d9 44 80 06 d6 01 d9 43 80 06 e0 01 d9
>50e8	42 80 06 ea 01 d9 41 80 06 f4 01 d9 40 80 07 fe
>50f8	01 d9 90 41 80 07 08 02 d9 90 42 80 07 12 02 d9
>5108	90 43 80 07 1c 02 d9 90 44 80 07 26 02 d9 90 45
>5118	80 07 30 02 d9 90 46 80 07 3a 02 d9 90 47 80 07
>5128	44 02 d9 90 48 80 07 4e 02 d9 90 49 80 07 58 02
>5138	d9 90 4a 80 07 62 02 d9 90 4b 80 07 6c 02 d9 90
>5148	4c 80 07 76 02 d9 90 4d 80 07 80 02 d9 90 4e 80
>5158	07 8a 02 d9 90 4f 80 07 94 02 d9 90 50 80 07 9e
>5168	02 d9 90 51 80 07 a8 02 d9 90 52 80 07 b2 02 d9
>5178	90 53 80 07 bc 02 d9 90 54 80 07 c6 02 d9 90 55
>5188	80 07 d0 02 d9 90 56 80 07 da 02 d9 90 57 80 07
>5198	e4 02 d9 90 58 80 07 ee 02 d9 90 59 80 07 f8 02
>51a8	d9 90 5a 80 07 02 03 d9 90 5b 80 07 0c 03 d9 90
>51b8	5c 80 07 16 03 d9 90 5d 80 07 20 03 d9 90 5e 80
>51c8	07 2a 03 d9 90 5f 80 07 34 03 d9 90 60 80 07 3e
>51d8	03 d9 90 61 80 07 48 03 d9 90 62 80 07 52 03 d9
>51e8	90 63 80 07 5c 03 d9 90 64 80 07 66 03 d9 90 65
>51f8	80 07 70 03 d9 90 66 80 07 7a 03 d9 90 67 80 07
>5208	84 03 d9 90 68 80 07 8e 03 d9 90 69 80 07 98 03
>5218	d9 90 6a 80 07 a2 03 d9 90 6b 80 07 ac 03 d9 90
>5228	6c 80 07 b6 03 d9 90 6d 80 07 c0 03 d9 90 6e 80
>5238	07 ca 03 d9 90 6f 80 07 d4 03 d9 90 70 80 07 de
>5248	03 d9 90 71 80 07 e8 03 d9 90 72 80 07 f2 03 d9
>5258	90 73 80 07 fc 03 d9 90 74 80 07 06 04 d9 90 75
>5268	80 07 10 04 d9 90 76 80 07 1a 04 d9 90 77 80 07
>5278	24 04 d9 90 78 80 07 2e 04 d9 90 79 80 07 38 04
>5288	d9 90 7a 80 07 42 04 d9 90 7b 80 05 4c 04 db 80
>5298	00

;******  Return to file: ..\source\main/00start.asm


;******  Return to file: ..\source\main/main.asm


;******  Processing file: ..\source\main/commands/assert.asm

.1010					Command_Assert:
.1010	20 79 14	jsr $1479			jsr 	EvaluateRoot 				; what is being asserted.
.1013	20 b6 18	jsr $18b6			jsr 	MInt32Zero 					; is it true ?
.1016	f0 01		beq $1019			beq 	_CAError
.1018	60		rts				rts
.1019					_CAError:
.1019	a2 03		ldx #$03			ldx 	#ErrorID_Assert
.101b	20 1a 19	jsr $191a			jsr 	ErrorHandler

;******  Return to file: ..\source\main/main.asm


;******  Processing file: ..\source\main/commands/run.asm

.101e					Command_Run:
.101e	a2 ff		ldx #$ff			ldx 	#$FF
.1020	9a		txs				txs
.1021	20 40 10	jsr $1040			jsr 	ResetCodeAddress
.1024	a0 03		ldy #$03			ldy 	#3
.1026					CRNextInstruction:
.1026	b1 02		lda ($02),y			lda 	(codePtr),y 				; get next token.
.1028	10 14		bpl $103e			bpl 	_CRNotToken
.102a	c9 c1		cmp #$c1			cmp 	#TOK_TOKENS 				; if in the tokens then do that token.
.102c	b0 04		bcs $1032			bcs 	_CRExecute
.102e	c9 86		cmp #$86			cmp 	#TOK_BINARYST 				; if one of the system tokens $80-$85 do that
.1030	b0 1b		bcs $104d			bcs 	Unimplemented 				; else not implemented.
.1032					_CRExecute:
.1032	c8		iny				iny 								; consume it.
.1033	0a		asl a				asl 	a 							; double it, losing most significant bit.
.1034	aa		tax				tax
.1035	20 3b 10	jsr $103b			jsr 	_CRRunRoutine 				; we want to do jsr (group0vectors,x)
.1038	4c 26 10	jmp $1026			jmp 	CRNextInstruction
.103b					_CRRunRoutine:
.103b	7c 51 10	jmp ($1051,x)			jmp 	(Group0Vectors,x)
.103e					_CRNotToken:
>103e	db						.byte 	$DB
.103f					CommandColon:
.103f	60		rts				rts
.1040					ResetCodeAddress:
.1040	ad 68 08	lda $0868			lda 	basePage 					; copy basePage to code Pointer
.1043	85 02		sta $02				sta 	codePtr
.1045	ad 69 08	lda $0869			lda 	basePage+1
.1048	85 03		sta $03				sta 	codePtr+1
.104a	a0 03		ldy #$03			ldy 	#3 							; offset after offset link and line#
.104c	60		rts				rts
.104d					Unimplemented:
>104d	db						.byte 	$DB
.104e	4c 4d 10	jmp $104d			jmp 	Unimplemented

;******  Processing file: ..\source\main/commands/../../generated/tokenvectors0.inc

.1051					Group0Vectors:
>1051	19 11					.word	AdvanceNextLine          ; $80 [[eol]]
>1053	4d 10					.word	Unimplemented            ; $81 [[sh1]]
>1055	4d 10					.word	Unimplemented            ; $82 [[sh2]]
>1057	4d 10					.word	Unimplemented            ; $83 [[sh3]]
>1059	4d 10					.word	Unimplemented            ; $84 [[fpc]]
>105b	4d 10					.word	Unimplemented            ; $85 [[str]]
>105d	ee 11					.word	AndHandler               ; $86 and
>105f	db 11					.word	OrHandler                ; $87 or
>1061	c8 11					.word	XorHandler               ; $88 xor
>1063	05 13					.word	CompareGreaterEq         ; $89 >=
>1065	0f 13					.word	CompareLessEq            ; $8a <=
>1067	f1 12					.word	CompareGreater           ; $8b >
>1069	e7 12					.word	CompareLess              ; $8c <
>106b	dd 12					.word	CompareEquals            ; $8d =
>106d	fb 12					.word	CompareNotEquals         ; $8e <>
>106f	59 11					.word	AddHandler               ; $8f +
>1071	7c 11					.word	SubHandler               ; $90 -
>1073	14 12					.word	ShrHandler               ; $91 >>
>1075	01 12					.word	ShlHandler               ; $92 <<
>1077	8f 11					.word	MulHandler               ; $93 *
>1079	a2 11					.word	DivHandler               ; $94 /
>107b	b5 11					.word	ModHandler               ; $95 mod
>107d	4d 12					.word	PowerHandler             ; $96 ^
>107f	27 12					.word	WordRefHandler           ; $97 !
>1081	3a 12					.word	ByteRefHandler           ; $98 ?
>1083	4d 10					.word	Unimplemented            ; $99 repeat
>1085	4d 10					.word	Unimplemented            ; $9a while
>1087	4d 10					.word	Unimplemented            ; $9b for
>1089	4d 10					.word	Unimplemented            ; $9c if
>108b	4d 10					.word	Unimplemented            ; $9d until
>108d	4d 10					.word	Unimplemented            ; $9e wend
>108f	4d 10					.word	Unimplemented            ; $9f next
>1091	4d 10					.word	Unimplemented            ; $a0 then
>1093	4d 10					.word	Unimplemented            ; $a1 endif
>1095	51 14					.word	UnaryParenthesis         ; $a2 (
>1097	fd 14					.word	UnaryLen                 ; $a3 len(
>1099	41 15					.word	UnarySgn                 ; $a4 sgn(
>109b	2a 15					.word	UnaryAbs                 ; $a5 abs(
>109d	9a 15					.word	Unary_Random             ; $a6 random(
>109f	e4 15					.word	Unary_Page               ; $a7 page
>10a1	8b 18					.word	MInt32True               ; $a8 true
>10a3	8f 18					.word	MInt32False              ; $a9 false
>10a5	af 15					.word	Unary_Min                ; $aa min(
>10a7	b3 15					.word	Unary_Max                ; $ab max(
>10a9	4d 10					.word	Unimplemented            ; $ac sys(
>10ab	4d 10					.word	Unimplemented            ; $ad timer(
>10ad	4d 10					.word	Unimplemented            ; $ae event(
>10af	4d 10					.word	Unimplemented            ; $af get(
>10b1	4d 10					.word	Unimplemented            ; $b0 inkey(
>10b3	4d 10					.word	Unimplemented            ; $b1 alloc(
>10b5	4d 10					.word	Unimplemented            ; $b2 chr$(
>10b7	4d 10					.word	Unimplemented            ; $b3 left$(
>10b9	4d 10					.word	Unimplemented            ; $b4 mid$(
>10bb	4d 10					.word	Unimplemented            ; $b5 right$(
>10bd	4d 10					.word	Unimplemented            ; $b6 str$(
>10bf	4d 10					.word	Unimplemented            ; $b7 val(
>10c1	58 15					.word	UnaryPeek                ; $b8 peek(
>10c3	5e 15					.word	UnaryDeek                ; $b9 deek(
>10c5	64 15					.word	UnaryLeek                ; $ba leek(
>10c7	1b 15					.word	UnaryAsc                 ; $bb asc(
>10c9	4d 10					.word	Unimplemented            ; $bc int(
>10cb	4d 10					.word	Unimplemented            ; $bd float(
>10cd	f2 15					.word	UnaryReference           ; $be @
>10cf	08 16					.word	UnaryComplement          ; $bf ~
>10d1	05 16					.word	UnaryHexMarker           ; $c0 &
>10d3	4d 10					.word	Unimplemented            ; $c1 )
>10d5	3f 10					.word	CommandColon             ; $c2 :
>10d7	4d 10					.word	Unimplemented            ; $c3 ,
>10d9	4d 10					.word	Unimplemented            ; $c4 ;
>10db	4d 10					.word	Unimplemented            ; $c5 ]
>10dd	4d 10					.word	Unimplemented            ; $c6 to
>10df	4d 10					.word	Unimplemented            ; $c7 step
>10e1	4d 10					.word	Unimplemented            ; $c8 proc
>10e3	4d 10					.word	Unimplemented            ; $c9 endproc
>10e5	4d 10					.word	Unimplemented            ; $ca local
>10e7	4d 10					.word	Unimplemented            ; $cb rem
>10e9	4d 10					.word	Unimplemented            ; $cc let
>10eb	4d 10					.word	Unimplemented            ; $cd '
>10ed	4d 10					.word	Unimplemented            ; $ce [
>10ef	4d 10					.word	Unimplemented            ; $cf input
>10f1	4d 10					.word	Unimplemented            ; $d0 else
>10f3	4d 10					.word	Unimplemented            ; $d1 vdu
>10f5	4d 10					.word	Unimplemented            ; $d2 read
>10f7	4d 10					.word	Unimplemented            ; $d3 data
>10f9	4d 10					.word	Unimplemented            ; $d4 restore
>10fb	4d 10					.word	Unimplemented            ; $d5 print
>10fd	4d 10					.word	Unimplemented            ; $d6 goto
>10ff	4d 10					.word	Unimplemented            ; $d7 gosub
>1101	4d 10					.word	Unimplemented            ; $d8 return
>1103	10 10					.word	Command_Assert           ; $d9 assert
>1105	11 11					.word	CommandStop              ; $da stop
>1107	16 11					.word	CommandEnd               ; $db end
>1109	4d 10					.word	Unimplemented            ; $dc dim
>110b	4d 10					.word	Unimplemented            ; $dd poke
>110d	4d 10					.word	Unimplemented            ; $de doke
>110f	4d 10					.word	Unimplemented            ; $df loke

;******  Return to file: ..\source\main/commands/run.asm


;******  Return to file: ..\source\main/main.asm


;******  Processing file: ..\source\main/commands/stopend.asm

.1111					CommandStop:
.1111	a2 05		ldx #$05			ldx 	#ErrorID_Stop
.1113	20 1a 19	jsr $191a			jsr 	ErrorHandler
.1116					CommandEnd:
.1116	4c ff ff	jmp $ffff			jmp 	$FFFF 						; fudge to crash out of emulator
.1119					AdvanceNextLine:
.1119	a0 00		ldy #$00			ldy 	#0 							; get offset
.111b	b1 02		lda ($02),y			lda 	(codePtr),y
.111d	18		clc				clc 								; add to codePtr
.111e	65 02		adc $02				adc 	codePtr
.1120	85 02		sta $02				sta 	codePtr
.1122	90 02		bcc $1126			bcc 	_ANLNoCarry
.1124	e6 03		inc $03				inc 	codePtr+1
.1126					_ANLNoCarry:
.1126	b1 02		lda ($02),y			lda 	(codePtr),y 				; if end of program (or was just stand alone.
.1128	f0 ec		beq $1116			beq 	CommandEnd 					; execute END
.112a	a0 03		ldy #$03			ldy 	#3 							; start of tokens on line.
.112c	60		rts				rts

;******  Return to file: ..\source\main/main.asm


;******  Processing file: ..\source\main/evaluate/binary.asm

.112d					BinaryProcess:
.112d	b5 40		lda $40,x			lda 	esType,x 					; or type bytes together and check bit 6.
.112f	15 41		ora $41,x			ora 	esType+1,x
.1131	0a		asl a				asl 	a
.1132	30 0e		bmi $1142			bmi 	_BPStringType 				; if one is set, then string type.
.1134	18		clc				clc 								; return CC for integer
.1135	29 02		and #$02			and 	#$02 						; $02 because of ASL A.
.1137	f0 08		beq $1141			beq 	_BPExit 					; if both integer then return with CC.
.1139	20 47 11	jsr $1147			jsr 	BPMakeBothFloat 			; make both float
.113c	a9 01		lda #$01			lda 	#$01 						; set result type to float
.113e	95 40		sta $40,x			sta 	esType,x
.1140	38		sec				sec 								; and return with carry set.
.1141					_BPExit:
.1141	60		rts				rts
.1142					_BPStringType:
.1142	a2 06		ldx #$06			ldx 	#ErrorID_BadType
.1144	20 1a 19	jsr $191a			jsr 	ErrorHandler
.1147					BPMakeBothFloat:
.1147	e8		inx				inx
.1148	20 4c 11	jsr $114c			jsr 	BPMakeFloat 				; one is a float, so we do both as floats.
.114b	ca		dex				dex
.114c					BPMakeFloat:
.114c	b5 40		lda $40,x			lda 	esType,x 					; get type bit.
.114e	4a		lsr a				lsr 	a
.114f	b0 07		bcs $1158			bcs 	_BPIsFloat
.1151	8a		txa				txa
.1152	a2 1a		ldx #$1a		ldx	#26
.1154	20 21 19	jsr $1921		jsr	floatingpointHandler
.1157	aa		tax				tax
.1158					_BPIsFloat:
.1158	60		rts				rts
.1159					AddHandler:
.1159	20 1f 13	jsr $131f			jsr 	DereferenceTwo 				; dereference top two on stack.
.115c	b5 40		lda $40,x			lda 	esType,x 					; check two strings.
.115e	35 41		and $41,x			and 	esType+1,x
.1160	29 40		and #$40			and 	#$40 						; if both have bit 6 set ...
.1162	d0 10		bne $1174			bne 	_AHStringConcat				; concatenate strings.
.1164	20 2d 11	jsr $112d			jsr 	BinaryProcess 				; check to see if either is float
.1167	b0 03		bcs $116c			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.1169	4c 81 17	jmp $1781			jmp 	MInt32Add 							; else do it as integer.
.116c					_IsFPOperation:
.116c	8a		txa				txa 								; call the relevant fp routine
.116d	a2 04		ldx #$04		ldx	#4
.116f	20 21 19	jsr $1921		jsr	floatingpointHandler
.1172	aa		tax				tax
.1173	60		rts				rts
.1174					_AHStringConcat:
.1174	8a		txa				txa
.1175	a2 00		ldx #$00		ldx	#0
.1177	20 30 19	jsr $1930		jsr	stringHandler
.117a	aa		tax				tax
.117b	60		rts				rts
.117c					SubHandler:
.117c	20 1f 13	jsr $131f			jsr 	DereferenceTwo
.117f	20 2d 11	jsr $112d			jsr 	BinaryProcess 				; check to see if either is float
.1182	b0 03		bcs $1187			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.1184	4c 9b 17	jmp $179b			jmp 	MInt32Sub 							; else do it as integer.
.1187					_IsFPOperation:
.1187	8a		txa				txa 								; call the relevant fp routine
.1188	a2 12		ldx #$12		ldx	#18
.118a	20 21 19	jsr $1921		jsr	floatingpointHandler
.118d	aa		tax				tax
.118e	60		rts				rts
.118f					MulHandler:
.118f	20 1f 13	jsr $131f			jsr 	DereferenceTwo
.1192	20 2d 11	jsr $112d			jsr 	BinaryProcess 				; check to see if either is float
.1195	b0 03		bcs $119a			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.1197	4c b5 17	jmp $17b5			jmp 	MInt32Multiply 							; else do it as integer.
.119a					_IsFPOperation:
.119a	8a		txa				txa 								; call the relevant fp routine
.119b	a2 0c		ldx #$0c		ldx	#12
.119d	20 21 19	jsr $1921		jsr	floatingpointHandler
.11a0	aa		tax				tax
.11a1	60		rts				rts
.11a2					DivHandler:
.11a2	20 1f 13	jsr $131f			jsr 	DereferenceTwo
.11a5	20 2d 11	jsr $112d			jsr 	BinaryProcess 				; check to see if either is float
.11a8	b0 03		bcs $11ad			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.11aa	4c 8f 16	jmp $168f			jmp 	MInt32SDivide 							; else do it as integer.
.11ad					_IsFPOperation:
.11ad	8a		txa				txa 								; call the relevant fp routine
.11ae	a2 08		ldx #$08		ldx	#8
.11b0	20 21 19	jsr $1921		jsr	floatingpointHandler
.11b3	aa		tax				tax
.11b4	60		rts				rts
.11b5					ModHandler:
.11b5	20 1f 13	jsr $131f			jsr 	DereferenceTwo
.11b8	20 2d 11	jsr $112d			jsr 	BinaryProcess 				; check to see if either is float
.11bb	b0 03		bcs $11c0			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.11bd	4c 0d 17	jmp $170d			jmp 	MInt32Modulus 							; else do it as integer.
.11c0					_IsFPOperation:
.11c0	8a		txa				txa 								; call the relevant fp routine
.11c1	a2 0a		ldx #$0a		ldx	#10
.11c3	20 21 19	jsr $1921		jsr	floatingpointHandler
.11c6	aa		tax				tax
.11c7	60		rts				rts
.11c8					XorHandler:
.11c8	20 1f 13	jsr $131f			jsr 	DereferenceTwo
.11cb	20 2d 11	jsr $112d			jsr 	BinaryProcess 				; check to see if either is float
.11ce	b0 03		bcs $11d3			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.11d0	4c 41 16	jmp $1641			jmp 	MInt32Xor 							; else do it as integer.
.11d3					_IsFPOperation:
.11d3	8a		txa				txa 								; call the relevant fp routine
.11d4	a2 0a		ldx #$0a		ldx	#10
.11d6	20 21 19	jsr $1921		jsr	floatingpointHandler
.11d9	aa		tax				tax
.11da	60		rts				rts
.11db					OrHandler:
.11db	20 1f 13	jsr $131f			jsr 	DereferenceTwo
.11de	20 2d 11	jsr $112d			jsr 	BinaryProcess 				; check to see if either is float
.11e1	b0 03		bcs $11e6			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.11e3	4c 28 16	jmp $1628			jmp 	MInt32Or 							; else do it as integer.
.11e6					_IsFPOperation:
.11e6	8a		txa				txa 								; call the relevant fp routine
.11e7	a2 0a		ldx #$0a		ldx	#10
.11e9	20 21 19	jsr $1921		jsr	floatingpointHandler
.11ec	aa		tax				tax
.11ed	60		rts				rts
.11ee					AndHandler:
.11ee	20 1f 13	jsr $131f			jsr 	DereferenceTwo
.11f1	20 2d 11	jsr $112d			jsr 	BinaryProcess 				; check to see if either is float
.11f4	b0 03		bcs $11f9			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.11f6	4c 0f 16	jmp $160f			jmp 	MInt32And 							; else do it as integer.
.11f9					_IsFPOperation:
.11f9	8a		txa				txa 								; call the relevant fp routine
.11fa	a2 0a		ldx #$0a		ldx	#10
.11fc	20 21 19	jsr $1921		jsr	floatingpointHandler
.11ff	aa		tax				tax
.1200	60		rts				rts
.1201					ShlHandler:
.1201	20 1f 13	jsr $131f			jsr 	DereferenceTwo
.1204	20 2d 11	jsr $112d			jsr 	BinaryProcess 				; check to see if either is float
.1207	b0 03		bcs $120c			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.1209	4c 82 12	jmp $1282			jmp 	Mint32ShiftLeftX 							; else do it as integer.
.120c					_IsFPOperation:
.120c	8a		txa				txa 								; call the relevant fp routine
.120d	a2 0a		ldx #$0a		ldx	#10
.120f	20 21 19	jsr $1921		jsr	floatingpointHandler
.1212	aa		tax				tax
.1213	60		rts				rts
.1214					ShrHandler:
.1214	20 1f 13	jsr $131f			jsr 	DereferenceTwo
.1217	20 2d 11	jsr $112d			jsr 	BinaryProcess 				; check to see if either is float
.121a	b0 03		bcs $121f			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.121c	4c 85 12	jmp $1285			jmp 	MInt32ShiftRightX 							; else do it as integer.
.121f					_IsFPOperation:
.121f	8a		txa				txa 								; call the relevant fp routine
.1220	a2 0a		ldx #$0a		ldx	#10
.1222	20 21 19	jsr $1921		jsr	floatingpointHandler
.1225	aa		tax				tax
.1226	60		rts				rts
.1227					WordRefHandler:
.1227	20 1f 13	jsr $131f			jsr 	DereferenceTwo
.122a	20 2d 11	jsr $112d			jsr 	BinaryProcess 				; check to see if either is float
.122d	b0 03		bcs $1232			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.122f	4c 74 12	jmp $1274			jmp 	MInt32WordIndirect 							; else do it as integer.
.1232					_IsFPOperation:
.1232	8a		txa				txa 								; call the relevant fp routine
.1233	a2 0a		ldx #$0a		ldx	#10
.1235	20 21 19	jsr $1921		jsr	floatingpointHandler
.1238	aa		tax				tax
.1239	60		rts				rts
.123a					ByteRefHandler:
.123a	20 1f 13	jsr $131f			jsr 	DereferenceTwo
.123d	20 2d 11	jsr $112d			jsr 	BinaryProcess 				; check to see if either is float
.1240	b0 03		bcs $1245			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.1242	4c 78 12	jmp $1278			jmp 	MInt32ByteIndirect 							; else do it as integer.
.1245					_IsFPOperation:
.1245	8a		txa				txa 								; call the relevant fp routine
.1246	a2 0a		ldx #$0a		ldx	#10
.1248	20 21 19	jsr $1921		jsr	floatingpointHandler
.124b	aa		tax				tax
.124c	60		rts				rts
.124d					PowerHandler:
.124d	20 1f 13	jsr $131f			jsr 	DereferenceTwo
.1250	20 2d 11	jsr $112d			jsr 	BinaryProcess 				; check to see if either is float
.1253	b0 03		bcs $1258			bcs 	_IsFPOperation 				; if so do the whole thing as float.
.1255	4c 60 12	jmp $1260			jmp 	PowerInteger 							; else do it as integer.
.1258					_IsFPOperation:
.1258	8a		txa				txa 								; call the relevant fp routine
.1259	a2 16		ldx #$16		ldx	#22
.125b	20 21 19	jsr $1921		jsr	floatingpointHandler
.125e	aa		tax				tax
.125f	60		rts				rts
.1260					PowerInteger:
.1260	20 47 11	jsr $1147			jsr 	BPMakeBothFloat				; make them float.
.1263	8a		txa				txa
.1264	a2 16		ldx #$16		ldx	#22
.1266	20 21 19	jsr $1921		jsr	floatingpointHandler
.1269	a2 14		ldx #$14		ldx	#20
.126b	20 21 19	jsr $1921		jsr	floatingpointHandler
.126e	aa		tax				tax
.126f	a9 00		lda #$00			lda 	#0 							; make type integer
.1271	95 40		sta $40,x			sta 	esType,x
.1273	60		rts				rts
.1274					Mint32WordIndirect:
.1274	a9 80		lda #$80			lda 	#$80 				 		; word reference type
.1276	d0 02		bne $127a			bne 	Min32Indirect
.1278					Mint32ByteIndirect:
.1278	a9 a0		lda #$a0			lda 	#$A0 						; byte reference type
.127a					Min32Indirect:
.127a	48		pha				pha 								; save the indirection
.127b	20 81 17	jsr $1781			jsr 	MInt32Add 					; add a!b a?b
.127e	68		pla				pla 								; and set the type to reference.
.127f	95 40		sta $40,x			sta 	esType,x
.1281	60		rts				rts
.1282					Mint32ShiftLeftX:
.1282	18		clc				clc
.1283	90 01		bcc $1286			bcc 	Mint32Shift
.1285					Mint32ShiftRightX:
.1285	38		sec				sec
.1286					Mint32Shift:
.1286	08		php				php 								; save carry flag on stack.
.1287	b5 51		lda $51,x			lda 	esInt1+1,x 					; if shift >= 32 then it is zero.
.1289	15 59		ora $59,x			ora 	esInt2+1,x
.128b	15 61		ora $61,x			ora 	esInt3+1,x
.128d	d0 1e		bne $12ad			bne 	_MShiftZero
.128f	b5 49		lda $49,x			lda 	esInt0+1,x
.1291	c9 20		cmp #$20			cmp 	#32
.1293	b0 18		bcs $12ad			bcs 	_MShiftZero
.1295					_MShiftLoop:
.1295	b5 49		lda $49,x			lda 	esInt0+1,x 					; check count is zero
.1297	f0 12		beq $12ab			beq 	_MShiftExit
.1299	d6 49		dec $49,x			dec 	esInt0+1,x
.129b	28		plp				plp 								; restore and save carry
.129c	08		php				php
.129d	90 06		bcc $12a5			bcc 	_MShiftLeft
.129f	20 ad 18	jsr $18ad			jsr 	Mint32ShiftRight
.12a2	4c 95 12	jmp $1295			jmp 	_MShiftLoop
.12a5					_MShiftLeft:
.12a5	20 a4 18	jsr $18a4			jsr 	Mint32ShiftLeft
.12a8	4c 95 12	jmp $1295			jmp 	_MShiftLoop
.12ab					_MShiftExit:
.12ab	28		plp				plp	 								; throw saved carry and exit
.12ac	60		rts				rts
.12ad					_MShiftZero:
.12ad	4c 8f 18	jmp $188f			jmp 	MInt32False 				; return 0.

;******  Return to file: ..\source\main/main.asm


;******  Processing file: ..\source\main/evaluate/compare.asm

.12b0					PerformComparison:
.12b0	b5 40		lda $40,x			lda 	esType,x 					; check for two strings.
.12b2	35 41		and $41,x			and 	esType+1,x
.12b4	0a		asl a				asl 	a
.12b5	30 19		bmi $12d0			bmi 	_PCIsString
.12b7	b5 40		lda $40,x			lda 	esType,x 					; check either is floating point.
.12b9	15 41		ora $41,x			ora 	esType+1,x
.12bb	0a		asl a				asl 	a 							; shift bit 6 (string) to bit 7
.12bc	30 1a		bmi $12d8			bmi 	_PCError
.12be	29 02		and #$02			and 	#$02 						; because of ASL, check type in bit 0
.12c0	f0 0b		beq $12cd			beq 	_PCIsInteger 				; if not two integers
.12c2	20 47 11	jsr $1147			jsr 	BPMakeBothFloat 			; make both float
.12c5	8a		txa				txa
.12c6	a2 06		ldx #$06		ldx	#6
.12c8	20 21 19	jsr $1921		jsr	floatingpointHandler
.12cb	aa		tax				tax
.12cc	60		rts				rts
.12cd					_PCIsInteger:
.12cd	4c 5a 16	jmp $165a			jmp 	MInt32Compare
.12d0					_PCIsString:
.12d0	8a		txa				txa
.12d1	a2 02		ldx #$02		ldx	#2
.12d3	20 30 19	jsr $1930		jsr	stringHandler
.12d6	aa		tax				tax
.12d7	60		rts				rts
.12d8					_PCError:
.12d8	a2 06		ldx #$06			ldx 	#ErrorID_BadType
.12da	20 1a 19	jsr $191a			jsr 	ErrorHandler
.12dd					CompareEquals:
.12dd	20 b0 12	jsr $12b0			jsr 	PerformComparison
.12e0	c9 00		cmp #$00			cmp 	#$00
.12e2	f0 35		beq $1319			beq  	CompareTrue
.12e4	4c 1c 13	jmp $131c			jmp 	CompareFalse
.12e7					CompareLess:
.12e7	20 b0 12	jsr $12b0			jsr 	PerformComparison
.12ea	c9 ff		cmp #$ff			cmp 	#$FF
.12ec	f0 2b		beq $1319			beq  	CompareTrue
.12ee	4c 1c 13	jmp $131c			jmp 	CompareFalse
.12f1					CompareGreater:
.12f1	20 b0 12	jsr $12b0			jsr 	PerformComparison
.12f4	c9 01		cmp #$01			cmp 	#$01
.12f6	f0 21		beq $1319			beq  	CompareTrue
.12f8	4c 1c 13	jmp $131c			jmp 	CompareFalse
.12fb					CompareNotEquals:
.12fb	20 b0 12	jsr $12b0			jsr 	PerformComparison
.12fe	c9 00		cmp #$00			cmp 	#$00
.1300	d0 17		bne $1319			bne  	CompareTrue
.1302	4c 1c 13	jmp $131c			jmp 	CompareFalse
.1305					CompareGreaterEq:
.1305	20 b0 12	jsr $12b0			jsr 	PerformComparison
.1308	c9 ff		cmp #$ff			cmp 	#$FF
.130a	d0 0d		bne $1319			bne  	CompareTrue
.130c	4c 1c 13	jmp $131c			jmp 	CompareFalse
.130f					CompareLessEq:
.130f	20 b0 12	jsr $12b0			jsr 	PerformComparison
.1312	c9 01		cmp #$01			cmp 	#$01
.1314	d0 03		bne $1319			bne  	CompareTrue
.1316	4c 1c 13	jmp $131c			jmp 	CompareFalse
.1319					CompareTrue:
.1319	4c 8b 18	jmp $188b			jmp 	MInt32True
.131c					CompareFalse:
.131c	4c 8f 18	jmp $188f			jmp 	MInt32False

;******  Return to file: ..\source\main/main.asm


;******  Processing file: ..\source\main/evaluate/dereference.asm

.131f					DereferenceTwo:
.131f	e8		inx				inx
.1320	20 24 13	jsr $1324			jsr 	DereferenceOne
.1323	ca		dex				dex
.1324					DereferenceOne:
.1324	b5 40		lda $40,x			lda 	esType,x
.1326	10 3d		bpl $1365			bpl 	_DRNotReference 			; is it a reference ?
.1328	4a		lsr a				lsr 	a 							; do float dereference if bit 0 set.
.1329	b0 3b		bcs $1366			bcs 	_DRFloatDeReference
.132b	98		tya				tya
.132c	48		pha				pha
.132d	b5 48		lda $48,x			lda 	esInt0,x 					; copy address to temp0
.132f	85 04		sta $04				sta 	temp0
.1331	b5 50		lda $50,x			lda 	esInt1,x
.1333	85 05		sta $05				sta 	temp0+1
.1335	a9 00		lda #$00			lda 	#0 							; clear esInt1..3
.1337	95 50		sta $50,x			sta 	esInt1,x
.1339	95 58		sta $58,x			sta 	esInt2,x
.133b	95 60		sta $60,x			sta 	esInt3,x
.133d	b5 40		lda $40,x			lda 	esType,x 					; get the type byte.
.133f	29 60		and #$60			and 	#$60 						; get string flag ($40) and byte flag ($20)
.1341	0a		asl a				asl 	a 							; now string ($80) byte ($40)
.1342	30 0d		bmi $1351			bmi 	_DeRefString 				; string, 2 bytes only
.1344	d0 11		bne $1357			bne 	_DeRefByte 					; byte 1 byte only
.1346					_DeRefLong:
.1346	a0 03		ldy #$03			ldy 	#3
.1348	b1 04		lda ($04),y			lda 	(temp0),y
.134a	95 60		sta $60,x			sta 	esInt3,x
.134c	88		dey				dey
.134d	b1 04		lda ($04),y			lda 	(temp0),y
.134f	95 58		sta $58,x			sta 	esInt2,x
.1351					_DeRefString:
.1351	a0 01		ldy #$01			ldy 	#1
.1353	b1 04		lda ($04),y			lda 	(temp0),y
.1355	95 50		sta $50,x			sta 	esInt1,x
.1357					_DeRefByte:
.1357	a0 00		ldy #$00			ldy 	#0
.1359	b1 04		lda ($04),y			lda 	(temp0),y
.135b	95 48		sta $48,x			sta 	esInt0,x
.135d	b5 40		lda $40,x			lda 	esType,x 					; clear byte and deref bits.
.135f	29 40		and #$40			and 	#$40
.1361	95 40		sta $40,x			sta 	esType,x
.1363	68		pla				pla
.1364	a8		tay				tay
.1365					_DRNotReference
.1365	60		rts				rts
.1366					_DRFloatDereference:
.1366	8a		txa				txa
.1367	a2 00		ldx #$00		ldx	#0
.1369	20 21 19	jsr $1921		jsr	floatingpointHandler
.136c	aa		tax				tax
.136d	a9 01		lda #$01			lda 	#$01 						; type to FP (float)
.136f	95 40		sta $40,x			sta 	esType,x
.1371	60		rts				rts

;******  Return to file: ..\source\main/main.asm


;******  Processing file: ..\source\main/evaluate/evaluate.asm

.1372					EvaluateLevel:
.1372	48		pha				pha 								; save precedence level.
.1373	a9 00		lda #$00			lda 	#0 							; zero the current stack level.
.1375	95 48		sta $48,x			sta 	esInt0,x
.1377	95 50		sta $50,x			sta 	esInt1,x
.1379	95 58		sta $58,x			sta 	esInt2,x
.137b	95 60		sta $60,x			sta 	esInt3,x
.137d	95 40		sta $40,x			sta 	esType,x 					; zero the type (integer value)
.137f	b1 02		lda ($02),y			lda 	(codePtr),y	 				; look at first token/character
.1381	30 21		bmi $13a4			bmi 	_ELIsToken 					; if -ve could be string, float, or unary function.
.1383	0a		asl a				asl 	a 							; if 00-3F then will now be PL and it's a variable.
.1384	30 0a		bmi $1390			bmi 	_ELIsConstant 				; 40-7F will be -ve and that's an integer constant.
.1386	8a		txa				txa 								; stack level in X
.1387	a2 00		ldx #$00		ldx	#0
.1389	20 5a 19	jsr $195a		jsr	variableHandler
.138c	aa		tax				tax
.138d	4c cd 13	jmp $13cd			jmp		_ELHasTerm
.1390					_ELIsConstant:
.1390	4a		lsr a				lsr 	a 							; get the value back
.1391	29 3f		and #$3f			and 	#$3F 						; force into range 0-63
.1393	95 48		sta $48,x			sta 	esInt0,x 					; and put in LSB.
.1395					_ELCheckNext:
.1395	c8		iny				iny 								; look at next
.1396	b1 02		lda ($02),y			lda 	(codePtr),y
.1398	49 40		eor #$40			eor 	#$40 						; shift around so 40-7F => 00-3F
.139a	c9 40		cmp #$40			cmp 	#$40 						; out of range ?
.139c	b0 2f		bcs $13cd			bcs 	_ELHasTerm 					; done getting the constant.
.139e	20 b3 14	jsr $14b3			jsr 	ELShiftByteIn 				; shift byte into position.
.13a1	4c 95 13	jmp $1395			jmp 	_ELCheckNext
.13a4					_ELIsToken:
.13a4	c9 85		cmp #$85			cmp 	#TOK_STR 					; handle strings.
.13a6	f0 0f		beq $13b7			beq 	_ELIsString
.13a8	c9 84		cmp #$84			cmp 	#TOK_FPC 					; if no, then check unary.
.13aa	d0 5f		bne $140b			bne 	_ELCheckUnary
.13ac	8a		txa				txa 								; put X into A
.13ad	c8		iny				iny 								; skip over the float marker
.13ae	a2 18		ldx #$18		ldx	#24
.13b0	20 21 19	jsr $1921		jsr	floatingpointHandler
.13b3	aa		tax				tax 								; restore X
.13b4	4c cd 13	jmp $13cd			jmp 	_ELHasTerm
.13b7					_ELIsString:
.13b7	98		tya				tya 								; address of string is codePtr+y+1
.13b8	38		sec				sec
.13b9	65 02		adc $02				adc 	codePtr
.13bb	95 48		sta $48,x			sta 	esInt0,x
.13bd	a5 03		lda $03				lda 	codePtr+1
.13bf	69 00		adc #$00			adc 	#0
.13c1	95 50		sta $50,x			sta 	esInt1,x
.13c3	a9 40		lda #$40			lda 	#$40 						; set type to string value
.13c5	95 40		sta $40,x			sta 	esType,x
.13c7	c8		iny				iny 								; skip over string.
.13c8	98		tya				tya
.13c9	38		sec				sec									; +1 for the length itself.
.13ca	71 02		adc ($02),y			adc 	(codePtr),y
.13cc	a8		tay				tay 								; and fall through to term loop code.
.13cd					_ELHasTerm:
.13cd	b1 02		lda ($02),y			lda 	(codePtr),y
.13cf	c9 86		cmp #$86			cmp 	#TOK_BINARYST 				; check in the correct range for binary tokens.
.13d1	90 04		bcc $13d7			bcc 	_ELPopExit
.13d3	c9 9d		cmp #$9d			cmp 	#TOK_STRUCTST
.13d5	90 02		bcc $13d9			bcc 	_ELHasBinaryTerm
.13d7					_ELPopExit:
.13d7	68		pla				pla
.13d8					_ELExit:
.13d8	60		rts				rts
.13d9					_ELHasBinaryTerm:
.13d9	84 0a		sty $0a				sty 	tempShort 					; save position
.13db	a8		tay				tay 								; use token as an index and get the precedence.
.13dc	b9 5b 14	lda $145b,y			lda 	ELBinaryOperatorInfo-TOK_BINARYST,y
.13df	a4 0a		ldy $0a				ldy 	tempShort 					; restore Y
.13e1	85 0a		sta $0a				sta 	tempShort 					; save precedence in memory.
.13e3	68		pla				pla 								; restore current level.
.13e4	c5 0a		cmp $0a				cmp 	tempShort 					; if current >= operator then exit
.13e6	b0 f0		bcs $13d8			bcs 	_ELExit
.13e8	48		pha				pha 								; save current level back on the stack.
.13e9	b1 02		lda ($02),y			lda 	(codePtr),y 				; save the binary operator on the stack and skip it.
.13eb	48		pha				pha
.13ec	c8		iny				iny
.13ed	e8		inx				inx 								; calculate the RHS at the operator precedence.
.13ee	a5 0a		lda $0a				lda 	tempShort
.13f0	20 72 13	jsr $1372			jsr 	EvaluateLevel
.13f3	ca		dex				dex
.13f4	68		pla				pla 								; get the operator back out.
.13f5					_ELExecuteA:
.13f5	86 0a		stx $0a				stx 	tempShort 					; upload the vectors. Would be nice to use jmp (aaaa,x)
.13f7	0a		asl a				asl 	a 							; but not practical. May use push/rts later.
.13f8	aa		tax				tax
.13f9	bd 51 10	lda $1051,x			lda 	Group0Vectors,x
.13fc	85 04		sta $04				sta 	temp0
.13fe	bd 52 10	lda $1052,x			lda 	Group0Vectors+1,x
.1401	85 05		sta $05				sta 	temp0+1
.1403	a6 0a		ldx $0a				ldx 	tempShort
.1405	20 4e 14	jsr $144e			jsr 	_ELCallTemp0
.1408	4c cd 13	jmp $13cd			jmp 	_ELHasTerm 					; and loop back round.
.140b					_ELCheckUnary:
.140b	c8		iny				iny 								; skip over token.
.140c	c9 90		cmp #$90			cmp 	#TKW_MINUS 					; is it - term
.140e	f0 15		beq $1425			beq 	_ELMinus
.1410	c9 97		cmp #$97			cmp 	#TKW_PLING 					; is it ! or ? term
.1412	f0 28		beq $143c			beq 	_ELIndirect
.1414	c9 98		cmp #$98			cmp 	#TKW_QMARK
.1416	f0 24		beq $143c			beq 	_ELIndirect
.1418	c9 a2		cmp #$a2			cmp 	#TOK_UNARYST 				; must be TOK_UNARYST ... TOK_TOKENS
.141a	90 04		bcc $1420			bcc 	_ELUSyntax
.141c	c9 c1		cmp #$c1			cmp 	#TOK_TOKENS
.141e	90 d5		bcc $13f5			bcc 	_ELExecuteA 				; if so do that token.
.1420					_ELUSyntax:
.1420	a2 01		ldx #$01			ldx 	#ErrorID_Syntax
.1422	20 1a 19	jsr $191a			jsr 	ErrorHandler
.1425					_ELMinus:
.1425	20 63 14	jsr $1463			jsr 	EvaluateNumericTerm 		; get a number to negate.
.1428	b5 40		lda $40,x			lda 	esType,x 					; is it integer
.142a	f0 0a		beq $1436			beq 	_ELMinusInteger
.142c	8a		txa				txa
.142d	a2 0e		ldx #$0e		ldx	#14
.142f	20 21 19	jsr $1921		jsr	floatingpointHandler
.1432	aa		tax				tax
.1433	4c cd 13	jmp $13cd			jmp 	_ELHasTerm
.1436					_ELMinusInteger:
.1436	20 49 18	jsr $1849			jsr 	MInt32Negate 				; do int negate
.1439	4c cd 13	jmp $13cd			jmp 	_ELHasTerm
.143c					_ELIndirect:
.143c	48		pha				pha 								; save what we want (TKW_QMARK TWK_PLING)
.143d	20 6c 14	jsr $146c			jsr 	EvaluateIntegerTerm 		; integer address
.1440	68		pla				pla
.1441	49 97		eor #$97			eor 	#TKW_PLING 					; now $00 if !
.1443	f0 02		beq $1447			beq 	_ELHaveModifier
.1445	a9 20		lda #$20			lda 	#$20 						; now $00 if !, $20 if ?
.1447					_ELHaveModifier:
.1447	09 80		ora #$80			ora 	#$80						; make it the appropriate reference.
.1449	95 40		sta $40,x			sta 	esType,x
.144b	4c cd 13	jmp $13cd			jmp 	_ELHasTerm
.144e					_ELCallTemp0:
.144e	6c 04 00	jmp ($0004)			jmp 	(temp0)
.1451					UnaryParenthesis:
.1451	a9 00		lda #$00			lda 	#0 							; ( is a unary function ....
.1453	20 72 13	jsr $1372			jsr 	EvaluateLevel
.1456	20 f7 18	jsr $18f7			jsr 	CheckRightParen 			; check for )
.1459	60		rts				rts
.145a					EvaluateTerm:
.145a	a9 0f		lda #$0f			lda 	#15
.145c	20 72 13	jsr $1372			jsr 	EvaluateLevel
.145f	20 24 13	jsr $1324			jsr 	DereferenceOne
.1462	60		rts				rts
.1463					EvaluateNumericTerm:
.1463	20 5a 14	jsr $145a			jsr 	EvaluateTerm
.1466	b5 40		lda $40,x			lda 	esType,x
.1468	0a		asl a				asl 	a 							; see if it's a string.
.1469	30 09		bmi $1474			bmi 	ENTType
.146b	60		rts				rts
.146c					EvaluateIntegerTerm:
.146c	20 5a 14	jsr $145a			jsr 	EvaluateTerm
.146f	b5 40		lda $40,x			lda 	esType,x
.1471	d0 01		bne $1474			bne 	ENTType
.1473	60		rts				rts
.1474					ENTType:
.1474	a2 06		ldx #$06			ldx 	#ErrorID_BadType
.1476	20 1a 19	jsr $191a			jsr 	ErrorHandler
.1479					EvaluateRoot:
.1479	a2 00		ldx #$00			ldx 	#0
.147b					Evaluate:
.147b	a9 00		lda #$00			lda 	#0
.147d	20 72 13	jsr $1372			jsr 	EvaluateLevel
.1480	20 24 13	jsr $1324			jsr 	DereferenceOne
.1483	60		rts				rts
.1484					EvaluateNumeric:
.1484	20 7b 14	jsr $147b			jsr 	Evaluate
.1487	b5 40		lda $40,x			lda 	esType,x
.1489	0a		asl a				asl 	a 							; see if it's a string.
.148a	30 e8		bmi $1474			bmi 	ENTType
.148c	4a		lsr a				lsr 	a 							; shift float flag into carry.
.148d	4a		lsr a				lsr 	a
.148e	60		rts				rts
.148f					EvaluateString:
.148f	20 7b 14	jsr $147b			jsr 	Evaluate
.1492	b5 40		lda $40,x			lda 	esType,x
.1494	0a		asl a				asl 	a 							; see if it's a string.
.1495	10 dd		bpl $1474			bpl 	ENTType
.1497	60		rts				rts
.1498					EvaluateInteger:
.1498	20 7b 14	jsr $147b			jsr 	Evaluate
.149b	b5 40		lda $40,x			lda 	esType,x
.149d	d0 d5		bne $1474			bne 	ENTType
.149f	60		rts				rts
.14a0					EvaluateSmallInteger:
.14a0	20 98 14	jsr $1498			jsr 	EvaluateInteger
.14a3	b5 41		lda $41,x			lda 	esType+1,x
.14a5	15 42		ora $42,x			ora 	esType+2,x
.14a7	15 43		ora $43,x			ora 	esType+3,x
.14a9	d0 03		bne $14ae			bne 	_ESIValue
.14ab	b5 40		lda $40,x			lda 	esType,x
.14ad	60		rts				rts
.14ae					_ESIValue:
.14ae	a2 07		ldx #$07			ldx 	#ErrorID_BadValue
.14b0	20 1a 19	jsr $191a			jsr 	ErrorHandler
.14b3					ELShiftByteIn:
.14b3	48		pha				pha 								; save bits to shift in.
.14b4	b5 60		lda $60,x			lda 	esInt3,x 					; save top most byte
.14b6	48		pha				pha
.14b7	b5 58		lda $58,x			lda 	esInt2,x 					; shift everything left 8 bits
.14b9	95 60		sta $60,x			sta 	esInt3,x
.14bb	b5 50		lda $50,x			lda 	esInt1,x
.14bd	95 58		sta $58,x			sta 	esInt2,x
.14bf	b5 48		lda $48,x			lda 	esInt0,x
.14c1	95 50		sta $50,x			sta 	esInt1,x
.14c3	a9 00		lda #$00			lda 	#0
.14c5	95 48		sta $48,x			sta 	esInt0,x
.14c7	68		pla				pla 								; now A:TOS is a 5 byte register, shift right twice.
.14c8	29 03		and #$03			and 	#3 							; only want lower 2 bits
.14ca	09 04		ora #$04			ora 	#4  						; set bit 2 - when 1 we are done
.14cc					_ELShiftLoop:
.14cc	4a		lsr a				lsr 	a
.14cd	76 60		ror $60,x			ror 	esInt3,x
.14cf	76 58		ror $58,x			ror 	esInt2,x
.14d1	76 50		ror $50,x			ror 	esInt1,x
.14d3	76 48		ror $48,x			ror 	esInt0,x
.14d5	c9 01		cmp #$01			cmp 	#1
.14d7	d0 f3		bne $14cc			bne 	_ELShiftLoop
.14d9	68		pla				pla 								; get original 6 bit value and OR in.
.14da	29 3f		and #$3f			and 	#$3F
.14dc	15 48		ora $48,x			ora 	esInt0,x
.14de	95 48		sta $48,x			sta 	esInt0,x
.14e0	60		rts				rts
.14e1					ELBinaryOperatorInfo:

;******  Processing file: ..\source\main/evaluate/../../generated/binarystructinfo.inc

>14e1	01					.byte	$01			; $86 and
>14e2	01					.byte	$01			; $87 or
>14e3	01					.byte	$01			; $88 xor
>14e4	02					.byte	$02			; $89 >=
>14e5	02					.byte	$02			; $8a <=
>14e6	02					.byte	$02			; $8b >
>14e7	02					.byte	$02			; $8c <
>14e8	02					.byte	$02			; $8d =
>14e9	02					.byte	$02			; $8e <>
>14ea	03					.byte	$03			; $8f +
>14eb	03					.byte	$03			; $90 -
>14ec	04					.byte	$04			; $91 >>
>14ed	04					.byte	$04			; $92 <<
>14ee	04					.byte	$04			; $93 *
>14ef	04					.byte	$04			; $94 /
>14f0	04					.byte	$04			; $95 mod
>14f1	05					.byte	$05			; $96 ^
>14f2	06					.byte	$06			; $97 !
>14f3	06					.byte	$06			; $98 ?
>14f4	82					.byte	$82			; $99 repeat
>14f5	82					.byte	$82			; $9a while
>14f6	82					.byte	$82			; $9b for
>14f7	82					.byte	$82			; $9c if
>14f8	80					.byte	$80			; $9d until
>14f9	80					.byte	$80			; $9e wend
>14fa	80					.byte	$80			; $9f next
>14fb	80					.byte	$80			; $a0 then
>14fc	80					.byte	$80			; $a1 endif

;******  Return to file: ..\source\main/evaluate/evaluate.asm


;******  Return to file: ..\source\main/main.asm


;******  Processing file: ..\source\main/evaluate/unary.asm

.14fd					UnaryLen:
.14fd	20 0b 15	jsr $150b			jsr 	ULStart
.1500					ULFinish:
.1500	b1 04		lda ($04),y			lda 	(temp0),y
.1502	a4 0a		ldy $0a				ldy 	tempShort
.1504	20 9e 18	jsr $189e			jsr 	MInt32Set8Bit
.1507	20 f7 18	jsr $18f7			jsr 	CheckRightParen
.150a	60		rts				rts
.150b	20 8f 14	jsr $148f	ULStart:jsr 	EvaluateString
.150e	b5 48		lda $48,x			lda 	esInt0,x 					; copy address of string to temp0
.1510	85 04		sta $04				sta 	temp0
.1512	b5 50		lda $50,x			lda 	esInt1,x
.1514	85 05		sta $05				sta 	temp0+1
.1516	84 0a		sty $0a				sty 	tempShort 					; get length
.1518	a0 00		ldy #$00			ldy 	#0
.151a	60		rts				rts
.151b					UnaryAsc:
.151b	20 0b 15	jsr $150b			jsr 	ULStart 					; same as LEN() get string, save Y, point to length.
.151e	b1 04		lda ($04),y			lda 	(temp0),y
.1520	c8		iny				iny 		 						; point to first character, we can do LEN code after that
.1521	c9 00		cmp #$00			cmp 	#0
.1523	d0 db		bne $1500			bne 	ULFinish
.1525	a2 07		ldx #$07			ldx 	#ErrorID_BadValue
.1527	20 1a 19	jsr $191a			jsr 	ErrorHandler
.152a					UnaryAbs:
.152a	20 84 14	jsr $1484			jsr 	EvaluateNumeric
.152d	b0 07		bcs $1536			bcs 	_UAFloat
.152f	20 44 18	jsr $1844			jsr 	MInt32Absolute
.1532	20 f7 18	jsr $18f7			jsr 	CheckRightParen
.1535	60		rts				rts
.1536					_UAFloat:
.1536	8a		txa				txa
.1537	a2 02		ldx #$02		ldx	#2
.1539	20 21 19	jsr $1921		jsr	floatingpointHandler
.153c	aa		tax				tax
.153d	20 f7 18	jsr $18f7			jsr 	CheckRightParen
.1540	60		rts				rts
.1541					UnarySgn:
.1541	20 84 14	jsr $1484			jsr 	EvaluateNumeric
.1544	b0 07		bcs $154d			bcs 	_USFloat
.1546	20 7c 18	jsr $187c			jsr 	MInt32Sign
.1549	20 f7 18	jsr $18f7			jsr 	CheckRightParen
.154c	60		rts				rts
.154d					_USFloat:
.154d	8a		txa				txa
.154e	a2 10		ldx #$10		ldx	#16
.1550	20 21 19	jsr $1921		jsr	floatingpointHandler
.1553	aa		tax				tax
.1554	20 f7 18	jsr $18f7			jsr 	CheckRightParen
.1557	60		rts				rts
.1558					UnaryPeek:
.1558	20 84 15	jsr $1584			jsr 	PDLCode
.155b	4c 78 15	jmp $1578			jmp 	PDLByte0
.155e					UnaryDeek:
.155e	20 84 15	jsr $1584			jsr 	PDLCode
.1561	4c 72 15	jmp $1572			jmp 	PDLByte1
.1564					UnaryLeek:
.1564	20 84 15	jsr $1584			jsr 	PDLCode
.1567	a0 03		ldy #$03			ldy 	#3
.1569	b1 04		lda ($04),y			lda 	(temp0),y
.156b	95 60		sta $60,x			sta 	esInt3,x
.156d	88		dey				dey
.156e	b1 04		lda ($04),y			lda 	(temp0),y
.1570	95 58		sta $58,x			sta 	esInt2,x
.1572					PDLByte1:
.1572	a0 01		ldy #$01			ldy 	#1
.1574	b1 04		lda ($04),y			lda 	(temp0),y
.1576	95 50		sta $50,x			sta 	esInt1,x
.1578					PDLByte0:
.1578	a0 00		ldy #$00			ldy 	#0
.157a	b1 04		lda ($04),y			lda 	(temp0),y
.157c	95 48		sta $48,x			sta 	esInt0,x
.157e	a4 0a		ldy $0a				ldy 	tempShort 					; restore Y
.1580	20 f7 18	jsr $18f7			jsr 	CheckRightParen 			; check right and return
.1583	60		rts				rts
.1584					PDLCode:
.1584	20 98 14	jsr $1498			jsr 	EvaluateInteger
.1587	b5 48		lda $48,x			lda 	esInt0,x 					; copy address of string to temp0
.1589	85 04		sta $04				sta 	temp0
.158b	b5 50		lda $50,x			lda 	esInt1,x
.158d	85 05		sta $05				sta 	temp0+1
.158f	a9 00		lda #$00			lda 	#0 							; zero upper 3 bytes of result, type okay.
.1591	95 50		sta $50,x			sta 	esInt1,x
.1593	95 58		sta $58,x			sta 	esInt2,x
.1595	95 60		sta $60,x			sta 	esInt3,x
.1597	84 0a		sty $0a				sty 	tempShort 					; save Y
.1599	60		rts				rts
.159a					Unary_Random:
.159a	20 bf 18	jsr $18bf			jsr 	MInt32Random 				; generate random number.
.159d	b1 02		lda ($02),y			lda 	(codePtr),y 				; check followed by )
.159f	c9 c1		cmp #$c1			cmp 	#TKW_RPAREN
.15a1	f0 08		beq $15ab			beq 	_URExit
.15a3	e8		inx				inx 								; load range 0..r-1 into +1
.15a4	20 98 14	jsr $1498			jsr 	EvaluateInteger
.15a7	ca		dex				dex
.15a8	20 0d 17	jsr $170d			jsr 	MInt32Modulus 				; calculate random % modulus
.15ab					_URExit:
.15ab	20 f7 18	jsr $18f7			jsr 	CheckRightParen 			; check right and return
.15ae	60		rts				rts
.15af					Unary_Min:
.15af	a9 01		lda #$01			lda 	#1 							; c1 cmp c2 needs to be > e.g. c1 > c2
.15b1	d0 02		bne $15b5			bne 	UnaryMBody
.15b3					Unary_Max:
.15b3	a9 ff		lda #$ff			lda 	#$FF 						; c1 cmp c2 needs to be < e.g. c1 < c2
.15b5					UnaryMBody:
.15b5	48		pha				pha 								; save comparator on stack.
.15b6	20 7b 14	jsr $147b			jsr 	Evaluate 					; get the first thing to check
.15b9					_UnaryMLoop:
.15b9	b1 02		lda ($02),y			lda 	(codePtr),y 				; found ), indicates end.
.15bb	c8		iny				iny
.15bc	c9 c1		cmp #$c1			cmp 	#TKW_RPAREN
.15be	f0 09		beq $15c9			beq 	_UnaryMExit
.15c0	c9 c3		cmp #$c3			cmp 	#TKW_COMMA 					; found , indicates more.
.15c2	f0 07		beq $15cb			beq 	_UnaryMCompare
.15c4	a2 01		ldx #$01			ldx 	#ErrorID_Syntax
.15c6	20 1a 19	jsr $191a			jsr 	ErrorHandler
.15c9					_UnaryMExit:
.15c9	68		pla				pla 								; throw comparator and return.
.15ca	60		rts				rts
.15cb					_UnaryMCompare:
.15cb	e8		inx				inx 								; get the 2nd thing to evaluate
.15cc	20 7b 14	jsr $147b			jsr 	Evaluate
.15cf	ca		dex				dex
.15d0	20 b0 12	jsr $12b0			jsr 	PerformComparison 			; this is part of evaluate/compare.asm
.15d3	85 0a		sta $0a				sta 	tempShort 					; save result
.15d5	68		pla				pla 								; get what we need
.15d6	48		pha				pha
.15d7	c5 0a		cmp $0a				cmp 	tempShort 					; did we get it
.15d9	d0 de		bne $15b9			bne 	_UnaryMLoop 				; no, try another value.
.15db	20 8f 18	jsr $188f			jsr 	MInt32False 				; promote 2nd to 1st.
.15de	20 81 17	jsr $1781			jsr 	MInt32Add
.15e1	4c b9 15	jmp $15b9			jmp 	_UnaryMLoop
.15e4					Unary_Page:
.15e4	20 8f 18	jsr $188f			jsr 	MInt32False 				; zero
.15e7	ad 68 08	lda $0868			lda 	basePage 					; copy base page address in.
.15ea	95 48		sta $48,x			sta 	esInt0,x
.15ec	ad 69 08	lda $0869			lda 	basePage+1
.15ef	95 50		sta $50,x			sta 	esInt1,x
.15f1	60		rts				rts
.15f2					UnaryReference:
.15f2	a9 0f		lda #$0f			lda 	#15
.15f4	20 72 13	jsr $1372			jsr 	EvaluateLevel 				; evaluate term and don't deference.
.15f7	b5 40		lda $40,x			lda 	esType,x 					; check it's a reference.
.15f9	10 05		bpl $1600			bpl 	UType
.15fb	a9 00		lda #$00			lda 	#0 							; make it an integer
.15fd	95 40		sta $40,x			sta 	esType,x
.15ff	60		rts				rts
.1600					UType:
.1600	a2 06		ldx #$06			ldx 	#ErrorID_BadType
.1602	20 1a 19	jsr $191a			jsr 	ErrorHandler
.1605					UnaryHexMarker:
.1605	4c 6c 14	jmp $146c			jmp 	EvaluateIntegerTerm
.1608					UnaryComplement:
.1608	20 6c 14	jsr $146c			jsr 	EvaluateIntegerTerm
.160b	20 63 18	jsr $1863			jsr 	MInt32Not
.160e	60		rts				rts

;******  Return to file: ..\source\main/main.asm


;******  Processing file: ..\source\main/imath/int32binary.asm

.160f					MInt32And:
.160f	b5 48		lda $48,x			lda 	esInt0,x
.1611	35 49		and $49,x			and 	esInt0+1,x
.1613	95 48		sta $48,x			sta 	esInt0,x
.1615	b5 50		lda $50,x			lda 	esInt1,x
.1617	35 51		and $51,x			and 	esInt1+1,x
.1619	95 50		sta $50,x			sta 	esInt1,x
.161b	b5 58		lda $58,x			lda 	esInt2,x
.161d	35 59		and $59,x			and 	esInt2+1,x
.161f	95 58		sta $58,x			sta 	esInt2,x
.1621	b5 60		lda $60,x			lda 	esInt3,x
.1623	35 61		and $61,x			and 	esInt3+1,x
.1625	95 60		sta $60,x			sta 	esInt3,x
.1627	60		rts				rts
.1628					MInt32Or:
.1628	b5 48		lda $48,x			lda 	esInt0,x
.162a	15 49		ora $49,x			ora 	esInt0+1,x
.162c	95 48		sta $48,x			sta 	esInt0,x
.162e	b5 50		lda $50,x			lda 	esInt1,x
.1630	15 51		ora $51,x			ora 	esInt1+1,x
.1632	95 50		sta $50,x			sta 	esInt1,x
.1634	b5 58		lda $58,x			lda 	esInt2,x
.1636	15 59		ora $59,x			ora 	esInt2+1,x
.1638	95 58		sta $58,x			sta 	esInt2,x
.163a	b5 60		lda $60,x			lda 	esInt3,x
.163c	15 61		ora $61,x			ora 	esInt3+1,x
.163e	95 60		sta $60,x			sta 	esInt3,x
.1640	60		rts				rts
.1641					MInt32Xor:
.1641	b5 48		lda $48,x			lda 	esInt0,x
.1643	55 49		eor $49,x			eor 	esInt0+1,x
.1645	95 48		sta $48,x			sta 	esInt0,x
.1647	b5 50		lda $50,x			lda 	esInt1,x
.1649	55 51		eor $51,x			eor 	esInt1+1,x
.164b	95 50		sta $50,x			sta 	esInt1,x
.164d	b5 58		lda $58,x			lda 	esInt2,x
.164f	55 59		eor $59,x			eor 	esInt2+1,x
.1651	95 58		sta $58,x			sta 	esInt2,x
.1653	b5 60		lda $60,x			lda 	esInt3,x
.1655	55 61		eor $61,x			eor 	esInt3+1,x
.1657	95 60		sta $60,x			sta 	esInt3,x
.1659	60		rts				rts

;******  Return to file: ..\source\main/main.asm


;******  Processing file: ..\source\main/imath/int32compare.asm

.165a					MInt32Compare:
.165a	b5 48		lda $48,x			lda 	esInt0,x 					; equality check.
.165c	d5 49		cmp $49,x			cmp 	esInt0+1,x
.165e	d0 13		bne $1673			bne 	MInt32Compare2
.1660	b5 50		lda $50,x			lda 	esInt1,x
.1662	d5 51		cmp $51,x			cmp 	esInt1+1,x
.1664	d0 0d		bne $1673			bne 	MInt32Compare2
.1666	b5 58		lda $58,x			lda 	esInt2,x
.1668	d5 59		cmp $59,x			cmp 	esInt2+1,x
.166a	d0 07		bne $1673			bne 	MInt32Compare2
.166c	b5 60		lda $60,x			lda 	esInt3,x
.166e	55 61		eor $61,x			eor 	esInt3+1,x 					; will return 0 if the same.
.1670	d0 01		bne $1673			bne 	MInt32Compare2
.1672	60		rts				rts
.1673					MInt32Compare2:
.1673	b5 48		lda $48,x			lda		esInt0,x 					; unsigned 32 bit comparison.
.1675	d5 49		cmp $49,x			cmp 	esInt0+1,x
.1677	b5 50		lda $50,x			lda		esInt1,x
.1679	f5 51		sbc $51,x			sbc 	esInt1+1,x
.167b	b5 58		lda $58,x			lda		esInt2,x
.167d	f5 59		sbc $59,x			sbc 	esInt2+1,x
.167f	b5 60		lda $60,x			lda		esInt3,x
.1681	f5 61		sbc $61,x			sbc 	esInt3+1,x
.1683	50 02		bvc $1687			bvc 	_I32LNoOverflow 			; make it signed 32 bi comparison
.1685	49 80		eor #$80			eor 	#$80
.1687					_I32LNoOverflow
.1687	30 03		bmi $168c			bmi 	MInt32CLess					; if -ve then return $FF
.1689	a9 01		lda #$01			lda 	#$01						; else return $01
.168b	60		rts				rts
.168c					MInt32CLess:
.168c	a9 ff		lda #$ff			lda 	#$FF
.168e	60		rts				rts

;******  Return to file: ..\source\main/main.asm


;******  Processing file: ..\source\main/imath/int32divide.asm

.168f					MInt32SDivide:
.168f	98		tya				tya  								; save Y, which is the count of negations
.1690	48		pha				pha
.1691	a0 00		ldy #$00			ldy 	#0 							; zero count
.1693	20 ab 16	jsr $16ab			jsr 	_MInt32SRemSign 			; unsign TOS
.1696	e8		inx				inx 								; unsign TOS+1
.1697	20 ab 16	jsr $16ab			jsr 	_MInt32SRemSign
.169a	ca		dex				dex
.169b	98		tya				tya 								; save sign count on stack
.169c	48		pha				pha
.169d	20 b4 16	jsr $16b4			jsr 	MInt32UDivide 				; unsigned division
.16a0	68		pla				pla 								; get sign count back
.16a1	29 01		and #$01			and 	#1 							; if it is odd, then negate result
.16a3	f0 03		beq $16a8			beq 	_I32SNoNeg
.16a5	20 49 18	jsr $1849			jsr 	MInt32Negate
.16a8					_I32SNoNeg:
.16a8	68		pla				pla 								; restoe Y and exit
.16a9	a8		tay				tay
.16aa	60		rts				rts
.16ab					_MInt32SRemSign:
.16ab	b5 60		lda $60,x			lda 	esInt3,x 					; is it -ve
.16ad	10 04		bpl $16b3			bpl 	_MInt32SRSExit
.16af	c8		iny				iny 								; increment the sign count
.16b0	20 49 18	jsr $1849			jsr 	MInt32Negate 				; negate the value.
.16b3					_MInt32SRSExit:
.16b3	60		rts				rts
.16b4					MInt32UDivide:
.16b4	b5 49		lda $49,x			lda 	esInt0+1,x 					; check for division by zero
.16b6	15 51		ora $51,x			ora 	esInt1+1,x
.16b8	15 52		ora $52,x			ora 	esInt1+2,x
.16ba	15 53		ora $53,x			ora 	esInt1+3,x
.16bc	f0 4a		beq $1708			beq 	_MInt32DZero
.16be	e8		inx				inx 								; clear A
.16bf	e8		inx				inx
.16c0	20 8f 18	jsr $188f			jsr 	MInt32False
.16c3	ca		dex				dex
.16c4	ca		dex				dex
.16c5	98		tya				tya 								; save Y on the stack
.16c6	48		pha				pha
.16c7	a0 20		ldy #$20			ldy 	#32 						; number of division passes
.16c9					_MInt32UDLoop:
.16c9	16 48		asl $48,x			asl 	esInt0,x					; shift QA left. First Q
.16cb	36 50		rol $50,x			rol 	esInt1,x
.16cd	36 58		rol $58,x			rol 	esInt2,x
.16cf	36 60		rol $60,x			rol 	esInt3,x
.16d1	36 4a		rol $4a,x			rol 	esInt0+2,x 					; then A.
.16d3	36 52		rol $52,x			rol 	esInt1+2,x
.16d5	36 5a		rol $5a,x			rol 	esInt2+2,x
.16d7	36 62		rol $62,x			rol 	esInt3+2,x
.16d9	38		sec				sec 								; calculate A-M saving result on the stack
.16da	b5 4a		lda $4a,x			lda 	esInt0+2,x
.16dc	f5 49		sbc $49,x			sbc 	esInt0+1,x
.16de	48		pha				pha
.16df	b5 52		lda $52,x			lda 	esInt1+2,x
.16e1	f5 51		sbc $51,x			sbc 	esInt1+1,x
.16e3	48		pha				pha
.16e4	b5 5a		lda $5a,x			lda 	esInt2+2,x
.16e6	f5 59		sbc $59,x			sbc 	esInt2+1,x
.16e8	48		pha				pha
.16e9	b5 62		lda $62,x			lda 	esInt3+2,x
.16eb	f5 61		sbc $61,x			sbc 	esInt3+1,x
.16ed	90 10		bcc $16ff			bcc		_MInt32NoSubtract 			; if A < M (e.g. carry clear) then reject this.
.16ef	95 62		sta $62,x			sta 	esInt3+2,x 					; write result back to A
.16f1	68		pla				pla
.16f2	95 5a		sta $5a,x			sta 	esInt2+2,x
.16f4	68		pla				pla
.16f5	95 52		sta $52,x			sta 	esInt1+2,x
.16f7	68		pla				pla
.16f8	95 4a		sta $4a,x			sta 	esInt0+2,x
.16fa	f6 48		inc $48,x			inc 	esInt0,x 					; sets bit 0 of Q - it was shifted left previously.
.16fc	4c 02 17	jmp $1702			jmp 	_MInt32Next 					; do the next iteration
.16ff					_MInt32NoSubtract:
.16ff	68		pla				pla
.1700	68		pla				pla
.1701	68		pla				pla
.1702					_MInt32Next:
.1702	88		dey				dey 								; do this 32 times.
.1703	d0 c4		bne $16c9			bne 	_MInt32UDLoop
.1705	68		pla				pla 								; restore Y and exit
.1706	a8		tay				tay
.1707	60		rts				rts
.1708					_MInt32DZero:
.1708	a2 04		ldx #$04			ldx 	#ErrorID_DivZero
.170a	20 1a 19	jsr $191a			jsr 	ErrorHandler
.170d					MInt32Modulus:
.170d	20 b4 16	jsr $16b4			jsr 	MInt32UDivide 				; do the division.
.1710	b5 62		lda $62,x			lda 	esInt3+2,x 					; copy 2nd on stack (the remainder) to the top.
.1712	95 60		sta $60,x			sta 	esInt3,x
.1714	b5 5a		lda $5a,x			lda 	esInt2+2,x
.1716	95 58		sta $58,x			sta 	esInt2,x
.1718	b5 52		lda $52,x			lda 	esInt1+2,x
.171a	95 50		sta $50,x			sta 	esInt1,x
.171c	b5 4a		lda $4a,x			lda 	esInt0+2,x
.171e	95 48		sta $48,x			sta 	esInt0,x
.1720	60		rts				rts

;******  Return to file: ..\source\main/main.asm


;******  Processing file: ..\source\main/imath/int32fromstr.asm

.1721					MInt32FromString:
.1721	85 0a		sta $0a				sta 	tempShort 					; save base
.1723	98		tya				tya
.1724	48		pha				pha
.1725	a0 00		ldy #$00			ldy 	#0 							; set index into string being read
.1727	b1 04		lda ($04),y			lda 	(temp0),y 					; look at first character
.1729	c9 2d		cmp #$2d			cmp 	#"-"						; is it a - character
.172b	d0 01		bne $172e			bne 	_I32FSNotNegative
.172d	c8		iny				iny 								; if so consume it.
.172e					_I32FSNotNegative:
.172e	a5 0a		lda $0a				lda 	tempShort 					; get the base back.
.1730	c0 00		cpy #$00			cpy 	#0 							; if we read a -ve (e.g. Y != 0)
.1732	f0 02		beq $1736			beq 	_I32FSNN2
.1734	09 80		ora #$80			ora 	#$80						; set bit 7, this indicates a negated result.
.1736					_I32FSNN2:
.1736	48		pha				pha 								; save base + final sign on stack.
.1737	20 8f 18	jsr $188f			jsr 	MInt32False 					; zero the return value.
.173a					I32FSMainLoop:
.173a	68		pla				pla 								; get the base back into tempshort
.173b	48		pha				pha
.173c	29 7f		and #$7f			and 	#$7F
.173e	85 0a		sta $0a				sta 	tempShort
.1740	b1 04		lda ($04),y			lda 	(temp0),y 					; look at next character.
.1742	c9 61		cmp #$61			cmp 	#"a" 						; fix up case.
.1744	90 02		bcc $1748			bcc 	_I32FSNotLC
.1746	e9 20		sbc #$20			sbc 	#32
.1748					_I32FSNotLC:
.1748	38		sec				sec 								; subtract 48 (ASCII "0")
.1749	e9 30		sbc #$30			sbc 	#"0"
.174b	90 26		bcc $1773			bcc 	_I32FSDone 					; nothing more to do.
.174d	c9 0a		cmp #$0a			cmp 	#9+1 						; if it is 0-9 validate vs base.
.174f	90 06		bcc $1757			bcc 	_I32FSValidate
.1751	c9 11		cmp #$11			cmp 	#17 						; is it between 58 and 64 ? if so bad.
.1753	90 1e		bcc $1773			bcc 	_I32FSDone
.1755	e9 07		sbc #$07			sbc 	#7 							; adjust into range so now character is 0->nnn
.1757					_I32FSValidate:
.1757	c5 0a		cmp $0a				cmp 	tempShort 					; compare against the base.
.1759	b0 18		bcs $1773			bcs 	_I32FSDone 					; sorry, too large for this base.
.175b	48		pha				pha 								; save the new digit value.
.175c	e8		inx				inx 								; put base into next slot.
.175d	a5 0a		lda $0a				lda 	tempShort
.175f	20 9e 18	jsr $189e			jsr 	MInt32Set8Bit
.1762	ca		dex				dex
.1763	20 b5 17	jsr $17b5			jsr 	MInt32Multiply 				; multiply current by the base
.1766	e8		inx				inx
.1767	68		pla				pla  								; put additive into next slot
.1768	20 9e 18	jsr $189e			jsr 	MInt32Set8Bit
.176b	ca		dex				dex
.176c	20 81 17	jsr $1781			jsr 	MInt32Add 					; and add it
.176f	c8		iny				iny 								; look at next character
.1770	4c 3a 17	jmp $173a			jmp 	I32FSMainLoop 				; and go round again.
.1773					_I32FSDone:
.1773	68		pla				pla 								; get base/final sign back
.1774	10 04		bpl $177a			bpl 	_I32FSNN3
.1776	88		dey				dey 								; one fewer character to allow for the - prefix.
.1777	20 49 18	jsr $1849			jsr 	MInt32Negate 				; negate the result.
.177a					_I32FSNN3:
.177a	84 0a		sty $0a				sty 	tempShort 					; save the count of characters read
.177c	68		pla				pla
.177d	a8		tay				tay
.177e	a5 0a		lda $0a				lda 	tempShort 					; get the count of characters read into A and exit
.1780	60		rts				rts

;******  Return to file: ..\source\main/main.asm


;******  Processing file: ..\source\main/imath/int32math.asm

.1781					MInt32Add:
.1781	18		clc				clc
.1782	b5 48		lda $48,x			lda 	esInt0,x
.1784	75 49		adc $49,x			adc 	esInt0+1,x
.1786	95 48		sta $48,x			sta 	esInt0,x
.1788	b5 50		lda $50,x			lda 	esInt1,x
.178a	75 51		adc $51,x			adc 	esInt1+1,x
.178c	95 50		sta $50,x			sta 	esInt1,x
.178e	b5 58		lda $58,x			lda 	esInt2,x
.1790	75 59		adc $59,x			adc 	esInt2+1,x
.1792	95 58		sta $58,x			sta 	esInt2,x
.1794	b5 60		lda $60,x			lda 	esInt3,x
.1796	75 61		adc $61,x			adc 	esInt3+1,x
.1798	95 60		sta $60,x			sta 	esInt3,x
.179a	60		rts				rts
.179b					MInt32Sub:
.179b	38		sec				sec
.179c	b5 48		lda $48,x			lda 	esInt0,x
.179e	f5 49		sbc $49,x			sbc 	esInt0+1,x
.17a0	95 48		sta $48,x			sta 	esInt0,x
.17a2	b5 50		lda $50,x			lda 	esInt1,x
.17a4	f5 51		sbc $51,x			sbc 	esInt1+1,x
.17a6	95 50		sta $50,x			sta 	esInt1,x
.17a8	b5 58		lda $58,x			lda 	esInt2,x
.17aa	f5 59		sbc $59,x			sbc 	esInt2+1,x
.17ac	95 58		sta $58,x			sta 	esInt2,x
.17ae	b5 60		lda $60,x			lda 	esInt3,x
.17b0	f5 61		sbc $61,x			sbc 	esInt3+1,x
.17b2	95 60		sta $60,x			sta 	esInt3,x
.17b4	60		rts				rts

;******  Return to file: ..\source\main/main.asm


;******  Processing file: ..\source\main/imath/int32multiply.asm

.17b5					MInt32Multiply:
.17b5	e8		inx				inx 								; copy 2nd -> 3rd
.17b6	20 db 17	jsr $17db			jsr 	MInt32CopyUp
.17b9	ca		dex				dex
.17ba	20 db 17	jsr $17db			jsr 	MInt32CopyUp 				; copy 1st -> 2nd
.17bd	20 8f 18	jsr $188f			jsr 	MInt32False 					; zero 1st.
.17c0					_I32Loop:
.17c0	b5 4a		lda $4a,x			lda 	esInt0+2,x 					; get low bit of 3rd
.17c2	29 01		and #$01			and 	#1
.17c4	f0 03		beq $17c9			beq 	_I32NoAdd 					; if set
.17c6	20 81 17	jsr $1781			jsr 	MInt32Add 					; add 2nd to 1st.
.17c9					_I32NoAdd:
.17c9	e8		inx				inx 								; shift 2nd left
.17ca	20 a4 18	jsr $18a4			jsr 	MInt32ShiftLeft
.17cd	e8		inx				inx  								; shift 3rd right
.17ce	20 ad 18	jsr $18ad			jsr 	MInt32ShiftRight
.17d1	20 b6 18	jsr $18b6			jsr 	MInt32Zero 					; check if zero.
.17d4	08		php				php 								; save status bits
.17d5	ca		dex				dex 	 							; point back to 1st
.17d6	ca		dex				dex
.17d7	28		plp				plp 								; get status bits
.17d8	d0 e6		bne $17c0			bne 	_I32Loop 					; if non-zero keep going.
.17da	60		rts				rts
.17db					MInt32CopyUp:
.17db	b5 48		lda $48,x			lda 	esInt0,x
.17dd	95 49		sta $49,x			sta 	esInt0+1,x
.17df	b5 50		lda $50,x			lda 	esInt1,x
.17e1	95 51		sta $51,x			sta 	esInt1+1,x
.17e3	b5 58		lda $58,x			lda 	esInt2,x
.17e5	95 59		sta $59,x			sta 	esInt2+1,x
.17e7	b5 60		lda $60,x			lda 	esInt3,x
.17e9	95 61		sta $61,x			sta 	esInt3+1,x
.17eb	60		rts				rts

;******  Return to file: ..\source\main/main.asm


;******  Processing file: ..\source\main/imath/int32tostr.asm

>086a					MCharCount:	.fill 	1						; count of converted characters
.17ec					MInt32ToString:
.17ec	48		pha				pha 								; save base
.17ed	85 0a		sta $0a				sta 	tempShort 					; save target base.
.17ef	a9 00		lda #$00			lda 	#0
.17f1	8d 6a 08	sta $086a			sta 	MCharCount 					; clear character count.
.17f4	98		tya				tya
.17f5	48		pha				pha
.17f6	a5 0a		lda $0a				lda 	tempShort 					; check if we are signed conversion
.17f8	10 10		bpl $180a			bpl 	_I32TSUnsigned
.17fa	48		pha				pha 								; save base on stack.
.17fb	b5 60		lda $60,x			lda 	esInt3,x 					; is it actually negative
.17fd	10 08		bpl $1807			bpl 	_I32TSNoFlip
.17ff	a9 2d		lda #$2d			lda 	#"-" 						; write a '-' prefix out.
.1801	20 36 18	jsr $1836			jsr 	MI32WriteCharacter
.1804	20 49 18	jsr $1849			jsr 	MInt32Negate 				; negate the value.
.1807					_I32TSNoFlip:
.1807	68		pla				pla 								; get the base back
.1808	29 7f		and #$7f			and 	#$7F 						; clear the sign flag so it's just a base now.
.180a					_I32TSUnsigned:
.180a	20 11 18	jsr $1811			jsr 	MI32DivideWrite 				; recursive code to output string.
.180d	68		pla				pla
.180e	a8		tay				tay
.180f	68		pla				pla
.1810	60		rts				rts
.1811					MI32DivideWrite:
.1811	48		pha				pha 								; save the divisor/base
.1812	e8		inx				inx 								; write in the dividing position.
.1813	20 9e 18	jsr $189e			jsr 	MInt32Set8Bit
.1816	ca		dex				dex
.1817	20 b4 16	jsr $16b4			jsr 	MInt32UDivide 				; divide number by base.
.181a	68		pla				pla 								; get the base into Y
.181b	a8		tay				tay
.181c	b5 4a		lda $4a,x			lda 	esInt0+2,x 					; get the remainder and push on the stack.
.181e	48		pha				pha
.181f	20 b6 18	jsr $18b6			jsr 	MInt32Zero 					; is the result zero ?
.1822	f0 04		beq $1828			beq 	_I32NoRecurse 				; if so, don't recurse.
.1824	98		tya				tya 								; put base into A
.1825	20 11 18	jsr $1811			jsr 	MI32DivideWrite 				; and jsr the dividor recursively.
.1828					_I32NoRecurse:
.1828	68		pla				pla 								; get the remainder back
.1829	c9 0a		cmp #$0a			cmp 	#10  						; handle hexadecimals.
.182b	90 02		bcc $182f			bcc 	_I32NotHex
.182d	69 06		adc #$06			adc 	#7-1
.182f					_I32NotHex:
.182f	18		clc				clc 								; make it ASCII
.1830	69 30		adc #$30			adc 	#48
.1832	20 36 18	jsr $1836			jsr 	MI32WriteCharacter 			; write the character out
.1835	60		rts				rts 								; and exit.
.1836					MI32WriteCharacter:
.1836	ac 6a 08	ldy $086a			ldy 	MCharCount 					; get position
.1839	91 04		sta ($04),y			sta 	(temp0),y 					; write out with trailing 0
.183b	c8		iny				iny
.183c	a9 00		lda #$00			lda 	#0
.183e	91 04		sta ($04),y			sta 	(temp0),y
.1840	ee 6a 08	inc $086a			inc 	MCharCount 					; bump count
.1843	60		rts				rts

;******  Return to file: ..\source\main/main.asm


;******  Processing file: ..\source\main/imath/int32unary.asm

>086b					MSeed32:	.fill 	4							; random number seed.
.1844					MInt32Absolute:
.1844	b5 60		lda $60,x			lda 	esInt3,x 					; use negate code if -ve.
.1846	30 01		bmi $1849			bmi 	MInt32Negate
.1848	60		rts				rts
.1849					MInt32Negate:
.1849	38		sec				sec
.184a	a9 00		lda #$00			lda 	#0
.184c	f5 48		sbc $48,x			sbc 	esInt0,x
.184e	95 48		sta $48,x			sta 	esInt0,x
.1850	a9 00		lda #$00			lda 	#0
.1852	f5 50		sbc $50,x			sbc 	esInt1,x
.1854	95 50		sta $50,x			sta 	esInt1,x
.1856	a9 00		lda #$00			lda 	#0
.1858	f5 58		sbc $58,x			sbc 	esInt2,x
.185a	95 58		sta $58,x			sta 	esInt2,x
.185c	a9 00		lda #$00			lda 	#0
.185e	f5 60		sbc $60,x			sbc 	esInt3,x
.1860	95 60		sta $60,x			sta 	esInt3,x
.1862	60		rts				rts
.1863					MInt32Not:
.1863	b5 48		lda $48,x			lda 	esInt0,x
.1865	49 ff		eor #$ff			eor 	#$FF
.1867	95 48		sta $48,x			sta 	esInt0,x
.1869	b5 50		lda $50,x			lda 	esInt1,x
.186b	49 ff		eor #$ff			eor 	#$FF
.186d	95 50		sta $50,x			sta 	esInt1,x
.186f	b5 58		lda $58,x			lda 	esInt2,x
.1871	49 ff		eor #$ff			eor 	#$FF
.1873	95 58		sta $58,x			sta 	esInt2,x
.1875	b5 60		lda $60,x			lda 	esInt3,x
.1877	49 ff		eor #$ff			eor 	#$FF
.1879	95 60		sta $60,x			sta 	esInt3,x
.187b	60		rts				rts
.187c					MInt32Sign:
.187c	b5 60		lda $60,x			lda 	esInt3,x					; look at MSB
.187e	30 0b		bmi $188b			bmi 	MInt32True 					; if set return -1 (true)
.1880	20 b6 18	jsr $18b6			jsr 	MInt32Zero 					; is it zero ?
.1883	f0 0a		beq $188f			beq 	MInt32False 					; if zero return 0 (false)
.1885	20 8f 18	jsr $188f			jsr 	MInt32False 					; > 0 return 1
.1888	f6 48		inc $48,x			inc 	esInt0,x
.188a	60		rts				rts
.188b					MInt32True:
.188b	a9 ff		lda #$ff			lda 	#$FF 						; set to $FFFFFFFF
.188d	d0 02		bne $1891			bne 	MInt32WriteAll
.188f					MInt32False:
.188f	a9 00		lda #$00			lda 	#0
.1891					MInt32WriteAll:
.1891	95 48		sta $48,x			sta 	esInt0,x
.1893					MInt32Write123:
.1893	95 50		sta $50,x			sta 	esInt1,x
.1895	95 58		sta $58,x			sta 	esInt2,x
.1897	95 60		sta $60,x			sta 	esInt3,x
.1899	a9 00		lda #$00			lda 	#$00						; and make it an integer
.189b	95 40		sta $40,x			sta 	esType,x
.189d	60		rts				rts
.189e					MInt32Set8Bit:
.189e	95 48		sta $48,x			sta 	esInt0,x
.18a0	a9 00		lda #$00			lda 	#0
.18a2	f0 ef		beq $1893			beq		MInt32Write123
.18a4					MInt32ShiftLeft:
.18a4	16 48		asl $48,x			asl 	esInt0,x
.18a6	36 50		rol $50,x			rol	 	esInt1,x
.18a8	36 58		rol $58,x			rol	 	esInt2,x
.18aa	36 60		rol $60,x			rol	 	esInt3,x
.18ac	60		rts				rts
.18ad					MInt32ShiftRight:
.18ad	56 60		lsr $60,x			lsr 	esInt3,x
.18af	76 58		ror $58,x			ror 	esInt2,x
.18b1	76 50		ror $50,x			ror 	esInt1,x
.18b3	76 48		ror $48,x			ror 	esInt0,x
.18b5	60		rts				rts
.18b6					MInt32Zero:
.18b6	b5 48		lda $48,x			lda 	esInt0,x
.18b8	15 50		ora $50,x			ora 	esInt1,x
.18ba	15 58		ora $58,x			ora 	esInt2,x
.18bc	15 60		ora $60,x			ora 	esInt3,x
.18be	60		rts				rts
.18bf					MInt32Random:
.18bf	98		tya				tya
.18c0	48		pha				pha
.18c1	a0 07		ldy #$07			ldy 	#7
.18c3	ad 6b 08	lda $086b			lda 	MSeed32+0
.18c6	d0 03		bne $18cb			bne 	_Random1
.18c8	a8		tay				tay
.18c9	a9 aa		lda #$aa			lda		#$AA
.18cb					_Random1:
.18cb	0a		asl a				asl 	a
.18cc	2e 6c 08	rol $086c			rol 	MSeed32+1
.18cf	2e 6d 08	rol $086d			rol 	MSeed32+2
.18d2	2e 6e 08	rol $086e			rol 	MSeed32+3
.18d5	90 02		bcc $18d9			bcc 	_Random2
.18d7	49 c5		eor #$c5			eor 	#$C5
.18d9					_Random2:
.18d9	88		dey				dey
.18da	d0 ef		bne $18cb			bne 	_Random1
.18dc	8d 6b 08	sta $086b			sta 	MSeed32+0
.18df	95 48		sta $48,x			sta 	esInt0,x
.18e1	ad 6c 08	lda $086c			lda 	MSeed32+1
.18e4	95 50		sta $50,x			sta 	esInt1,x
.18e6	ad 6d 08	lda $086d			lda 	MSeed32+2
.18e9	95 58		sta $58,x			sta 	esInt2,x
.18eb	ad 6e 08	lda $086e			lda 	MSeed32+3
.18ee	95 60		sta $60,x			sta 	esInt3,x
.18f0	68		pla				pla
.18f1	a8		tay				tay
.18f2	a9 00		lda #$00			lda 	#0
.18f4	95 40		sta $40,x			sta 	esType,x
.18f6	60		rts				rts

;******  Return to file: ..\source\main/main.asm


;******  Processing file: ..\source\main/utility/check.asm

.18f7					CheckRightParen:
.18f7	b1 02		lda ($02),y			lda 	(codePtr),y
.18f9	c8		iny				iny
.18fa	c9 c1		cmp #$c1			cmp 	#TKW_RPAREN
.18fc	d0 01		bne $18ff			bne 	_CRPError
.18fe	60		rts				rts
.18ff					_CRPError:
.18ff	a2 08		ldx #$08			ldx 	#ErrorID_MissingRP
.1901	20 1a 19	jsr $191a			jsr 	ErrorHandler
.1904					CheckComma:
.1904	b1 02		lda ($02),y			lda 	(codePtr),y
.1906	c8		iny				iny
.1907	c9 c3		cmp #$c3			cmp 	#TKW_COMMA
.1909	d0 01		bne $190c			bne 	_CCError
.190b	60		rts				rts
.190c					_CCError:
.190c	a2 09		ldx #$09			ldx 	#ErrorID_MissingComma
.190e	20 1a 19	jsr $191a			jsr 	ErrorHandler

;******  Return to file: ..\source\main/main.asm

.1911					mainHandler:
.1911	7c 14 19	jmp ($1914,x)			jmp 	(mainVectors,x)
.1914					mainVectors:

;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\assembler/assembler.asm

.1914					assemblerHandler:
.1914	7c 17 19	jmp ($1917,x)			jmp 	(assemblerVectors,x)
.1917					assemblerVectors:

;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\device/device.asm

.1917					deviceHandler:
.1917	7c 1a 19	jmp ($191a,x)			jmp 	(deviceVectors,x)
.191a					deviceVectors:

;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\error/error.asm


;******  Processing file: ..\source\error/errorhandler.asm

.191a					ErrorHandler:
.191a	a9 ee		lda #$ee			lda 	#$EE
.191c	a8		tay				tay
>191d	db						.byte 	$DB
.191e	4c 1e 19	jmp $191e	_EHHalt:jmp 	_EHHalt

;******  Return to file: ..\source\error/error.asm


;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\floatingpoint/floatingpoint.asm

.1921					floatingpointHandler:
.1921	a2 02		ldx #$02			ldx 	#ErrorID_NoModule
.1923	20 1a 19	jsr $191a			jsr 	ErrorHandler

;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\interaction/interaction.asm

.1926					interactionHandler:
.1926	7c 29 19	jmp ($1929,x)			jmp 	(interactionVectors,x)
.1929					interactionVectors:

;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\string/string.asm


;******  Processing file: ..\source\string/compare.asm

.1929					STRCompare:
>1929	db						.byte 	$DB
.192a	4c 29 19	jmp $1929			jmp 	STRCompare

;******  Return to file: ..\source\string/string.asm


;******  Processing file: ..\source\string/concat.asm

.192d					StringConcat:
>192d	db						.byte 	$DB
.192e	80 fd		bra $192d			bra 	StringConcat

;******  Return to file: ..\source\string/string.asm

.1930					stringHandler:
.1930	7c 33 19	jmp ($1933,x)			jmp 	(stringVectors,x)
.1933					stringVectors:
>1933	2d 19					.word StringConcat         ; index 0
>1935	29 19					.word STRCompare           ; index 2

;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\tokeniser/tokeniser.asm

.1937					tokeniserHandler:
.1937	7c 3a 19	jmp ($193a,x)			jmp 	(tokeniserVectors,x)
.193a					tokeniserVectors:

;******  Return to file: ..\source\basic.asm


;******  Processing file: ..\source\variable/variable.asm


;******  Processing file: ..\source\variable/access.asm

.193a					AccessVariable:
.193a	aa		tax				tax 								; stack in X
.193b	c8		iny				iny
.193c	b1 02		lda ($02),y			lda 	(codePtr),y
.193e	88		dey				dey
.193f	c9 3a		cmp #$3a			cmp 	#TYPE_INT 					; is it one of the end markers ?
.1941	d0 15		bne $1958			bne 	_AVLong
.1943	b1 02		lda ($02),y			lda 	(codePtr),y 				; this is the 6 bit ASCII of A-Z 1-26
.1945	38		sec				sec 	 							; make it 0-25
.1946	e9 01		sbc #$01			sbc 	#1
.1948	0a		asl a				asl 	a 							; x 4 is LSB of address
.1949	0a		asl a				asl 	a
.194a	95 48		sta $48,x			sta 	esInt0,x
.194c	a9 08		lda #$08			lda 	#SingleLetterVar >> 8 		; make it an address
.194e	95 50		sta $50,x			sta 	esInt1,x
.1950	a9 80		lda #$80			lda 	#$80 						; type is integer reference.
.1952	95 40		sta $40,x			sta 	esType,x
.1954	c8		iny				iny 								; skip over the variable reference in the code.
.1955	c8		iny				iny
.1956	8a		txa				txa 								; stack in A to return.
.1957	60		rts				rts
.1958					_AVLong:
.1958	80 fe		bra $1958			bra 	_AVLong

;******  Return to file: ..\source\variable/variable.asm

.195a					variableHandler:
.195a	7c 5d 19	jmp ($195d,x)			jmp 	(variableVectors,x)
.195d					variableVectors:
>195d	3a 19					.word AccessVariable       ; index 0

;******  Return to file: ..\source\basic.asm


;******  End of listing
